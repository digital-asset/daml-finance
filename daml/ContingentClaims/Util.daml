-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Util (
    fixings
  , fixings'
  , pruneZeros
  , pruneZeros'
  , expiry
  , payoffs
  , hasintrinsicAcquisitionTime
  , intrinsicAcquisitionTime
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..), Inequality(..))
import ContingentClaims.Observation (Observation)
import Daml.Control.Recursion
import DA.Foldable (fold, maximum, all)
import DA.Bifunctor (first)
import DA.Optional (isSome)
import Prelude hiding (sum, sequence, mapA, all)

-- | Return the fixing dates of a claim. This does not discriminate between
-- optional dates which *may* result from a condition, and outright fixings.  It
-- also does not correctly account for malformed trees, where subtrees are
-- orphaned due to impossible `When` statements. e.g. `When (t > 1) ((When t < 1) _)`
fixings : Claim t x a -> [t]
fixings = cata fixings'

--TODO should fail if dates will never be executed
-- | Algebra for `fixings`
fixings' : ClaimF t x a [t] -> [t]
fixings' (WhenF (TimeGte t) ts) = t :: ts
fixings' claim = fold claim

-- | Return the time after which the claim is worthless i.e. value = 0, if such a
-- time exists.  Also known as 'maturity' or 'horizon' in the Eber/Jones paper.
expiry : Ord t => Claim t x a -> Optional t
expiry c = case fixings c of
  [] -> None
  ts -> Some . maximum $ ts

-- | Return a list of possible scale-factor/payoff pairs.
-- This does not discriminate between conditional and outright payoffs.
payoffs : (Eq x, Eq a, Multiplicative x) => Claim t x a -> [(Observation t x a, a)]
payoffs = fmap (first ($ munit)) . cata payoffs'

-- | Algebra for `payoffs`. This also applies 'multiplication by one' identity,
payoffs' : (Eq x, Eq a, Multiplicative x) => ClaimF t x a [(Observation t x a -> Observation t x a, a)] -> [(Observation t x a -> Observation t x a, a)]
payoffs' ZeroF = []
payoffs' (OneF a) = [(identity, a)]
payoffs' (ScaleF k fs) = first multK <$> fs where
  multK f x | x == munit = f k -- prune unit
  multK f x = f (x * k)
payoffs' other = fold other

-- | Prunes sub-trees which are `Zero`.
pruneZeros : Claim t x a -> Claim t x a
pruneZeros = cata pruneZeros'

-- | Algebra for `pruneZeros`. N.b. the `Or` case : we only reduce the case
-- when all elements are `Zero`. It's incorrect to remove a single `Or` (as this
-- would remove a choice for 'inaction' from the bearer - think option lapse).
-- However, we don't handle the case for `Or > 1`, as this can be unintuitive
-- (although semantically correct); this may change in the future, so don't rely
-- on this behaviour.
pruneZeros' : ClaimF t x a (Claim t x a) -> Claim t x a
pruneZeros' (ScaleF _ Zero) = Zero
pruneZeros' (GiveF Zero) = Zero
pruneZeros' (AndF c c' cs) = case filter (not . isZero) (c :: c' :: cs) of
  [] -> Zero
  [c] -> c
  c :: c' :: cs -> And c c' cs
pruneZeros' (WhenF _ Zero) = Zero
pruneZeros' (CondF _ Zero Zero) = Zero
pruneZeros' ors@OrF{} | isZero `all` ors = Zero
pruneZeros' (UntilF _ Zero) = Zero
pruneZeros' (AnytimeF _ Zero) = Zero
pruneZeros' other = embed other

-- | This avoids requiring the equality type constraint on `a`
isZero Zero = True
isZero _ = False

-- | Returns the claim's intrinsic acquisition time (IAT) if it exists.
-- It is defined as the time `t` such that, for the purpose of lifecycling and valuation, it is irrelevant whether the contract has been acquired at `t` or at any time `s` before `t`.
-- This check is required as currently the claim's acquisition time is not an input to `lifecycle`, which forces us to work with claims that have an IAT.
-- For instance: 
-- - `Scale obs c` does not have an IAT (as `obs` is evaluated at the claim's acquisition time)
-- - the IAT for `When (TimeGte t) c` is `t`
-- - `When (obs <= 100) c` does not have an IAT, as the acquisition time defines when we start to monitor the observable `obs`
intrinsicAcquisitionTime : (Ord t) => Claim t x a -> Optional t
intrinsicAcquisitionTime (Anytime (TimeGte t) _) = Some t
intrinsicAcquisitionTime (When (TimeGte t) _) = Some t
intrinsicAcquisitionTime (And c1 c2 cs) = foldr folder (intrinsicAcquisitionTime c1) (c2 :: cs)
  where folder = liftA2 min . intrinsicAcquisitionTime
intrinsicAcquisitionTime (Give c) = intrinsicAcquisitionTime c
intrinsicAcquisitionTime (Until (TimeGte t) c) = intrinsicAcquisitionTime c
intrinsicAcquisitionTime _ = None

-- | Returns `True` if the the claim has an intrinsic acquisition time, `False` otherwise.
hasintrinsicAcquisitionTime : (Ord t) => Claim t x a -> Bool
hasintrinsicAcquisitionTime = isSome . intrinsicAcquisitionTime

