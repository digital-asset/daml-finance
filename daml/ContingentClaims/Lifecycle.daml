{-# LANGUAGE MultiWayIf #-}
{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Lifecycle (
    lifecycle
  , lifecycle'
  , Result(..)
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..))
import ContingentClaims.Observation (Observation, eval)
import ContingentClaims.Util (cataM)
import Daml.Control.Recursion (para)
import Daml.Control.Monad.State (StateT, evalStateT)
import Daml.Control.Monad.Writer (WriterT, runWriterT)
import Daml.Control.Monad.Reader (ReaderT(..), runReaderT)
import Daml.Control.Monad.MonadState (MonadState(..), modify)
import Daml.Control.Monad.MonadReader (MonadReader(..))
import Daml.Control.Monad.MonadWriter (MonadWriter(..))
import Daml.Control.Monad.Trans
import Daml.Control.Arrow (Kleisli(..))
import Prelude hiding (sequence, mapA)
import DA.Functor (($>))

type C a = Claim Observation Date a
type F a = ClaimF Observation Date a

deriving instance Eq a => Eq (C a)

-- Returned from a lifecycle operation.
-- Remaining has the tree after lifecycled branches have been pruned.
-- Pending contains a list of quantity/asset pairs requiring settlement.
data Result a = Result with remaining: C a, pending : [(Decimal, a)]

-- @m@ will typically be @Update@. It is parametrised so it can be run in a @Script@.
-- Uses @spot@ to lookup spot prices.
-- Uses @choose@ to make an election during a branch
lifecycle : (Eq a, CanAbort m)
  => (Text -> Date -> m Decimal)
  -> (C a -> C a -> C a)
  -> C a
  -> Date -> m (Result a)
lifecycle spot choose
  = runKleisli 
  . fmap (uncurry Result) 
  . flip runReaderT 1.0 
  . runWriterT 
  . para (lifecycle' spot choose)

type Seed m a = WriterT [(Decimal, a)] (ReaderT Decimal (Kleisli m Date)) (C a)

-- TODO: these three should probably go in their respective modules

instance (Monoid w, CanAbort m) => CanAbort (WriterT w m) where
  abort = lift . abort

instance CanAbort m => CanAbort (ReaderT s m) where
  abort = lift . abort

instance CanAbort m => CanAbort (StateT s m) where
  abort = lift . abort

instance CanAbort m => CanAbort (Kleisli m a) where -- because of the order of parameters it's not possible to write a MonadTrans instance for Kleisli.
  abort = Kleisli . const . abort

lifecycle' : (Eq a, Monad m, CanAbort m)
  => (Text -> Date -> m Decimal)
  -> (C a -> C a -> C a)
  -> F a (C a, Seed m a) -> Seed m a

lifecycle' _ _ ZeroF = pure Zero
lifecycle' _ _ (OneF id) = do
  qty <- ask
  tell [(qty, id)]
  pure $ One id
lifecycle' _ _ (GiveF (_, m)) = local negate m
lifecycle' spot _ (WhenF obs (c, m)) = do
  wasLifecycled <- lift . lift $ eval spot obs
  if wasLifecycled then m $> Zero else pure $ When obs c
lifecycle' spot _ (ScaleF obs (_, m)) = do
  k <- lift . lift $ eval spot obs
  Scale obs <$> local (* k) m
lifecycle' _ choose (OrF (c, m) (c', m')) = do
  let chosen = choose c c'
  if | chosen == c -> m
     | chosen == c' -> m'
     | otherwise -> abort "lifecycle: Invalid branch election"
lifecycle' _ _ (AndF (_, m) (_, m')) = reduceZero <$> m <*> m' where
   reduceZero Zero c' = c'
   reduceZero c Zero = c
   reduceZero c c' = And c c'
lifecycle' spot _ (CondF obs (_, m) (_, m')) = do
  predicate <- lift . lift $ eval spot obs
  if predicate then m else m'
