--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

{-# LANGUAGE MultiWayIf #-}
{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Lifecycle (
    lifecycle
  , lifecycle'
  , Result(..)
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..))
import ContingentClaims.Observation (Observation, eval)
import ContingentClaims.Util (apoCataM, pruneZeros')
import Daml.Control.Monad.Writer (WriterT, runWriterT)
import Daml.Control.Monad.State (StateT(..), evalStateT)
import Daml.Control.Monad.MonadWriter (MonadWriter(..))
import Daml.Control.Monad.MonadState (MonadState(..), modify)
import Daml.Control.Monad.Trans
import Daml.Control.Arrow (Kleisli(..))
import Prelude hiding (sequence, mapA)

type C a = Claim Observation Date a
type F a = ClaimF Observation Date a

deriving instance Eq a => Eq (C a)

-- | Returned from a lifecycle operation.
data Result a = Result with
  remaining : C a
    -- ^ the tree after lifecycled branches have been pruned.
  pending : [(Decimal, a)]
    -- ^ quantity/asset pairs requiring settlement.

-- | Lifecycle a Claim. Parameters:
-- 1. Function taking key and date, used to lookup an observable on the ledger. `m` will typically be `Update`. It is parametrised so it can be run in a `Script`.
-- 2. Function used when branching in an `Or`. Must return one of the arguments.
-- 3. A set of `Claim`s.
-- 4. A function which, given a date, lifecycles the third argument.
lifecycle : (Eq a, CanAbort m)
  => (Text -> Date -> m Decimal)
  -> (C a -> C a -> C a)
  -> C a
  -> Date -> m (Result a)
lifecycle spot choose
  = runKleisli
  . fmap (uncurry Result)
  . flip evalStateT 1.0
  . runWriterT
  . apoCataM (pruneZeros') (lifecycle' spot choose)

type Seed m a = WriterT [(Decimal, a)] (StateT Decimal (Kleisli m Date)) (F a (Either (C a) (C a)))

lifecycle' : (Eq a, Monad m, CanAbort m)
  => (Text -> Date -> m Decimal)
  -> (C a -> C a -> C a)
  -> C a -> Seed m a

lifecycle' _ _ Zero = pure ZeroF
lifecycle' _ _ (One id) = do
  qty <- get
  tell [(qty, id)]
  pure ZeroF -- replace lifecycled node with zero, to avoid double-spend.
lifecycle' _ _ (Give c) = do
  modify negate 
  pure $ GiveF (Right c)
lifecycle' spot _ (When obs c) = do
  predicate <- lift . lift $ eval spot obs
  pure $ if predicate then WhenF obs (Right c) else WhenF obs (Left c)
lifecycle' spot _ (Scale obs c) = do
  k <- lift . lift $ eval spot obs
  modify (* k) 
  pure $ ScaleF obs (Right c)
lifecycle' spot choose (Or c c') = do
  let chosen = choose c c'
  if | chosen == c -> lifecycle' spot choose c --TODO: should we abort with nested choices?
     | chosen == c' -> lifecycle' spot choose c'
     | otherwise -> abort "lifecycle: Invalid branch election"
lifecycle' _ _ (And c c') = pure $ AndF (Right c) (Right c')
lifecycle' spot choose (Cond obs c c') = do
  predicate <- lift . lift $ eval spot obs
  if predicate then lifecycle' spot choose c else lifecycle' spot choose c'
