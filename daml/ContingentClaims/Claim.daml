--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

module ContingentClaims.Claim where

import Prelude hiding (or, and)
import Daml.Control.Recursion
import ContingentClaims.Claim.Serializable qualified as Serialized
import ContingentClaims.Observation (Observation)
import ContingentClaims.Observable (Inequality(..), Param, Key)
import ContingentClaims.Observable qualified as Observable
import DA.Set qualified as Set
import DA.Foldable (Foldable(..))
import DA.Traversable (Traversable(..))

type T = Claim
type F = ClaimF

-- TODO: f should depend on t ?

-- | Used to model cashflows of instruments.
-- See [quickstart](../QUICKSTART.md) for detailed explanation.
-- In Petyon-Jones' paper, this is called 'Contract'.
-- We renamed it to avoid ambiguity.
-- * `f`, `t` and `x` respectively correspond to the `Observable`, it's input type and the resulting output type.
-- * `a` is the representation of an asset, e.g. a `Text` ISIN code.
data Claim f t x a
  = Zero
      -- ^ Represents an absence of claims.
  | One a
      -- ^ The bearer acquires one unit of `a` *immediately*.
  | Give (Claim f t x a)
      -- ^ The obligations of the bearer and issuer are revesed.
  | And with lhs: Claim f t x a, rhs: Claim f t x a
      -- ^ Used to combine multiple rights together.
  | Or with lhs: Claim f t x a, rhs: Claim f t x a
      -- ^ Gives the bearer the right to choose between two claims.
  | Cond with predicate: Inequality f t x, success: Claim f t x a, failure: Claim f t x a --TODO rename predicate -> `lte` or `inequality`
      -- ^ Gives the bearer the right to the first claim if `predicate` is true, else the second claim.
  | Scale with k: f t x, claim: Claim f t x a
      -- ^ Multiplies the `claim` by `k` (which can be non-deterministic).
  | When with predicate: Inequality f t x, claim: Claim f t x a
      -- ^ Defers the acquisition of `claim` until *the first instant* that `predicate` is true.

-- | Replace parameters in an `Claim` with actual values.
mapParams :  Observable.Interpret f
          => (t -> i)
          -> (i -> t)
          -> (Param -> Key)
          -> (Param -> Decimal)
          -> Claim f i Param a -> Claim f t Decimal a
mapParams ft' ft fk fv =
  let f = Observable.mapParams ft' fk fv
  in cata \case
    ZeroF -> Zero
    OneF a -> One a
    GiveF c -> Give c
    AndF c c' -> And c c'
    OrF c c' -> Or c c'
    CondF (Lte (x, x')) c c' -> Cond (Lte(f x, f x')) c c'
    CondF (TimeGte t) c c' -> Cond (TimeGte (ft t)) c c'
    ScaleF k c -> Scale (f k) c
    WhenF (Lte (x, x')) c -> When (Lte (f x, f x')) c
    WhenF (TimeGte t) c -> When (TimeGte (ft t)) c

-- | Return the upper time bound of the obligation; `None` if it cannot be determined.
-- This is called `horizon` in the original paper.
expiry : forall f t x a . Ord t => t -> Claim f t x a -> Optional t
expiry today = cata \case
  ZeroF -> Some today
  OneF _ -> Some today
  WhenF (Observable.TimeGte t) _ -> Some t
  WhenF (Observable.Lte _) _ -> None -- technically, we _can_ determine this if it's a pure fn.
  other -> maximum other
--           AnytimeF p _ -> Observation.expiry p
--           UntilF p _ -> Observation.expiry p

-- | Extract any fixing dates that can be analytically determined.
-- An example of an expression which **can't** be determined would be:
-- ```
-- When (observe tempCelcius > 24.5) _
-- ```
fixings : forall f t x a . Ord t => t -> Claim f t x a -> Set.Set t
fixings today = cata \case
  ZeroF -> Set.fromList [today]
  OneF _ -> Set.fromList [today]
  WhenF (Observable.TimeGte t) _ -> Set.fromList [t]
  other -> fold other

-- TODO: not sure these make sense
executorOf : Party -> Party -> Claim f t x a -> Set.Set Party
executorOf bearer cpty = cata \case
  ZeroF -> mempty
  OneF _ -> Set.singleton bearer
  GiveF p -> case Set.toList p of
    [p] -> Set.singleton $ if p == bearer then cpty else bearer
    [] -> mempty
    _ -> Set.fromList [bearer, cpty]
  AndF p p' -> p <> p'
  OrF p p' -> p <> p'
  ScaleF _ p -> p
  CondF _ p p' -> p <> p'
  WhenF _ p -> p
--  AnytimeF _ p -> p
--  UntilF _ p -> p

-- TODO: not sure these make sense
isBearerExecutor : forall f t x a . Claim f t x a -> Bool
isBearerExecutor = cata \case
                    OneF _ -> True
                    GiveF p -> not p
                    ScaleF _ p -> True
                    AndF p _ -> True
                    WhenF p _ -> True
                    ZeroF -> error "Undefined: ZeroF"
                    _ -> error "Undefined: isBearerExecutor"

-- | Converts a `Serialized.Claim` read from ledger, to a more general `Claim`, for use with `Daml.Control.Recursion`.
deserialize : Serialized.Claim t x a -> Claim Observation t x a
deserialize = ana deserialize'

-- | F-algebra for `deserialize`; it can be composed in unfolds.
deserialize' : Serialized.Claim t x a -> ClaimF Observation t x a (Serialized.Claim t x a)
deserialize' Serialized.Zero = ZeroF
deserialize' (Serialized.One a) = OneF a
deserialize' (Serialized.Give c) = GiveF c
deserialize' (Serialized.And [c]) = deserialize'  c
deserialize' (Serialized.And (c :: cs)) = AndF c (Serialized.And cs)
deserialize' (Serialized.And []) = error "deserialize: Malformed `And` (should have at least two elements)"
deserialize' (Serialized.Or c c') = OrF c c'
deserialize' (Serialized.Cond k c c') = CondF (deserializeInequality k) c c'
deserialize' (Serialized.Scale k c) = ScaleF k c
deserialize' (Serialized.When p c) = WhenF (deserializeInequality p) c
--  Serialized.Anytime p c = AnytimeF p c
--  Serialized.Until p c = UntilF p c

deserializeInequality : Serialized.Inequality t x -> Inequality Observation t x
deserializeInequality (Serialized.TimeGte t) = TimeGte t
deserializeInequality (Serialized.Lte (f, f')) = Lte (f, f')

serializeInequality : Inequality Observation t x -> Serialized.Inequality t x
serializeInequality (TimeGte t) = Serialized.TimeGte t
serializeInequality (Lte (f, f')) = Serialized.Lte (f, f')

-- | Converts a `Claim` into a `Serializable.Claim`, so it can be written to the ledger.
serialize : Claim Observation t x a -> Serialized.Claim t x a
serialize = histo serialize'

-- | F-coalgebra for `serialize`; it can be composed with other folds.
serialize' : ClaimF Observation t x a (Cofree (ClaimF Observation t x a) (Serialized.Claim t x a)) -> Serialized.Claim t x a 
serialize' ZeroF = Serialized.Zero
serialize' (OneF a) = Serialized.One a
serialize' (GiveF c) = Serialized.Give c.attribute
serialize' (AndF c (Cofree (Serialized.And cs) _) ) = Serialized.And $ c.attribute :: cs
serialize' (AndF c c') = Serialized.And [c.attribute, c'.attribute]
serialize' (OrF c c') = Serialized.Or c.attribute c'.attribute
serialize' (CondF k c c') = Serialized.Cond (serializeInequality k) c.attribute c'.attribute
serialize' (ScaleF k c) = Serialized.Scale k c.attribute
serialize' (WhenF p c) = Serialized.When (serializeInequality p) c.attribute
--  Anytime p c -> Serialized.AnytimeF p c
--  Until p c -> Serialized.UntilF p c

-- | Unfixed version of `Claim`, for use with `Daml.Control.Recursion`.
data ClaimF f t x a b
  = ZeroF
  | OneF a
  | GiveF b
  | AndF with lhs: b, rhs: b
  | OrF with lhs: b, rhs: b
  | CondF with predicate: Inequality f t x, success: b, failure: b
  | ScaleF with k: f t x, claim: b
  | WhenF with predicate: Inequality f t x, claim: b
--  | AnytimeF with predicate: (f t Bool), claim: b
--  | UntilF with predicate: (f t Bool), claim: b
  deriving (Functor)

-- TODO: rename variables to be consistent with the types
instance Recursive (Claim f t x a) (ClaimF f t x a) where
  project Zero = ZeroF
  project (One a) = OneF a
  project (Give c) = GiveF c
  project (And c c') = (AndF c c')
  project (Or c c') = (OrF c c')
  project (Cond a c c') = CondF a c c'
  project (Scale k a) = ScaleF k a
  project (When o a) = WhenF o a
--  project (Anytime o a) = AnytimeF o a
--  project (Until o x) = UntilF o x

instance Corecursive (Claim f t x a) (ClaimF f t x a) where
  embed ZeroF = Zero
  embed (OneF x) = One x
  embed (GiveF a) = Give a
  embed (AndF a b) = (And a b)
  embed (OrF a b) = (Or a b)
  embed (CondF x a b) = Cond x a b
  embed (ScaleF k x) = Scale k x
  embed (WhenF o x) = When o x
--  embed (AnytimeF o x) = Anytime o x
--  embed (UntilF o x) = Until o x

instance Foldable (ClaimF f t x a) where
  foldr _ seed ZeroF = seed
  foldr _ seed (OneF _) = seed
  foldr f seed (GiveF c) = f c seed
  foldr f seed (WhenF _ c) = f c seed
  foldr f seed (ScaleF _ c) = f c seed
  foldr f seed (AndF c c') = f c $ f c' seed
  foldr f seed (OrF c c') = f c $ f c' seed
  foldr f seed (CondF _ c c') = f c $ f c' seed

instance Traversable (ClaimF g t x b) where
  sequence ZeroF = pure ZeroF
  sequence (OneF asset) = pure $ OneF asset
  sequence (GiveF fa) = GiveF <$> fa
  sequence (WhenF p fa) = WhenF p <$> fa
  sequence (ScaleF p fa) = ScaleF p <$> fa
  sequence (AndF fa fa') = AndF <$> fa <*> fa'
  sequence (OrF fa fa') = OrF <$> fa <*> fa'
  sequence (CondF p fa fa') = CondF p <$> fa <*> fa'
