-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE UndecidableInstances #-} --needed to derive Show,Eq

module Test.Lifecycle where

import ContingentClaims.Claim hiding (C, F)
import ContingentClaims.Financial (fixed, european, american)
import ContingentClaims.Lifecycle qualified as Lifecycle
import ContingentClaims.Observation qualified as O
import ContingentClaims.Util.Recursion
import ContingentClaims.Util (intrinsicAcquisitionTime)
import DA.Assert ((===))
import DA.Date (date, Month(..), toDateUTC, toGregorian)
import DA.Optional (fromSome)
import DA.Time (time)
import DA.Tuple (thd3)
import Daml.Control.Arrow ((&&&))
import Daml.Control.Monad.Trans.Writer (runWriterT)
import Daml.Control.Recursion
import Daml.Script
import Prelude hiding (enumerate, length, or, and, (<=))

type C = Claim Date Decimal Text
type F = ClaimF Date Decimal Text

-- | Assets
[a,b,c] = ["a","b","c"]

-- | Dates
today = date 1970 Jan 1
tomorrow = succ today
afterTomorrow = succ tomorrow

-- | Observations 
two : O.Observation Date Decimal Text = O.pure 2.0

-- | Functions performing observations
observe25: Text -> Date -> Script Decimal = const . const . pure $ 25.0
observeDayOfMonth _ d = pure . intToDecimal . thd3 . toGregorian $ d

-- | Inequalities
false = TimeGte $ date 3000 Jan 1
true = TimeGte $ date 1970 Jan 1

-- | Helper functions
getDate = toDateUTC <$> getTime
setDate = setTime . noon where noon d = time d 12 0 0

-- | This test marks leaves (i.e. `one`/`zero`) with `acquired` if they were reached.
-- It also removes intermediate `when`/`cond` so they are not processed twice, accidentaly.
testAcquire = script do
  let acquiredF asset = OneF $ "acquired " <> asset
      acquired asset : C = embed $ acquiredF asset
      g acqTime c t =
        apoM coalg (acqTime,c)
        where 
          coalg = fmap process . (Lifecycle.acquire' observe25 t)
          process (OneF asset) = acquiredF asset
          process ZeroF = acquiredF "0"
          process other = other 

      f c = g (fromSome $ intrinsicAcquisitionTime c) c

  res <- g today (one a) today
  res === acquired a

  res <- g today zero tomorrow
  res === acquired "0"

  res <- f (when (at tomorrow) $ scale two (one a)) today
  res === when (at tomorrow) (scale two (one a))

  res <- f (when (at tomorrow) $ scale two (one a)) tomorrow
  res === when (at tomorrow) (scale two (acquired a))

  res <- g today (cond (at tomorrow) (one a) (one b)) today
  res === acquired b

  res <- g tomorrow (cond (at tomorrow) (one a) (one b)) tomorrow
  res === acquired a

{- FIXME: confirm if this test makes sense; it broke when we changed observable with inequality
  res <- f (when (O.TimeGte today) (when (O.TimeGte tomorrow) (one a)) ) tomorrow
  res === (when (O.TimeGte today) (when (at tomorrow) (one a)) )
-}

  res <- f (when (TimeGte today) (when (TimeGte tomorrow) (one a)) ) tomorrow
  res === when (TimeGte today) (when (TimeGte tomorrow) (acquired a))

  res <- g today (one a `or` one b) today
  res === acquired a `or` acquired b

  res <- f (anytime true (one a)) today
  res === anytime true (acquired a)

  res <- f (anytime false (one a)) today
  res === anytime false (one a)

  res <- g today (until false (one a)) today
  res === until false (acquired a)

  res <- g today (until true (one a)) today
  res === until true (acquired a)

-- | This test replaces all leaves with zeros, logging their qty/asset pair into a `Writer`.
-- It ignores `when/cond` nodes altogether.
testSettle = script do
  let f = fmap (uncurry $ flip Lifecycle.Result)
          . runWriterT
          . apoM coalg
          . (1.0, )
          where
            coalg = (Lifecycle.lifecycle' observe25) . process
            process = fmap ( Prelude.fst &&& acquired) -- process the input so that lifecycle' <<< process is a co-algebra that can be used for testing
            acquired (t,c) = Right . (t, ) <$> project c -- map a claim to an acquired claim


  Lifecycle.Result{pending, remaining} <- f (today, scale two zero)
  remaining === scale two zero
  pending === []

  Lifecycle.Result{pending, remaining} <- f (today, scale two (one a))
  remaining === scale two zero
  pending === [(2.0, a)]

  Lifecycle.Result{pending, remaining} <- f (today, give (one a))
  remaining === give zero
  pending === [(-1.0 , a)]

  Lifecycle.Result{pending, remaining} <- f (today, scale two (one a `and` one b))
  remaining === scale two (zero `And` zero $ []) -- using the explicit constructor because the smart constructor reduces this to `Zero`
  pending === [(2.0, a), (2.0, b)]

  Lifecycle.Result{pending, remaining} <- f (today, scale two (one a) `and` scale two (one b))
  remaining === scale two zero `and` scale two zero
  pending === [(2.0, a), (2.0, b)]

  -- This is a case we don't hit in practice, as it is prevented from acquire'
  Lifecycle.Result{pending, remaining} <- f (today, when false (one a))
  remaining === when false zero
  pending === pure (1.0, a)

  Lifecycle.Result{pending, remaining} <- f (today, anytime true (one a))
  remaining === anytime true (one a)
  pending === []

  -- There is no need to test what happens with `Cond` nodes, because lifecycle' is always used in combination with acquire' (which consume `Cond` nodes)

  pure ()

-- | Replace any `or/anytime` nodes with the elections that have been made.
testExercise = script do
  let acquired (t,c) = Right . (t, ) <$> project c -- map a claim to an acquired claim
      process = fmap ( Prelude.fst &&& acquired) -- process the input so that exercise' <<< process is a co-algebra that can be used for testing
      coalg election today = (Lifecycle.exercise' election today) . process
      f election = apo (coalg election today) . (True, )

  let rem = f (True, one a) (today, one a `or` one b)
  rem === one a

  let rem = f (True, one b) (today, one a `or` one b)
  rem === one b

  let rem = f (True, one c) (today, one a `or` one b)
  rem === one a `or` one b

  let rem = f (True, one a) (today, anytime true $ one a)
  rem === When (TimeGte today) (one a)

  -- n.b. conditions are handled by the `Lifecyle.acquire'` function, so in practice we should never hit this case
  let rem = f (True, one a) (today, anytime false $ one a)
  rem === When (TimeGte today) (one a)

  let rem = f (True, one c) (today, anytime true $ one a)
  rem === anytime true (one a)

  -- nested choice: the outer one must be exercised before the inner!
  let rem = f (True, one a) (today, anytime true $ anytime true $ one a)
  rem === (anytime true (anytime true (one a)))

  -- wrong `Or` election date
  let rem = apo (coalg (True, one a) tomorrow) . (True, ) . (today, ) $ one a `or` one b
  rem === one a `or` one b

  -- wrong `Anytime` election date
  -- This case should never happen in practice as it is prevented by acquire'
  let rem = apo (coalg (True, one a) tomorrow) . (True, ) . (today, ) $ anytime true (one a)
  rem === anytime true (one a)


testgiveExercise = script do
  let f election = apo (coalg election today) . (True, )
        where
          coalg election today = (Lifecycle.exercise' election today) . (fmap ( Prelude.fst &&& acquired))
          acquired (t,c) = Right . (t, ) <$> project c -- map a claim to an acquired claim

  let rem = f (False, one a) (today, anytime true (one a))
  rem === (anytime true (one a))

  let rem = f (False, one a) (today, give (anytime true (one a)))
  rem === give (When (TimeGte today) (one a))

  let rem = f (True, one a) (today, give . give . anytime true $ one a)
  rem === give (give (When (TimeGte today) (one a)))

-- | Lifecycle a bond with three fixing dates. Uses ledger time effects.
testBond = script do
  let principal = 1_000.0
      coupon = principal * 0.015
      bond = fixed principal coupon a

  setDate today
  t <- getDate

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 (bond [today, tomorrow, afterTomorrow]) t
  remaining === bond [tomorrow, afterTomorrow]
  pending === [(coupon, a)]

  setDate tomorrow
  t <- getDate

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 remaining t
  remaining === bond [afterTomorrow]
  pending === [(coupon, a)]

  -- Check bond coupon doesn't get processed twice
  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 remaining t
  remaining === bond [afterTomorrow]
  pending === []

  setDate afterTomorrow
  t <- getDate

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 remaining t
  remaining === zero
  pending === [(coupon, a), (principal, a)]


testEuropeanCall = script do
  let strike = 23.0
      payoff = scale (O.observe "spot" - O.pure strike) (one a)
      option = european tomorrow payoff
      bearer = True

  -- Before maturity
  setDate today
  t <- getDate

  -- Exercise is a no-op
  remaining <- Lifecycle.exercise observe25 (bearer, zero) option t
  remaining === option

  -- and so is settlement
  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 option t
  remaining === option
  pending === []

  -- At maturity
  setDate tomorrow
  t <- getDate

  remaining <- Lifecycle.exercise observe25 (bearer, payoff) option t
  remaining === when (at tomorrow) payoff

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 remaining t
  remaining === zero
  pending === pure (2.0, a)

-- Knock-in tomorrow
testAmericanPut : Script ()
testAmericanPut = script do
  let strike = 30.0
      payoff = scale (O.pure strike - O.observe "spot") (one a)
      option = american tomorrow afterTomorrow payoff
      bearer = True

  -- Scenario 1) Before knock-in
  setDate today
  t <- getDate

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 option t
  remaining === option
  pending === []

  remaining <- Lifecycle.exercise observe25 (bearer, payoff) remaining t
  remaining === option -- not in acquisition range yet

  -- Scenario 2) in acquisition range
  setDate tomorrow
  t <- getDate

  -- Settlement before exercise is a no-op
  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 option t
  remaining === option
  pending === []

  -- So is expiration before maturity
  remaining <- Lifecycle.expire observe25 remaining t
  remaining === option

  -- Exercise `anytime`
  remaining <- Lifecycle.exercise observe25 (bearer, remaining.claim) remaining t
  remaining === when (TimeGte t) (until (TimeGte $ afterTomorrow) (payoff `or`  zero))

  -- Exercise `or`
  remaining <- Lifecycle.exercise observe25 (bearer, payoff) remaining t
  remaining === when (TimeGte t) (until (TimeGte afterTomorrow) payoff)

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 remaining t
  remaining === zero
  pending === pure (5.0, a)

  -- Scenario 3) at maturity
  setDate afterTomorrow
  t <- getDate

  -- Expiration at maturity n.b. this means you must *first* exercise & settle *before* expiring.
  remaining <- Lifecycle.expire observe25 option t
  remaining === zero

  -- Settlement before exercise has been done is a no-op
  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 option t
  remaining === option
  pending === []

  -- Trying to exercise inner `or` before `anytime` won't work.
  remaining <- Lifecycle.exercise observe25 (bearer, payoff) remaining t
  remaining === option

  -- You must first exercise the 'outer' `anytime`, and then ...
  remaining <- Lifecycle.exercise observe25 (bearer, remaining.claim) remaining t
  remaining === when (TimeGte t) (until (TimeGte $ afterTomorrow) (payoff `or` zero))

  -- ... the inner `or`.
  remaining <- Lifecycle.exercise observe25 (bearer, payoff) remaining t
  remaining === when (TimeGte t) (until (TimeGte $ afterTomorrow) payoff)

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 remaining t
  remaining === zero
  pending === pure (5.0, a)

  -- Scenario 4) after expiration
  setDate $ succ afterTomorrow
  t <- getDate

  remaining <- Lifecycle.exercise observe25 (bearer, payoff) option t
  remaining === option -- past maturity; no exercise possible

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observe25 remaining t
  remaining === option
  pending === []

  remaining <- Lifecycle.expire observe25 remaining t
  remaining === zero

-- | Ensure that acquisition time is propagated correctly (deterministic time)
testFloatingRateNote = script do
  let 
    innerFrn = Scale (O.Observe a) $ When (TimeGte $ date 2022 Mar 10) $ One b
    frn = When (TimeGte $ date 2022 Mar 05) innerFrn

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observeDayOfMonth frn $ date 2022 Feb 28
  remaining === frn

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observeDayOfMonth frn $ date 2022 Mar 07
  remaining === frn

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observeDayOfMonth frn $ date 2022 Mar 10
  remaining === Zero
  pending === [(5.0,b)]

  pure ()  

-- | Ensure that acquisition time is propagated correctly (stochastic time)
testKnockOutBarrier = script do
  let
    start = date 2022 Mar 01
    inequality = O.Const 25.0 <= O.Observe a
    innerFrn = Scale (O.Observe a) $ When (TimeGte $ date 2022 Mar 27) $ One b
    frn = When (at start) $ When inequality innerFrn

  -- Predicate is False, contract should be unchanged
  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observeDayOfMonth frn $ date 2022 Mar 01
  remaining === frn

  -- Predicate becomes True and `When pred` should be replaced by `When (TimeGte Ï„)`
  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observeDayOfMonth frn $ date 2022 Mar 25
  remaining === When (at start) (When (TimeGte $ date 2022 Mar 25) innerFrn)
  pending === []

  -- Payment of the correct amount is made on payment date
  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observeDayOfMonth remaining $ date 2022 Mar 27
  remaining === Zero
  pending === [(25.0,b)]

  -- With a stochastic predicate, if we lifecycle too late (e.g. on the 26th rather than on the 25th) we end up with an incorrect claim
  wrongLifecycleResult <- Lifecycle.lifecycle observeDayOfMonth frn $ date 2022 Mar 26
  wrongLifecycleResult.remaining === When (at start) (When (TimeGte $ date 2022 Mar 26) innerFrn)

  pure ()

-- | Ensure that `Cond` nodes are lifecycled appropriately 
testCondLifecycle = script do
  let c = When true $ Cond true (One a) (One b)

  Lifecycle.Result{pending, remaining} <- Lifecycle.lifecycle observeDayOfMonth c today
  remaining === zero
  pending === [(1.0, a)]

  pure ()

