-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- {-# LANGUAGE AllowAmbiguousTypes #-}
-- {-# LANGUAGE TypeFamilies #-}
-- {-# LANGUAGE MultiParamTypeClasses #-}
-- {-# LANGUAGE UndecidableInstances #-}
-- {-# LANGUAGE OverlappingInstances #-}
-- {-# LANGUAGE FlexibleInstances #-}

module Scratch.Test where

-- import DA.Assert ((===))
-- import DA.List (head, tail)
-- import Daml.Control.Monad.State.Class
-- import Daml.Control.Monad.Trans.State (State(..), StateT(..), runState, runStateT)
-- import Daml.Script

-- -- import Typeable

-- type Stack = [Int]

-- pop : Stack -> (Int, Stack)
-- pop s = (head s, tail s)

-- push : Int -> Stack -> ((), Stack)
-- push x s = ((), x :: s)

-- -- s -> (r, s)

-- test : Script ()
-- test = do
--   let
--     s0 = [] -- initial state
--     (_, s1) = push 1 s0
--     (_, s2) = push 2 s1
--   debug s2 -- show state
--   let
--     s2 = [] -- reset state
--     (_, s3) = push 3 s2
--     (_, s4) = push 4 s3
--     (_, s5) = pop s4
--     (_, s6) = push 5 s5
--     (_, s7) = pop s6
--     (_, s8) = pop s7
--     (_, s9) = push 6 s8
--     result = pop s9

--   debug result

-- -- s -> (r, s)
-- -- newtype State s r = State {runState : s -> (r, s)}

-- pop' : State Stack Int
-- pop' = state $ \s -> (head s, tail s)

-- push' : Int -> State Stack ()
-- push' x = state $ \s -> ((), x :: s)

-- test' : Script ()
-- test' = do
--   let
--     result = runState do
--       push' 1
--       push' 2
--       s <- get
--       debug s -- show state
--       put [] -- reset state
--       push' 3
--       push' 4
--       pop'
--       push' 5
--       pop'
--       pop'
--       push' 6
--       pop'
--       $ [] -- initial state

--   debug result

--   pure ()

-- -- newtype State s r = State {runState : s -> (r, s)}
-- -- newtype StateT s m r = StateT {runStateT : s -> m (r, s)}

-- pop'' : (Action m) => StateT Stack m Int
-- pop'' = StateT $ \s -> pure (head s, tail s)

-- push'' : (Action m) => Int -> StateT Stack m ()
-- push'' x = StateT $ \s -> pure ((), x :: s)

-- test'' : Script ()
-- test'' = do
--   result <- withIndexTable idx do
--     push'' 1
--     push'' 2
--     s <- get
--     debug s -- show state
--     put [] -- reset state
--     s <- get
--     s === [] -- assert
--     assertMsg "adsg" $ null s
--     push'' 3
--     push'' 4
--     pop''
--     push'' 5
--     pop''
--     pop''
--     push'' 6
--     pop''
--     $ [] -- initial state

--   debug result

-- -- class Printable a where
-- --   printMe : a -> Script ()

-- -- instance Printable a where
-- --   printMe a = debug "dummy instance"

-- -- instance {-# OVERLAPPING #-} Printable Int where
-- --   printMe x = debug ("I am an Int with value :" <> show x)

-- -- main : Script ()
-- -- main = do
-- --   printMe 5
-- --   printMe "5"
