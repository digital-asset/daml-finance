-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Holding.Test.Transfer where

import DA.Assert ((===))
import DA.Map qualified as M (fromList)
import DA.Set qualified as S (fromList, singleton)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Holding.NonFungible qualified as NonFungible (Factory(..))
import Daml.Finance.Holding.Test.Common (TestInitialState(..), TestParties(..), setupInitialState, setupParties)
import Daml.Finance.Interface.Holding.Factory.Account qualified as Account (Create(..), F)
import Daml.Finance.Interface.Holding.Lockable qualified as Lockable (Acquire(..), GetView(..), I, LockType(..))
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Types.Common (Id(..), AccountKey(..))
import Daml.Finance.Test.Util.Account qualified as Account (createFactory)
import Daml.Script

-- | Verify that I cannot transfer a non-fungible holding to a fungible account.
noCrossTransfer : Script ()
noCrossTransfer = script do
  -- Create parties
  tp@TestParties{custodian; issuer; investor; publicParty} <- setupParties

  -- Initialize state with `NonFungible.Factory`
  let pp = M.fromList [("PublicParty", S.singleton publicParty)]
  TestInitialState {issuerAccount; issuerHoldingCid} <- setupInitialState tp (NonFungible.Factory with provider = custodian; observers = pp) []

  -- Create investor account for fungible holdings
  accountFactoryCid <- toInterfaceContractId @Account.F <$> Account.createFactory custodian []
  holdingFactoryCid <- toInterfaceContractId <$> submit custodian do createCmd Fungible.Factory with provider = custodian; observers = pp
  let
    id = Id $ show investor <> "@" <> show custodian <> "[" <> "Fungible" <> "]"
    investorAccount = AccountKey with custodian; owner = investor; id
  submitMulti [custodian, investor] [] do
    exerciseCmd accountFactoryCid Account.Create
      with
        account = investorAccount
        description = "Fungible Account"
        holdingFactoryCid
        observers = M.fromList [("Issuer", S.singleton issuer)]

  -- Attempt to transfer a non-fungible holding to a fungible holding.
  submitMultiMustFail [issuer, investor] [publicParty] do
    exerciseCmd (coerceContractId issuerHoldingCid : ContractId Transferable.I) Transferable.Transfer
      with
        newOwnerAccount = investorAccount
        transferors = S.singleton investor

  pure ()

-- | Verify that transfer preserves holding locks.
locksArePreserved : Script ()
locksArePreserved = script do
  -- Create parties
  tp@TestParties{custodian; issuer; investor; lockers; publicParty} <- setupParties

  -- Initialize state with `Fungible.Factory`
  let pp = M.fromList [("PublicParty", S.singleton publicParty)]
  TestInitialState {issuerAccount; issuerHoldingCid; investorAccount} <- setupInitialState tp (Fungible.Factory with provider = custodian; observers = pp) []

  -- Lock asset (with 2 contexts)
  lockableCid <- submitMulti [issuer, lockers] [] do
    exerciseCmd (coerceContractId issuerHoldingCid : ContractId Lockable.I) Lockable.Acquire with newLocker = S.singleton lockers; context = "C1"; lockType = Lockable.Reentrant
  lockableCid <- submitMulti [issuer, lockers] [] do
    exerciseCmd lockableCid Lockable.Acquire with newLocker = S.singleton lockers; context = "C2"; lockType = Lockable.Reentrant

  -- Transfer
  newHoldingCid <- submitMulti [issuer, investor, lockers] [publicParty] do
    exerciseCmd (coerceContractId lockableCid : ContractId Transferable.I) Transferable.Transfer with newOwnerAccount = investorAccount; transferors = S.fromList [issuer, investor]

  -- Verify lock is maintained
  Some lock <- (.lock) <$> submit lockers do exerciseCmd (coerceContractId newHoldingCid : ContractId Lockable.I) Lockable.GetView with viewer = lockers
  lock.lockers === S.singleton lockers
  lock.context === S.fromList ["C1", "C2"]
  lock.lockType === Lockable.Reentrant

  pure ()
