-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Option.Test.Util where

import DA.List (sort)
import DA.Map qualified as M (empty, fromList)
import DA.Set (fromList, singleton)
import Daml.Finance.Instrument.Option.Election qualified as Election (Factory(..))
import Daml.Finance.Instrument.Option.EuropeanCash.Instrument qualified as EuropeanCashOption (Instrument(..))
import Daml.Finance.Instrument.Option.EuropeanPhysical.Instrument qualified as EuropeanPhysicalOption (Instrument(..))
import Daml.Finance.Instrument.Option.Lifecycle.Rule qualified as Lifecycle (Rule(..))
import Daml.Finance.Interface.Instrument.Option.Election qualified as Election (Apply(..))
import Daml.Finance.Interface.Instrument.Option.Election.Factory qualified as Election (Create(..), F)
import Daml.Finance.Interface.Instrument.Option.Types (OptionTypeEnum)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (GetView(..))
import Daml.Finance.Interface.Lifecycle.Observable.NumericObservable qualified as NumericObservable (I)
import Daml.Finance.Interface.Types.Common.Types (Id(..), InstrumentKey, InstrumentQuantity, Parties)
import Daml.Finance.Test.Util.Instrument (createReference)
import Daml.Finance.Test.Util.Time (dateToDateClockTime)
import Daml.Script

-- | Originate a cash-settled European option.
originateEuropeanCashOption : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time ->
  Date -> OptionTypeEnum -> Decimal -> InstrumentKey -> Text -> Bool -> Script InstrumentKey
originateEuropeanCashOption depository issuer label description observers lastEventTimestamp
  expiryDate optionType strike currency referenceAssetId ownerReceives = do
  -- CREATE_EUROPEAN_OPTION_INSTRUMENT_BEGIN
    cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
      createCmd EuropeanCashOption.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp
        ownerReceives; optionType; strike; expiryDate
        referenceAssetId; currency
  -- CREATE_EUROPEAN_OPTION_INSTRUMENT_END
    createReference cid depository issuer observers

-- | Originate a physically settled European option.
originateEuropeanPhysicalOption : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time ->
  Date -> OptionTypeEnum -> Decimal -> InstrumentKey -> InstrumentKey -> Bool -> Script InstrumentKey
originateEuropeanPhysicalOption depository issuer label description observers lastEventTimestamp
  expiryDate optionType strike currency referenceAsset ownerReceives = do
  -- CREATE_EUROPEAN_PHYSICAL_OPTION_INSTRUMENT_BEGIN
    cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
      createCmd EuropeanPhysicalOption.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp
        ownerReceives; optionType; strike; expiryDate
        referenceAsset; currency
  -- CREATE_EUROPEAN_PHYSICAL_OPTION_INSTRUMENT_END
    createReference cid depository issuer observers

-- | Verify the payments of an instrument after an election (excluding settlement)
electAndVerifyPaymentEffects : [Party] -> Date -> InstrumentKey -> Party -> Party -> Text ->
  [ContractId NumericObservable.I] -> [InstrumentQuantity] -> [InstrumentQuantity] ->
  Script (Optional InstrumentKey)
electAndVerifyPaymentEffects readAs today instrument issuer custodian electedTag
  observableCids expectedConsumedQuantities expectedProducedQuantities = do

    -- Create election offers to allow holders to create elections
    electionFactoryCid <- submit issuer do
      toInterfaceContractId @Election.F <$> createCmd Election.Factory with
        provider = issuer
        observers = M.fromList [("Holders", fromList [custodian] )]

    -- Apply election to generate new instrument version + effects
    lifecycleRuleCid <- toInterfaceContractId <$> submit custodian do
      createCmd Lifecycle.Rule with
        providers = singleton custodian
        observers = M.empty
        lifecycler = issuer
        id = Id "LifecycleRule"
        description = "Rule to lifecycle a generic instrument"

    let
      electorIsOwner = True
      counterparty = issuer
      description = "election for physically settled option"
    exerciseOptionCid <- submitMulti [custodian] readAs
      do
        exerciseCmd electionFactoryCid Election.Create with
          actors = fromList [custodian]
          id = Id "election id"
          description
          claim = electedTag
          electionTime = dateToDateClockTime today
          electorIsOwner
          elector = custodian
          counterparty
          instrument
          amount = 1.0
          observers = M.fromList [("Holders", fromList [ custodian, issuer] )]
          provider = issuer

    (newInstrumentKey, [effectCid]) <- submit issuer do
      exerciseCmd exerciseOptionCid Election.Apply with
        observableCids
        exercisableCid = lifecycleRuleCid

    -- Get the effect
    effectView <- submit issuer do
      exerciseCmd effectCid Effect.GetView with viewer = issuer

    -- Verify that the consumed/produced quantities match the expected ones
    assertMsg "The consumed quantities do not match the expected ones" $
      sort expectedConsumedQuantities == sort effectView.otherConsumed
    assertMsg "The produced quantities do not match the expected ones" $
      sort expectedProducedQuantities == sort effectView.otherProduced

    pure newInstrumentKey
