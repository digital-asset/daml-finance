-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Equity.Test.Merger where

import DA.Map qualified as M (fromList)
import DA.Set (fromList, singleton)
import Daml.Finance.Data.Reference.HolidayCalendar qualified as HolidayCalendar (T)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Instrument.Equity.Instrument qualified as Equity (T)
import Daml.Finance.Instrument.Equity.Instrument qualified as Instrument (T)
import Daml.Finance.Instrument.Equity.Test.Util (originateEquity)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as BaseInstrument (I)
import Daml.Finance.Interface.Instrument.Equity.Instrument qualified as Equity (I, DeclareReplacement(..))
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (Evolve(..), I)
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common.Types (Id(..))
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Lifecycle.Rule.Claim qualified as Claim (Rule(..))
import Daml.Finance.Lifecycle.Rule.Replacement qualified as Replacement (Rule(..))
import Daml.Finance.Settlement.Factory (Factory(..))
import Daml.Finance.Settlement.RouteProvider.SingleCustodian (SingleCustodian(..))
import Daml.Finance.Settlement.Test.Util (allocateAny, approveAny, settleAny)
import Daml.Finance.Test.Util.Account qualified as Account (ControlledBy(..), createAccount, createFactory, credit)
import Daml.Finance.Test.Util.Common (createParties, queryAnyByKey)
import Daml.Finance.Test.Util.Holding qualified as Holding (verifyOwnerOfHolding)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (buildKeyTable)
import Daml.Script

-- Merger lifecycling and settlement
-- This is a mandatory corporate action: no election is required by the shareholder.
run : Script ()
run = script do
  -- Create parties
  [merging, merged, custodian, investor, publicParty] <-
    createParties ["MergingIssuer", "MergedIssuer", "Custodian", "Investor", "PublicParty"]

  -- Account and holding factory
  let pp = [("PublicParty", singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory custodian pp
  holdingFactoryCid <- toInterfaceContractId <$> submit custodian do
    createCmd Fungible.Factory with provider = custodian; observers = M.fromList pp

  -- Create accounts
  investorSecuritiesAccount <- Account.createAccount "Securities Account" [] accountFactoryCid
    holdingFactoryCid [] Account.Owner custodian investor

  -- CREATE_EQUITY_REPLACEMENT_RULE_BEGIN
  -- Create lifecycle rules
  replacementRuleCid <- toInterfaceContractId @Lifecycle.I <$> submit merging do
    createCmd Replacement.Rule with
      providers = singleton merging
      lifecycler = merging
      observers = singleton publicParty
      id = Id "LifecycleRule"
      description = "Rule to lifecycle an instrument following a replacement event"
  -- CREATE_EQUITY_REPLACEMENT_RULE_END

  -- Originate instruments
  now <- getTime
  -- CREATE_EQUITY_INSTRUMENTS_BEGIN
  mergingInstrument <- originateEquity merging merging "INST-1" "0" "ABC" pp now
  mergedInstrument <- originateEquity merged merged "INST-2" "0" "XYZ" pp now
  -- CREATE_EQUITY_INSTRUMENTS_END

  -- Distribute holdings
  investorEquityCid <- Account.credit [] mergingInstrument 2_000.0 investorSecuritiesAccount

  -- Build key table
  (mergingInstrumentCid, _) <- queryAnyByKey @Equity.T @BaseInstrument.I [merging] mergingInstrument

  -- CREATE_EQUITY_REPLACEMENT_EVENT_BEGIN
  -- Create replacement event
  -- perUnitReplacement is an arbitrary list of instruments, so the investor can also receive a
  -- combination of shares and cash.
  replacementEventCid <- submit merging do
    exerciseCmd (coerceInterfaceContractId @Equity.I mergingInstrumentCid)
      Equity.DeclareReplacement with
        id = Id $ "ABC merge - " <> show now
        description = "Merge"
        effectiveTime = now
        perUnitReplacement = [qty 0.5 mergedInstrument]
  -- CREATE_EQUITY_REPLACEMENT_EVENT_END

  -- Build key table
  keyTable <- Instrument.buildKeyTable @Instrument.T @HolidayCalendar.T [merging] mergingInstrument

  -- LIFECYCLE_MERGER_BEGIN
  -- Lifecycle replacement event
  (_, [effectCid]) <- submit merging do
    fst <$> exerciseCmd replacementRuleCid Lifecycle.Evolve with
      eventCid = replacementEventCid
      observableCids = []
      instrument = mergingInstrument
      keyTable
  -- LIFECYCLE_MERGER_END

  -- Claim effect
  routeProviderCid <- toInterfaceContractId <$> submit custodian do
    createCmd SingleCustodian with
      provider = custodian; observers = singleton publicParty; custodian
  settlementFactoryCid <- toInterfaceContractId <$> submit custodian do
    createCmd Factory with provider = custodian; observers = singleton publicParty
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submit custodian do
    createCmd Claim.Rule with
      providers = singleton custodian
      claimers = fromList [custodian, investor]
      settlers = fromList [custodian, investor]
      routeProviderCid
      settlementFactoryCid
      netInstructions = False

  result <- submitMulti [custodian] [publicParty] do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = custodian
      holdingCids = [investorEquityCid]
      effectCid
      batchId = Id "MergerSettlement"

  -- Allocate instructions
  let [consumeInstructionCid, produceInstructionCid] = result.instructionCids
  (consumeInstructionCid, _) <- allocateAny [investor] consumeInstructionCid $
    Pledge investorEquityCid
  (produceInstructionCid, _) <- allocateAny [custodian] produceInstructionCid $ CreditReceiver

  -- Approve instructions
  consumeInstructionCid <- approveAny [custodian] consumeInstructionCid $ DebitSender
  produceInstructionCid <- approveAny [investor] produceInstructionCid $
    TakeDelivery investorSecuritiesAccount

  -- Settle batch
  [investorEquityCid] <- settleAny [custodian] [] result.batchCid

  -- Assert state
  Holding.verifyOwnerOfHolding [(investor, investorEquityCid)]

  pure ()
