-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Equity.Test.Merger where

import DA.Date (toDateUTC)
import DA.Map qualified as M (fromList)
import DA.Set (fromList, singleton)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Instrument.Equity.Test.Util (originateEquity)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Instrument.Equity.Instrument qualified as Equity (I, DeclareReplacement(..))
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (Evolve(..), I)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common (Id(..))
import Daml.Finance.Lifecycle.Rule.Claim qualified as Claim (Rule(..))
import Daml.Finance.Lifecycle.Rule.Replacement qualified as Replacement (Rule(..))
import Daml.Finance.Settlement.Factory (Factory(..))
import Daml.Finance.Test.Util.Account qualified as Account (ControlledBy(..), createAccount, createFactory, credit)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Holding qualified as Holding (verifyOwnerOfHolding)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (submitExerciseInterfaceByKeyCmd)
import Daml.Finance.Test.Util.Lifecycle (createClockAndEvent)
import Daml.Script

-- Merger lifecycling and settlement
run : Script ()
run = script do
  -- Create parties
  [merging, merged, custodian, investor, public] <-
    createParties ["MergingIssuer", "MergedIssuer", "Custodian", "Investor", "Public"]

  -- Account and holding factory
  let pp = [("Public", singleton public)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory custodian pp
  holdingFactoryCid <- toInterfaceContractId <$> submit custodian do createCmd Fungible.Factory with provider = custodian; observers = M.fromList pp

  -- Create accounts
  investorSecuritiesAccount <- Account.createAccount "Securities Account" [] accountFactoryCid holdingFactoryCid [] Account.Owner custodian investor

  -- Create lifecycle rules
  replacementRuleCid <- toInterfaceContractId @Lifecycle.I <$> submit merging do createCmd Replacement.Rule with providers = singleton merging; lifecycler = merging; observers = singleton public

  -- Create clock
  now <- getTime
  (clockCid, clockEventCid) <- createClockAndEvent (singleton merging) (toDateUTC now) (singleton public)

  -- Originate instruments
  mergingInstrument <- originateEquity merging merging "INST-1" "0" "ABC" pp now
  mergedInstrument <- originateEquity merged merged "INST-2" "0" "XYZ" pp now

  -- Distribute holdings
  investorEquityCid <- Account.credit [] mergingInstrument 2_000.0 investorSecuritiesAccount

  -- Create replacement event
  replacementEventCid <- Instrument.submitExerciseInterfaceByKeyCmd @Equity.I [merging] [] mergingInstrument Equity.DeclareReplacement
    with
      id = Id $ "ABC merge - " <> show now
      description = "Merge"
      effectiveDate = toDateUTC now
      perUnitReplacement = [Instrument.qty 0.5 mergedInstrument]

  -- Lifecycle replacement event
  (_, [effectCid]) <- submit merging do exerciseCmd replacementRuleCid Lifecycle.Evolve with ruleName = "Merger"; eventCid = replacementEventCid; observableCids = []; timeObservableCid = clockCid

  -- Claim effect
  settlementFactoryCid <- toInterfaceContractId <$> submit custodian do createCmd Factory with provider = custodian; observers = singleton public; custodian
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submit custodian do
    createCmd Claim.Rule
      with
        providers = singleton custodian
        claimers = fromList [custodian, investor]
        settlers = fromList [custodian, investor]
        settlementFactoryCid
        netInstructions = False

  result <- submitMulti [custodian] [public] do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect
      with
        claimer = custodian
        holdingCids = [investorEquityCid]
        effectCid
        batchId = Id "MergerSettlement"

  -- Allocate instructions
  let [consumeInstructionCid, produceInstructionCid] = result.instructionCids
  (consumeInstructionCid, _) <- submit investor do exerciseCmd consumeInstructionCid Instruction.Allocate with actors = singleton investor; allocation = Pledge $ coerceContractId investorEquityCid
  (produceInstructionCid, _) <- submit custodian do exerciseCmd produceInstructionCid Instruction.Allocate with actors = singleton custodian; allocation = CreditReceiver

  -- Approve instructions
  consumeInstructionCid <- submit custodian do exerciseCmd consumeInstructionCid Instruction.Approve with actors = singleton custodian; approval = DebitSender
  produceInstructionCid <- submit investor do exerciseCmd produceInstructionCid Instruction.Approve with actors = singleton investor; approval = TakeDelivery investorSecuritiesAccount

  -- Settle batch
  [investorEquityCid] <- submit custodian do exerciseCmd result.batchCid Batch.Settle with actors = singleton custodian

  -- Assert state
  Holding.verifyOwnerOfHolding [(investor, investorEquityCid)]

  pure ()
