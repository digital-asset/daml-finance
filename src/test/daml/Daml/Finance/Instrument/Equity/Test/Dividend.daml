-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Equity.Test.Dividend where

import DA.Date (toDateUTC)
import DA.Map qualified as M (fromList)
import DA.Set (empty, fromList, singleton)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Instrument.Equity.Test.Util (originateEquity)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Instrument.Equity.Instrument qualified as Equity (DeclareDividend(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (Evolve(..), I)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common (Id(..))
import Daml.Finance.Lifecycle.Rule.Claim qualified as Claim (Rule(..))
import Daml.Finance.Lifecycle.Rule.Distribution qualified as Distribution (Rule(..))
import Daml.Finance.Settlement.Factory (Factory(..))
import Daml.Finance.Test.Util.Account qualified as Account (ControlledBy(..), createAccount, createFactory, credit)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Holding qualified as Holding (verifyOwnerOfHolding)
import Daml.Finance.Test.Util.Instrument (originate)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (submitExerciseInterfaceByKeyCmd)
import Daml.Finance.Test.Util.Lifecycle (createClockAndEvent)
import Daml.Script

-- Cash dividend lifecycling and settlement
run : Script ()
run = script do
  -- Create parties
  [cb, issuer, custodian, investor, public] <-
    createParties ["CentralBank", "Issuer", "Custodian", "Investor", "Public"]

  -- Create holding and account factory
  let pp = [("Public", singleton public)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory issuer pp
  holdingFactoryCid <- toInterfaceContractId <$> submit issuer do
    createCmd Fungible.Factory with provider = issuer; observers = M.fromList pp

  -- Create accounts
  investorAccount <- Account.createAccount "Account" [public] accountFactoryCid holdingFactoryCid []
    Account.Owner custodian investor

  -- Create clock
  now <- getTime
  (clockCid, clockEventCid) <- createClockAndEvent (singleton issuer) (toDateUTC now) empty

  -- Originate instruments
  cashInstrument <- originate cb cb "USD" "United States Dollar" pp now
  cumEquityInstrument <- originateEquity issuer issuer "EQUITY-INST-1" "0" "APPL" pp now
  exEquityInstrument <- originateEquity issuer issuer "EQUITY-INST-1" "1" "APPL" [] now

  -- Distribute holdings
  investorEquityCid <- Account.credit [public] cumEquityInstrument 1_000.0 investorAccount

  -- Create cash dividend event
  distributionRuleCid <- toInterfaceContractId @Lifecycle.I <$> submit issuer do
    createCmd Distribution.Rule with
      providers = singleton issuer; lifecycler = issuer; observers = singleton public
  distributionEventCid <-
    Instrument.submitExerciseInterfaceByKeyCmd @Equity.I [issuer] [] cumEquityInstrument
      Equity.DeclareDividend with
        id = Id $ "APPL - " <> show now
        description = "Cash Dividend"
        effectiveDate = toDateUTC now
        newInstrument = exEquityInstrument
        perUnitDistribution = [Instrument.qty 2.0 cashInstrument]

  -- Lifecycle cash dividend
  (_, [effectCid]) <- submit issuer do
    exerciseCmd distributionRuleCid Lifecycle.Evolve with
      ruleName = "Dividend"; observableCids = []; eventCid = distributionEventCid
      timeObservableCid = clockCid

  -- Claim effect
  settlementFactoryCid <- toInterfaceContractId <$> submit custodian do
    createCmd Factory with
      provider = custodian; observers = singleton public; custodian
  claimRuleCid <- toInterfaceContractId @Claim.I <$> submit custodian do
    createCmd Claim.Rule
      with
        providers = singleton custodian
        claimers = fromList [investor, custodian]
        settlers = fromList [investor, custodian]
        settlementFactoryCid
        netInstructions = False

  -- The effect is claimed and then settled by the custodian, but it could also be claimed and then
  -- settled by the investor.
  result <- submitMulti [custodian] [public] do
    exerciseCmd claimRuleCid Claim.ClaimEffect
      with
        claimer = custodian
        holdingCids = [investorEquityCid]
        effectCid
        batchId = Id "DividendSettlement"

  let
    [investorInstrumentInstructionCid, custodianInstrumentInstructionCid,
      custodianCashInstructionCid] = result.instructionCids

  -- Allocate instructions
  (investorInstrumentInstructionCid, _) <- submit investor do
    exerciseCmd investorInstrumentInstructionCid Instruction.Allocate with
      actors = singleton investor; allocation = Pledge $ coerceContractId investorEquityCid
  (custodianInstrumentInstructionCid, _) <- submit custodian do
    exerciseCmd custodianInstrumentInstructionCid Instruction.Allocate with
      actors = singleton custodian; allocation = CreditReceiver
  (custodianCashInstructionCid, _) <- submit custodian do
    exerciseCmd custodianCashInstructionCid Instruction.Allocate with
      actors = singleton custodian; allocation = CreditReceiver

  -- Approve instructions
  investorInstrumentInstructionCid <- submit custodian do
    exerciseCmd investorInstrumentInstructionCid Instruction.Approve with
      actors = singleton custodian; approval = DebitSender
  custodianInstrumentInstructionCid <- submit investor do
    exerciseCmd custodianInstrumentInstructionCid Instruction.Approve with
      actors = singleton investor; approval = TakeDelivery investorAccount
  custodianCashInstructionCid <- submit investor do
    exerciseCmd custodianCashInstructionCid Instruction.Approve with
      actors = singleton investor; approval = TakeDelivery investorAccount

  -- Settle batch
  [investorEquityHoldingCid, investorCashHoldingCid] <- submitMulti [custodian] [public] do
    exerciseCmd result.batchCid Batch.Settle with actors = singleton custodian

  -- Assert state
  Holding.verifyOwnerOfHolding
    [(investor, investorEquityHoldingCid), (investor, coerceContractId investorCashHoldingCid)]

  pure ()
