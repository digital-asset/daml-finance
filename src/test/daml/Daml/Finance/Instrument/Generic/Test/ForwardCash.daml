-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Generic.Test.ForwardCash where

import ContingentClaims.Claim (Inequality(..), one, scale, when)
import ContingentClaims.Observation (Observation(..))
import DA.Date (addDays, toDateUTC)
import DA.Map qualified as M (empty, fromList)
import DA.Set (empty, singleton)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Instrument.Generic.Test.Util (originateGeneric, dateToDateClockTime)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (Evolve(..), I)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common (Id(..))
import Daml.Finance.Lifecycle.Rule.Claim qualified as Claim (Rule(..))
import Daml.Finance.RefData.Observation (Observation(..))
import Daml.Finance.RefData.Time.DateClock (DateClock(..), DateClockUpdateEvent(..), Unit(..))
import Daml.Finance.Settlement.Factory (Factory(..))
import Daml.Finance.Test.Util.Account qualified as Account (createAccount, createFactory, credit)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Holding qualified as Holding (verifyOwnerOfHolding)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (originate, submitExerciseInterfaceByKeyCmd)
import Daml.Script

-- | Parties involved in the test script.
data TestParties = TestParties
  with
    bank : Party
      -- ^ Acts as custodian in the respective holdings (both cash holdings and instrument holdings). It also acts as depository in the forward instrument.
    broker : Party
      -- ^ Acts as issuer of the forward contract. It is also the party tasked with lifecycling of the contract.
    centralBank : Party
      -- ^ The Central Bank is the depository and the issuer of the cash instrument.
    investor : Party
      -- ^ Owner of the equity forward holding.
    settler : Party
      -- ^ Triggers the settlement of fully allocated settlement instructions.
    publicParty : Party
      -- ^ The public party. Every party can readAs the public party.

-- Cash-settled forward trade lifecycling and settlement (needs observations)
run : Script ()
run = script do
  TestParties{..} <- setupParties

  -- Account and holding factory
  let fp = [("FactoryProvider", singleton $ singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory bank fp
  holdingFactoryCid <- toInterfaceContractId <$> submit bank do
    createCmd Fungible.Factory with provider = bank; observers = M.fromList fp

  -- Create accounts
  [bankOwnAccount, investorAccount] <- mapA (Account.createAccount "Default Account" [publicParty] accountFactoryCid holdingFactoryCid [] bank) [bank, investor]

  -- Distribute cash
  now <- getTime
  let pp = [("PublicParty", singleton $ singleton publicParty)]
  cashInstrument <- Instrument.originate centralBank centralBank "USD" "United States Doller" pp now
  bankCashTransferableCid <- Account.credit [publicParty] cashInstrument 50_000.0 bankOwnAccount

  -- Create observable
  let
    maturity = addDays (toDateUTC now) 1
    observations = M.fromList [(dateToDateClockTime maturity, 200.0)]
  observableCid <- coerceContractId <$> submitMulti [broker] [] do createCmd Observation with provider = broker; obsKey = "SPOT/AAPL"; observations; observers = M.empty

  -- Create and distribute a gerneric derivative
  let
    equityObservable = "SPOT/AAPL"
    claims = when (TimeGte $ dateToDateClockTime maturity) $ scale (Observe equityObservable - Const 150.0) $ one cashInstrument
  genericInstrument <- originateGeneric bank broker "FWD-AAPL" "Forward Contract" now claims pp now
  investorGenericTransferableCid <- Account.credit [publicParty] genericInstrument 1_000.0 investorAccount

  -- create clock and clock update event
  let clock = DateClock with u = Unit maturity; id = Id (show maturity); provider = broker; observers = M.empty
  clockCid <- toInterfaceContractId <$> submitMulti [broker] [] do createCmd clock
  clockEventCid <- toInterfaceContractId <$> submitMulti [broker] [] do createCmd DateClockUpdateEvent with clock; id = Id (show maturity)

  -- Lifecycle derivative
  (_, [effectCid]) <- Instrument.submitExerciseInterfaceByKeyCmd @Lifecycle.I [broker] [] genericInstrument Lifecycle.Evolve with settler; eventCid = clockEventCid; observableCids = [observableCid]; ruleName = "Time"; clockCid

  -- Create settlement factory
  settlementFactoryCid <- submitMulti [investor] [] do createCmd Factory with provider = investor; observers = empty

  -- Claim effect
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submitMulti [bank, investor] [] do
    createCmd Claim.Rule
      with
        custodian = bank
        owner = investor
        claimers = singleton investor
        settler
        factoryCid = toInterfaceContractId settlementFactoryCid

  result <- submitMulti [investor] [publicParty] do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = investor
      holdingCids = [coerceContractId investorGenericTransferableCid]
      effectCid

  let [bankCashInstructionCid] = result.instructionCids

  -- Allocate instructions
  bankCashInstructionCid <- submitMulti [bank] [] do exerciseCmd bankCashInstructionCid Instruction.Allocate with allocation = Pledge bankCashTransferableCid

  -- Approve instructions
  bankCashInstructionCid <- submitMulti [investor] [] do exerciseCmd bankCashInstructionCid Instruction.Approve with approval = TakeDelivery  investorAccount

  -- Settle batch
  [investorCashTransferableCid] <- submitMulti [settler] [publicParty] do exerciseCmd result.batchCid Batch.Settle

  -- Assert state
  Holding.verifyOwnerOfHolding [(investor, investorCashTransferableCid)]

  pure ()

setupParties : Script TestParties
setupParties = do
  [bank, broker, centralBank, investor, settler, publicParty] <-
    createParties ["Bank", "Broker", "Central Bank", "Investor", "Settler", "PublicParty"]
  pure $ TestParties with bank; broker; centralBank; investor; settler; publicParty
