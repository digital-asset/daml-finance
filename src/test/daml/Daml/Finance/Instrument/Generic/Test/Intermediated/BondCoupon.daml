-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Generic.Test.Intermediated.BondCoupon where

import ContingentClaims.Core.Claim (Inequality(..), one, scale, when)
import ContingentClaims.Core.Observation (Observation(..))
import DA.Assert ((===))
import DA.Date (addDays, toDateUTC)
import DA.Foldable qualified as F (forA_)
import DA.Map qualified as M (fromList)
import DA.Set (empty, fromList, singleton, toList)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Instrument.Generic.Test.Util (originateGeneric, mapClaimToUTCTime)
import Daml.Finance.Interface.Account.Account qualified as Account (K)
import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I)
import Daml.Finance.Interface.Holding.Util (getInstrument)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as BaseInstrument (K)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (SetProvider(..), GetView(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (I, Evolve(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..))
import Daml.Finance.Interface.Types.Common (Id(..), Parties)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, AddObservers(..))
import Daml.Finance.Lifecycle.Rule.Claim qualified as Claim (Rule(..))
import Daml.Finance.Settlement.Factory (Factory(..), FactoryWithIntermediaries(..))
import Daml.Finance.Settlement.Hierarchy (Hierarchy(..))
import Daml.Finance.Settlement.Instruction qualified as Instruction (T)
import Daml.Finance.Test.Util.Account qualified as Account (ControlledBy(..), createAccount, createFactory, credit, submitExerciseInterfaceByKeyCmd)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Holding qualified as Holding (verifyOwnerOfHolding)
import Daml.Finance.Test.Util.Instrument qualified as BaseInstrument (originate, submitExerciseInterfaceByKeyCmd)
import Daml.Finance.Test.Util.Lifecycle (createClockAndEvent)
import Daml.Script

{-
  This script distributes a bond to investors and showcases how the bond can be lifecycled to trigger (and settle) a coupon payment.

  Bond (security) account structure :

          Issuer
           |
          CSD
           |
          Investor

  Cash account structure :

          Central Bank
          /     |     \
       CSD   Issuer  Bank
                        \
                      Investor

  In the "non-atomic" script, the lifecycling and settlement happen in three steps:
    - issuer lifecycles the instrument
    - effects are settled between issuer and CSD
    - effects are settled between CSD and investor(s)

  The last step involves moving cash through an account hierarchy.

  In the "atomic" script, the last two steps are executed atomically.
-}

-- | Parties involved in the test script.
data TestParties = TestParties
  with
    bank : Party
      -- ^ The Bank acts as custodian of the investor's cash holdings.
    centralBank : Party
      -- ^ The Central Bank is the depository and the issuer of the cash instrument. It also acts as root custodian of the cash holdings.
    csd : Party
      -- ^ Acts as root custodian of the instrument holdings. It also acts as depository in the bond instrument.
    issuer : Party
      -- ^ Acts as issuer of the bond instrument. It is also the party tasked with lifecycling of the bond.
    investor : Party
      -- ^ Owner of the bond holding.
    settlers : Parties
      -- ^ Any party of the settlers triggers the settlement of fully allocated settlement instructions.
    publicParty : Party
      -- ^ The public party. Every party can readAs the public party.

-- | Originate USD cash instrument and define settlement route.
originateCashAndDefineRoute : TestParties -> Time -> Script (BaseInstrument.K, (Text, Hierarchy))
originateCashAndDefineRoute TestParties{bank, centralBank, csd, investor, issuer, publicParty} now = do
  let
    pp = [("PublicParty", singleton publicParty)]
    label = "USD"
    route =
      ( label
      , Hierarchy with
          rootCustodian = centralBank
          pathsToRootCustodian = [[investor, bank], [csd], [issuer]]
      )
  instrument <- BaseInstrument.originate centralBank centralBank "USD" "United States Dollar" pp now
  pure (instrument, route)

-- | Originate bond instrument and define settlement route.
originateSecurityAndDefineRoute : TestParties -> Time -> BaseInstrument.K -> Script (BaseInstrument.K, (Text, Hierarchy))
originateSecurityAndDefineRoute TestParties{bank, csd, investor, issuer, publicParty} now cashInstrument = do
  -- CREATE_CC_INSTRUMENT_VARIABLES_BEGIN
  let
    today = toDateUTC now
    expiry = addDays today 180
    bondLabel = "ABC.DE 2% " <> show expiry <> " Corp"
    claims = mapClaimToUTCTime $ mconcat
      [ when (TimeGte $ today) $ scale (Const 0.02) $ one cashInstrument
      , when (TimeGte $ expiry) $ scale (Const 0.02) $ one cashInstrument
      , when (TimeGte $ expiry) $ scale (Const 1.0) $ one cashInstrument
      ]
  -- CREATE_CC_INSTRUMENT_VARIABLES_END
  let pp = [("PublicParty", singleton publicParty)]
  -- CREATE_CC_INSTRUMENT_BEGIN
  instrument <- originateGeneric csd issuer bondLabel "Bond" now claims pp now
  -- CREATE_CC_INSTRUMENT_END
  let
    route =
      ( bondLabel
      , Hierarchy with
          rootCustodian = issuer
          pathsToRootCustodian = [[investor, csd]]
      )
  pure (instrument, route)

-- | Penultimate coupon payment on a bond showing creation of new instrument version.
-- Settlement of effects does not happen atomically.
runIntermediatedLifecyclingNonAtomic : Script ()
runIntermediatedLifecyclingNonAtomic = script do
  parties@TestParties{..} <- setupParties

  -- Setup security accounts
  [investorSecuritiesAccount] <- setupAccounts "Securities Account" csd publicParty [investor]
  [csdAccountAtIssuer] <- setupAccounts "Securities Account" issuer publicParty [csd]

  -- Setup cash accounts at central bank
  [issuerCashAccount, bankCashAccount, csdCashAccount] <- setupAccounts "Cash Account" centralBank publicParty [issuer, bank, csd]

  -- Setup investor's cash account at Bank
  [investorCashAccount] <- setupAccounts "Cash Account" bank publicParty [investor]

  -- Originate and distribute central-bank cash
  now <- getTime
  let
    today = toDateUTC now

  (cashInstrument, cashRoute) <- originateCashAndDefineRoute parties now
  issuerCashHoldingCid <- Account.credit [publicParty] cashInstrument 20_000.0 issuerCashAccount

  -- Originate and distribute bond
  (bondInstrument, bondRoute) <- originateSecurityAndDefineRoute parties now cashInstrument
  csdBondHoldingCid <- Account.credit [publicParty] bondInstrument 1_000_000.0 csdAccountAtIssuer
  investorBondHoldingCid <- Account.credit [publicParty] bondInstrument 1_000_000.0 investorSecuritiesAccount

  -- create clock and clock update event
  (clockCid, clockEventCid) <- createClockAndEvent (singleton issuer) today empty

  -- Lifecycle bond
  (_, [effectCid]) <- BaseInstrument.submitExerciseInterfaceByKeyCmd @Lifecycle.I [issuer] [] bondInstrument Lifecycle.Evolve with eventCid = clockEventCid; observableCids = []; ruleName = "Time"; timeObservableCid = clockCid

  -- Setup settlement contract between issuer and CSD
  -- In order for the workflow to be successful, we need to disclose the CSD's cash account to the Issuer.
  Account.submitExerciseInterfaceByKeyCmd @Disclosure.I [csd] [] csdCashAccount Disclosure.AddObservers with disclosers = singleton csd; observersToAdd = ("Issuer", singleton issuer)

  settle1Cid <- submitMulti [csd, issuer] [] do
    createCmd EffectSettlementService
      with
        csd
        issuer
        instrumentId = bondInstrument.id
        securitiesAccount = csdAccountAtIssuer
        issuerCashAccount
        csdCashAccount

  -- CSD claims and settles effect against issuer
  (effectCid, newInstrumentHoldingCid, [cashHolding]) <- submitMulti [issuer] [publicParty] do
    exerciseCmd settle1Cid ClaimAndSettle
      with
        instrumentHoldingCid = csdBondHoldingCid
        cashHoldingCid = issuerCashHoldingCid
        effectCid

  -- investor claims effect against CSD

  -- Define settlement routes from CSD to Investor and create batch factory
  let routes = M.fromList [cashRoute, bondRoute]

  settlementFactoryCid <- submit csd do
    toInterfaceContractId <$> createCmd FactoryWithIntermediaries
      with
        provider = csd
        paths = routes
        observers = fromList [investor]

  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submit csd do
    createCmd Claim.Rule
      with
        providers = singleton csd
        claimers = fromList [csd, investor]
        settlers
        settlementFactoryCid

  result <- submit csd do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = csd
      holdingCids = [investorBondHoldingCid]
      effectCid
      batchId = Id "CouponSettlement"

  let [investorBondInstructionCid, csdBondInstructionCid, csdCashInstructionCid, bankCashInstructionCid] = result.instructionCids

  -- Allocate instructions
  (investorBondInstructionCid, _) <- submit investor do exerciseCmd investorBondInstructionCid Instruction.Allocate with actors = singleton investor; allocation = Pledge $ coerceContractId investorBondHoldingCid
  (csdBondInstructionCid, _) <- submit csd do exerciseCmd csdBondInstructionCid Instruction.Allocate with actors = singleton csd; allocation = CreditReceiver
  (csdCashInstructionCid, _) <- submit csd do exerciseCmd csdCashInstructionCid Instruction.Allocate with actors = singleton csd; allocation = Pledge cashHolding
  (bankCashInstructionCid, _) <- submit bank do exerciseCmd bankCashInstructionCid Instruction.Allocate with actors = singleton bank; allocation = CreditReceiver

  -- Approve instructions
  investorBondInstructionCid <- submit csd do
    exerciseCmd investorBondInstructionCid Instruction.Approve with actors = singleton csd; approval = DebitSender
  csdBondInstructionCid <- submit investor do
    exerciseCmd csdBondInstructionCid Instruction.Approve with actors = singleton investor; approval = TakeDelivery investorSecuritiesAccount
  csdCashInstructionCid <- submit bank do
    exerciseCmd csdCashInstructionCid Instruction.Approve with actors = singleton bank; approval = TakeDelivery bankCashAccount
  bankCashInstructionCid <- submit investor do
    exerciseCmd bankCashInstructionCid Instruction.Approve with actors = singleton investor; approval = TakeDelivery investorCashAccount

  -- Settle batch
  [investorBondHoldingCid, bankCashHoldingCid, investorCashHoldingCid] <- submitMulti (toList settlers) [publicParty] do exerciseCmd result.batchCid Batch.Settle with actors = settlers

  -- Assert state
  Holding.verifyOwnerOfHolding
    [ (investor, investorBondHoldingCid)
    , (bank, coerceContractId bankCashHoldingCid)
    , (investor, coerceContractId investorCashHoldingCid)
    ]

  pure ()

-- | Penultimate coupon payment on a bond showing creation of new instrument version.
-- The effect is claimed and settled atomically across the entire chain.
runIntermediatedLifecyclingAtomic : Script ()
runIntermediatedLifecyclingAtomic = script do
  parties@TestParties{..} <- setupParties

  -- Setup security accounts
  [investorSecuritiesAccount] <- setupAccounts "Securities Account" csd publicParty [investor]
  [csdAccountAtIssuer] <- setupAccounts "Securities Account" issuer publicParty [csd]

  -- Setup cash accounts at central bank
  [issuerCashAccount, bankCashAccount, csdCashAccount] <- setupAccounts "Cash Account" centralBank publicParty [issuer, bank, csd]

  -- Setup investor's cash account at Bank
  [investorCashAccount] <- setupAccounts "Cash Account" bank publicParty [investor]

  -- Originate and distribute central-bank cash
  now <- getTime
  let
    today = toDateUTC now

  (cashInstrument, cashRoute) <- originateCashAndDefineRoute parties now
  issuerCashHoldingCid <- Account.credit [publicParty] cashInstrument 20_000.0 issuerCashAccount

  -- Originate and distribute bond
  (bondInstrument, bondRoute) <- originateSecurityAndDefineRoute parties now cashInstrument
  csdBondHoldingCid <- Account.credit [publicParty] bondInstrument 1_000_000.0 csdAccountAtIssuer
  investorBondHoldingCid <- Account.credit [publicParty] bondInstrument 1_000_000.0 investorSecuritiesAccount

  -- create clock and clock update event
  (clockCid, clockEventCid) <- createClockAndEvent (singleton issuer) today empty

  -- Lifecycle bond
  (_, [effectCid]) <- BaseInstrument.submitExerciseInterfaceByKeyCmd @Lifecycle.I [issuer] [] bondInstrument Lifecycle.Evolve with eventCid = clockEventCid; observableCids = []; ruleName = "Time"; timeObservableCid = clockCid

  -- Define settlement routes from CSD to Investor and create batch factory
  let routes = M.fromList [cashRoute, bondRoute]

  settlementFactoryCid <- submit csd do
    toInterfaceContractId <$> createCmd FactoryWithIntermediaries
      with
        provider = csd
        paths = routes
        observers = fromList [investor]

  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submit csd do
    createCmd Claim.Rule
      with
        providers = fromList [csd]
        claimers = singleton csd
        settlers
        settlementFactoryCid

  result <- submit csd do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = csd
      holdingCids = [csdBondHoldingCid, investorBondHoldingCid]
      effectCid
      batchId = Id "CouponSettlement"

  let [   csdBondInstructionCid1      -- old bond from CSD to issuer
        , issuerBondInstructionCid    -- new bond from issuer to CSD
        , issuerCashInstructionCid    -- coupon payment from issuer to CSD
        , investorBondInstructionCid  -- old bond from investor to CSD
        , csdBondInstructionCid2      -- new bond from CSD to investor
        , csdCashInstructionCid       -- coupon payment from CSD to investor's bank
        , bankCashInstructionCid      -- coupon payment from investor's bank to investor
        ] = result.instructionCids

  Some issuerCashInstruction <- queryContractId csd $ fromInterfaceContractId @Instruction.T issuerCashInstructionCid
  let issuerCashInstructionKey = InstructionKey with
        requestors = issuerCashInstruction.requestors
        batchId = issuerCashInstruction.batchId
        id = issuerCashInstruction.id

  Some csdCashInstruction <- queryContractId csd $ fromInterfaceContractId @Instruction.T csdCashInstructionCid
  let csdCashInstructionKey = InstructionKey with
        requestors = csdCashInstruction.requestors
        batchId = csdCashInstruction.batchId
        id = csdCashInstruction.id

  -- Allocate instructions
  (csdBondInstructionCid1, _) <- submit csd do exerciseCmd csdBondInstructionCid1 Instruction.Allocate with actors = singleton csd; allocation = Pledge $ coerceContractId csdBondHoldingCid
  (issuerBondInstructionCid, _) <- submit issuer do exerciseCmd issuerBondInstructionCid Instruction.Allocate with actors = singleton issuer; allocation = CreditReceiver
  (issuerCashInstructionCid, _) <- submit issuer do exerciseCmd issuerCashInstructionCid Instruction.Allocate with actors = singleton issuer; allocation = Pledge $ coerceContractId issuerCashHoldingCid
  (investorBondInstructionCid, _) <- submit investor do exerciseCmd investorBondInstructionCid Instruction.Allocate with actors = singleton investor; allocation = Pledge $ coerceContractId investorBondHoldingCid
  (csdBondInstructionCid2, _) <- submit csd do exerciseCmd csdBondInstructionCid2 Instruction.Allocate with actors = singleton csd; allocation = CreditReceiver
  (csdCashInstructionCid, _) <- submit csd do exerciseCmd csdCashInstructionCid Instruction.Allocate with actors = singleton csd; allocation = PassthroughFrom (csdCashAccount, issuerCashInstructionKey)
  (bankCashInstructionCid, _) <- submit bank do exerciseCmd bankCashInstructionCid Instruction.Allocate with actors = singleton bank; allocation = CreditReceiver

  -- Approve instructions
  csdBondInstructionCid1 <- submit issuer do
    exerciseCmd csdBondInstructionCid1 Instruction.Approve with actors = singleton issuer; approval = DebitSender
  issuerBondInstructionCid <- submit csd do
    exerciseCmd issuerBondInstructionCid Instruction.Approve with actors = singleton csd; approval = TakeDelivery csdAccountAtIssuer
  issuerCashInstructionCid <- submit csd do
    exerciseCmd issuerCashInstructionCid Instruction.Approve with actors = singleton csd; approval = PassthroughTo (csdCashAccount, csdCashInstructionKey)
  investorBondInstructionCid <- submit csd do
    exerciseCmd investorBondInstructionCid Instruction.Approve with actors = singleton csd; approval = DebitSender
  csdBondInstructionCid2 <- submit investor do
    exerciseCmd csdBondInstructionCid2 Instruction.Approve with actors = singleton investor; approval = TakeDelivery investorSecuritiesAccount
  csdCashInstructionCid <- submit bank do
    exerciseCmd csdCashInstructionCid Instruction.Approve with actors = singleton bank; approval = TakeDelivery bankCashAccount
  bankCashInstructionCid <- submit investor do
    exerciseCmd bankCashInstructionCid Instruction.Approve with actors = singleton investor; approval = TakeDelivery investorCashAccount

  -- Settle batch
  [csdBondHoldingCid, bankCashHoldingCid, investorBondHoldingCid, investorCashHoldingCid] <- submitMulti (toList settlers) [publicParty] do exerciseCmd result.batchCid Batch.Settle with actors = settlers

  -- Assert state
  Holding.verifyOwnerOfHolding
    [ (csd, csdBondHoldingCid)
    , (investor, investorBondHoldingCid)
    , (bank, coerceContractId bankCashHoldingCid)
    , (investor, coerceContractId investorCashHoldingCid)
    ]

  pure ()

-- | Service template that allows to claim an effect and settle the corresponding transactions atomically.
template EffectSettlementService
  with
    csd : Party
      -- ^ Owner of the instrument holding. Acts as depository of the instrument.
    issuer : Party
      -- ^ Counterparty of the instrument holding. Issuer of the instrument.
    instrumentId : Id
      -- ^ Defines the instrument to which the contract is applicable.
    securitiesAccount : Account.K
      -- ^ Security account of CSD @ issuer.
    issuerCashAccount : Account.K
      -- ^ Cash account of Issuer @ Central Bank.
    csdCashAccount : Account.K
      -- ^ Cash account of CSD @ Central Bank. Needs to be disclosed to the Issuer (ideally as part of the creation of this contract).
  where
    signatory csd, issuer

    ensure
      securitiesAccount.custodian == issuer &&
      securitiesAccount.owner == csd &&
      issuerCashAccount.custodian == csdCashAccount.custodian &&
      issuerCashAccount.owner == issuer &&
      csdCashAccount.owner == csd

    nonconsuming choice ClaimAndSettle : (ContractId Effect.I, Optional (ContractId Base.I), [ContractId Transferable.I])
      with
        instrumentHoldingCid : ContractId Base.I
          -- ^ Holding of CSD @ issuer for the old instrument.
        cashHoldingCid : ContractId Transferable.I
          -- ^ Cash holding of issuer @ central bank, used to settle the effect's consequences.
        effectCid : ContractId Effect.I
          -- ^ Effect to claim.
      controller issuer
      do
        effectView <- exercise effectCid Effect.GetView with viewer = issuer

        -- 0. sanity checks
        let
          oldInstrument = effectView.targetInstrument
          newInstrument = effectView.producedInstrument

        oldInstrument.depository === csd
        oldInstrument.issuer === issuer
        oldInstrument.id === instrumentId

        F.forA_ newInstrument $ (=== csd) . (.depository)
        F.forA_ newInstrument $ (=== issuer) . (.issuer)
        F.forA_ newInstrument $ (=== instrumentId) . (.id)

        -- fetch instrument fungible
        fungible <- fetch instrumentHoldingCid
        assertMsg "wrong fungible" $ getInstrument fungible == oldInstrument

        -- 1. csd claims effect against issuer
        settlementFactoryCid <- create Factory with provider = csd; observers = empty

        lifecycleClaimRuleCid <- create Claim.Rule
          with
            providers = singleton issuer
            claimers = fromList [issuer, csd]
            settlers = singleton csd
            settlementFactoryCid = toInterfaceContractId settlementFactoryCid

        result <- exercise (toInterfaceContractId @Claim.I lifecycleClaimRuleCid) Claim.ClaimEffect with
          claimer = csd
          holdingCids = [toInterfaceContractId instrumentHoldingCid]
          effectCid
          batchId = Id "EffectSettlement"

        archive settlementFactoryCid
        archive lifecycleClaimRuleCid

        let [csdInstrumentInstructionCid, issuerInstrumentInstructionCid, issuerCashInstructionCouponCid] = result.instructionCids

        -- Allocate instructions
        (csdInstrumentInstructionCid, _) <- exercise csdInstrumentInstructionCid Instruction.Allocate with actors = singleton csd; allocation = Pledge $ coerceContractId instrumentHoldingCid
        (issuerCashInstructionCouponCid, _) <- exercise issuerCashInstructionCouponCid Instruction.Allocate with actors = singleton issuer; allocation = Pledge $ coerceContractId cashHoldingCid
        (issuerInstrumentInstructionCid, _) <- exercise issuerInstrumentInstructionCid Instruction.Allocate with actors = singleton issuer; allocation = CreditReceiver

        -- Approve instructions
        csdInstrumentInstructionCid <- exercise csdInstrumentInstructionCid Instruction.Approve with actors = singleton issuer; approval = DebitSender
        issuerCashInstructionCouponCid <- exercise issuerCashInstructionCouponCid Instruction.Approve with actors = singleton csd; approval = TakeDelivery csdCashAccount
        issuerInstrumentInstructionCid <- exercise issuerInstrumentInstructionCid Instruction.Approve with actors = singleton csd; approval = TakeDelivery securitiesAccount

        -- Settle batch
        [newInstrumentHoldingCid, investorCashTransferableCouponCid] <- exercise result.batchCid Batch.Settle with actors = singleton csd

        -- 2. create effect to be used by investors
        newEffectCid <- exercise effectCid Effect.SetProvider with newProviders = singleton csd

        pure (newEffectCid, Some (toInterfaceContractId newInstrumentHoldingCid), [investorCashTransferableCouponCid])

-- | HIDE
setupParties : Script TestParties
setupParties = do
  [bank, centralBank, csd, issuer, investor, settler, publicParty] <- createParties ["Bank", "CentralBank", "CSD", "Issuer", "Investor", "Settler", "PublicParty"]
  pure $ TestParties with bank; centralBank; csd; issuer; investor; settlers = singleton settler; publicParty

-- | HIDE
-- Setup a set of accounts.
setupAccounts : Text -> Party -> Party -> [Party] -> Script [Account.K]
setupAccounts description custodian publicParty owners = do
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory custodian []
  holdingFactoryCid <- toInterfaceContractId <$> submit custodian do
    createCmd Fungible.Factory with provider= custodian; observers = M.fromList [("PublicParty", singleton publicParty)]
  forA owners $ Account.createAccount description [] accountFactoryCid holdingFactoryCid [] Account.Owner custodian

