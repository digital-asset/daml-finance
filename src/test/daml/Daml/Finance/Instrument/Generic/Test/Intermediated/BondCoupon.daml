-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Generic.Test.Intermediated.BondCoupon where

import ContingentClaims.Core.Claim (Inequality(..), andList, one, scale, when)
import ContingentClaims.Core.Observation (Observation(..))
import DA.Assert ((===))
import DA.Date (addDays, toDateUTC)
import DA.Foldable qualified as F (forA_)
import DA.Map qualified as M (Map, empty, fromList)
import DA.Set qualified as S (empty, fromList, singleton, toList)
import Daml.Finance.Account.Account qualified as Account (T)
import Daml.Finance.Data.Reference.HolidayCalendar qualified as HolidayCalendar (T)
import Daml.Finance.Data.Time.DateClockUpdate qualified as Event (T)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Instrument.Generic.Instrument qualified as Instrument (T)
import Daml.Finance.Instrument.Generic.Lifecycle.Rule qualified as Lifecycle (Rule(..))
import Daml.Finance.Instrument.Generic.Test.Util (originateGeneric, mapClaimToUTCTime)
import Daml.Finance.Interface.Account.Account qualified as Account (I)
import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Holding.Util (getInstrument)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (SetProviders(..), GetView(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (Evolve(..), I)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentKey, Parties)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I)
import Daml.Finance.Interface.Util.KeyTable (KeyTable(..))
import Daml.Finance.Lifecycle.Rule.Claim qualified as Claim (Rule(..))
import Daml.Finance.Settlement.Factory (Factory(..))
import Daml.Finance.Settlement.Hierarchy (Hierarchy(..))
import Daml.Finance.Settlement.Instruction qualified as Instruction (T)
import Daml.Finance.Settlement.RouteProvider.IntermediatedStatic (IntermediatedStatic(..))
import Daml.Finance.Settlement.Test.Util (buildKeyTableForAllocation, buildKeyTableForApproval, buildKeyTableForBatchSettlement, allocateAny, approveAny, settleAny)
import Daml.Finance.Test.Util.Account qualified as Account (ControlledBy(..), buildKeyTable, createAccount, createFactory, credit)
import Daml.Finance.Test.Util.Common (createParties, queryAnyByKey)
import Daml.Finance.Test.Util.Holding qualified as Holding (verifyOwnerOfHolding)
import Daml.Finance.Test.Util.Instrument qualified as BaseInstrument (originate)
import Daml.Finance.Test.Util.Lifecycle (buildKeyTableForLifecycleEvolve)
import Daml.Finance.Test.Util.Time (createClockUpdateEvent)
import Daml.Script

{-
  This script distributes a bond to investors and showcases how the bond can be lifecycled to
  trigger (and settle) a coupon payment.

  Bond (security) account structure :

     Issuer
       |
      CSD
       |
    Investor

  Cash account structure :

      Central Bank
      /    |     \
    CSD  Issuer  Bank
                   \
                 Investor

  In the "non-atomic" script, the lifecycling and settlement happen in three steps:
    - issuer lifecycles the instrument
    - effects are settled between issuer and CSD
    - effects are settled between CSD and investor(s)

  The last step involves moving cash through an account hierarchy.

  In the "atomic" script, the last two steps are executed atomically.
-}

-- | Parties involved in the test script.
data TestParties = TestParties
  with
    bank : Party
      -- ^ The Bank acts as custodian of the investor's cash holdings.
    centralBank : Party
      -- ^ The Central Bank is the depository and the issuer of the cash instrument. It also acts
      --   as root custodian of the cash holdings.
    csd : Party
      -- ^ Custodian of the bond holding (from the perspective of an investor). It also acts as
      --   depository of the bond instrument.
    issuer : Party
      -- ^ Acts as issuer, as well as the root custodian, of the bond instrument. It is also the
      --   party tasked with lifecycling the bond.
    investor : Party
      -- ^ Owner of the bond holding.
    settlers : Parties
      -- ^ Any party of the settlers triggers the settlement of fully allocated settlement
      --   instructions.
    publicParty : Party
      -- ^ The public party. Every party can readAs the public party.

-- | Originate USD cash instrument and define settlement route.
originateCashAndDefineRoute : TestParties -> Time -> Script (InstrumentKey, (Text, Hierarchy))
originateCashAndDefineRoute TestParties{bank, centralBank, csd, investor, issuer, publicParty}
  now = do
    let
      pp = [("PublicParty", S.singleton publicParty)]
      label = "USD"
      -- CREATE_CASH_ROUTE_BEGIN
      {-
        Cash account structure :

            Central Bank
            /    |     \
          CSD  Issuer  Bank
                        \
                      Investor
      -}
      route =
        ( label
        , Hierarchy with
            rootCustodian = centralBank
            pathsToRootCustodian = [[investor, bank], [csd], [issuer]]
        )
      -- CREATE_CASH_ROUTE_END
    instrument <-
      BaseInstrument.originate centralBank centralBank "USD" "United States Dollar" pp now
    pure (instrument, route)

-- | Originate bond instrument and define settlement route.
originateSecurityAndDefineRoute : TestParties -> Time -> InstrumentKey ->
  Script (InstrumentKey, (Text, Hierarchy))
originateSecurityAndDefineRoute TestParties{bank, csd, investor, issuer, publicParty} now
  cashInstrument = do
    -- CREATE_CC_INSTRUMENT_VARIABLES_BEGIN
    let
      today = toDateUTC now
      expiry = addDays today 180
      bondLabel = "ABC.DE 2% " <> show expiry <> " Corp"
      claims = mapClaimToUTCTime $ andList
        [ when (TimeGte $ today) $ scale (Const 0.02) $ one cashInstrument
        , when (TimeGte $ expiry) $ scale (Const 0.02) $ one cashInstrument
        , when (TimeGte $ expiry) $ scale (Const 1.0) $ one cashInstrument
        ]
    -- CREATE_CC_INSTRUMENT_VARIABLES_END
    let pp = [("PublicParty", S.singleton publicParty)]
    -- CREATE_CC_INSTRUMENT_BEGIN
    instrument <- originateGeneric csd issuer bondLabel "Bond" now claims pp now
    -- CREATE_CC_INSTRUMENT_END
    -- CREATE_BOND_ROUTE_BEGIN
    {-
    Bond (security) account structure :

      Issuer
        |
        CSD
        |
      Investor
    -}
    let
      route =
        ( bondLabel
        , Hierarchy with
            rootCustodian = issuer
            pathsToRootCustodian = [[investor, csd]]
        )
    -- CREATE_BOND_ROUTE_END
    pure (instrument, route)

-- | Penultimate coupon payment on a bond showing creation of new instrument version.
-- Settlement of effects does not happen atomically.
runIntermediatedLifecyclingNonAtomic : Script ()
runIntermediatedLifecyclingNonAtomic = script do
  parties@TestParties{..} <- setupParties

  -- Setup security accounts
  [investorSecuritiesAccount] <- setupAccounts "Securities Account" csd publicParty [investor]
  [csdAccountAtIssuer] <- setupAccounts "Securities Account" issuer publicParty [csd]

  -- Setup cash accounts at central bank
  [issuerCashAccount, bankCashAccount, csdCashAccount] <-
    setupAccounts "Cash Account" centralBank publicParty [issuer, bank, csd]

  -- Setup investor's cash account at Bank
  [investorCashAccount] <- setupAccounts "Cash Account" bank publicParty [investor]

  -- Originate and distribute central-bank cash
  now <- getTime
  let today = toDateUTC now

  (cashInstrument, cashRoute) <- originateCashAndDefineRoute parties now
  issuerCashHoldingCid <- Account.credit [publicParty] cashInstrument 20_000.0 issuerCashAccount

  -- Originate and distribute bond
  (bondInstrument, bondRoute) <- originateSecurityAndDefineRoute parties now cashInstrument
  csdBondHoldingCid <- Account.credit [publicParty] bondInstrument 1_000_000.0 csdAccountAtIssuer
  investorBondHoldingCid <-
    Account.credit [publicParty] bondInstrument 1_000_000.0 investorSecuritiesAccount

  -- CREATE_CLOCK_FOR_BOND_LIFECYCLING_BEGIN
  -- create clock update event
  clockEventCid <- createClockUpdateEvent (S.singleton issuer) today S.empty
  -- CREATE_CLOCK_FOR_BOND_LIFECYCLING_END

  -- LIFECYCLE_BOND_CREATE_RULE_BEGIN
  -- Create a lifecycle rule
  lifecycleRuleCid <- toInterfaceContractId @Lifecycle.I <$> submit csd do
    createCmd Lifecycle.Rule with
      providers = S.singleton csd
      observers= M.empty
      lifecycler = issuer
      id = Id "LifecycleRule"
      description = "Rule to lifecycle a generic instrument"
  -- LIFECYCLE_BOND_CREATE_RULE_END

  -- Build key table
  keyTable <- buildKeyTableForLifecycleEvolve @Instrument.T @HolidayCalendar.T @Event.T [issuer]
    clockEventCid bondInstrument

  -- LIFECYCLE_BOND_BEGIN
  -- Try to lifecycle instrument
  (_, [effectCid]) <- submit issuer do
    fst <$> exerciseCmd lifecycleRuleCid Lifecycle.Evolve with
      eventCid = clockEventCid
      observableCids = []
      instrument = bondInstrument
      keyTable
  -- LIFECYCLE_BOND_END

  -- Define settlement routes across intermediaries
  let routes = M.fromList [cashRoute, bondRoute]

  -- LIFECYCLE_BOND_ISSUER_CSD_BEGIN
  -- Setup settlement contract between issuer and CSD
  -- In order for the workflow to be successful, we need to disclose the CSD's cash account to the
  -- Issuer.
  (csdCashAccountCid, _)<- queryAnyByKey @Account.T @Account.I csd csdCashAccount
  submit csd do
    exerciseCmd (toInterfaceContractId @Disclosure.I csdCashAccountCid)
      Disclosure.AddObservers with
        disclosers = S.singleton csd; observersToAdd = ("Issuer", S.singleton issuer)

  settle1Cid <- submitMulti [csd, issuer] [] do
    createCmd EffectSettlementService with
      csd
      issuer
      instrumentId = bondInstrument.id
      securitiesAccount = csdAccountAtIssuer
      issuerCashAccount
      csdCashAccount
      settlementRoutes = routes

  -- Build key table
  keyTable <- mconcat <$> mapA (uncurry Account.buildKeyTable)
    [ (investor, investorSecuritiesAccount)
      , (investor, investorCashAccount)
      , (issuer, issuerCashAccount)
      , (bank, bankCashAccount)
      , (csd, csdCashAccount)
      , (csd, csdAccountAtIssuer)
      ]

  -- CSD claims and settles effect against issuer
  (effectCid, newInstrumentHoldingCid, [cashHoldingCid], keyTable) <-
    submitMulti [issuer] [publicParty] do
      exerciseCmd settle1Cid ClaimAndSettle with
        instrumentHoldingCid = csdBondHoldingCid
        cashHoldingCid = issuerCashHoldingCid
        effectCid
        keyTable
  -- LIFECYCLE_BOND_ISSUER_CSD_END

  -- LIFECYCLE_BOND_SETTLEMENT_FACTORY_BEGIN
  -- investor claims effect against CSD
  routeProviderCid <- toInterfaceContractId <$> submit csd do
    createCmd IntermediatedStatic with
      provider = csd; observers = S.singleton investor; paths = routes

  settlementFactoryCid <- submit csd do
    toInterfaceContractId <$> createCmd Factory with
      provider = csd; observers = S.singleton investor
  -- LIFECYCLE_BOND_SETTLEMENT_FACTORY_END

  -- LIFECYCLE_BOND_CSD_INVESTOR_BEGIN
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submit csd do
    createCmd Claim.Rule with
      providers = S.singleton csd
      claimers = S.fromList [csd, investor]
      settlers
      routeProviderCid
      settlementFactoryCid
      netInstructions = False

  result <- submit csd do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = csd
      holdingCids = [investorBondHoldingCid]
      effectCid
      batchId = Id "CouponSettlement"
  -- LIFECYCLE_BOND_CSD_INVESTOR_END

  -- LIFECYCLE_BOND_ALLOCATE_APPROVE_SETTLE_BEGIN
  let
    [investorBondInstructionCid, csdBondInstructionCid, csdCashInstructionCid,
      bankCashInstructionCid] = result.instructionCids

  -- Allocate instructions
  let allocation = Pledge investorBondHoldingCid
  keyTable <- buildKeyTableForAllocation [investor] allocation
  ((investorBondInstructionCid, _), _) <- submit investor do
    exerciseCmd investorBondInstructionCid Instruction.Allocate with
      actors = S.singleton investor; allocation; keyTable
  let allocation = CreditReceiver
  keyTable <- buildKeyTableForAllocation [csd] allocation
  ((csdBondInstructionCid, _), _) <- submit csd do
    exerciseCmd csdBondInstructionCid Instruction.Allocate with
      actors = S.singleton csd; allocation; keyTable
  let allocation = Pledge cashHoldingCid
  keyTable <- buildKeyTableForAllocation [csd] allocation
  ((csdCashInstructionCid, _), _) <- submit csd do
    exerciseCmd csdCashInstructionCid Instruction.Allocate with
      actors = S.singleton csd; allocation; keyTable
  let allocation = CreditReceiver
  keyTable <- buildKeyTableForAllocation [bank] allocation
  ((bankCashInstructionCid, _), keyTable) <- submit bank do
    exerciseCmd bankCashInstructionCid Instruction.Allocate with
      actors = S.singleton bank; allocation; keyTable

  -- Approve instructions
  let approval = DebitSender
  keyTable <- buildKeyTableForApproval [csd] approval
  (investorBondInstructionCid, keyTable) <- submit csd do
    exerciseCmd investorBondInstructionCid Instruction.Approve with
      actors = S.singleton csd; approval; keyTable
  let approval = TakeDelivery investorSecuritiesAccount
  keyTable <- buildKeyTableForApproval [investor] approval
  (csdBondInstructionCid, keyTable) <- submit investor do
    exerciseCmd csdBondInstructionCid Instruction.Approve with
      actors = S.singleton investor; approval; keyTable
  let approval = TakeDelivery bankCashAccount
  keyTable <- buildKeyTableForApproval [bank] approval
  (csdCashInstructionCid, keyTable) <- submit bank do
    exerciseCmd csdCashInstructionCid Instruction.Approve with
      actors = S.singleton bank; approval; keyTable
  let approval = TakeDelivery investorCashAccount
  keyTable <- buildKeyTableForApproval [investor] approval
  (bankCashInstructionCid, keyTable) <- submit investor do
    exerciseCmd bankCashInstructionCid Instruction.Approve with
      actors = S.singleton investor; approval; keyTable

  -- Build key table
  keyTable <- buildKeyTableForBatchSettlement (S.toList settlers) result.batchCid

  -- Settle batch
  [investorBondHoldingCid, bankCashHoldingCid, investorCashHoldingCid] <-
    submitMulti (S.toList settlers) [publicParty] do
      fst <$> exerciseCmd result.batchCid Batch.Settle with actors = settlers; keyTable
  -- LIFECYCLE_BOND_ALLOCATE_APPROVE_SETTLE_END

  -- Assert state
  Holding.verifyOwnerOfHolding
    [ (investor, investorBondHoldingCid)
    , (bank, bankCashHoldingCid)
    , (investor, investorCashHoldingCid)
    ]

  pure ()

-- | Penultimate coupon payment on a bond showing creation of new instrument version.
-- The effect is claimed and settled atomically across the entire chain.
runIntermediatedLifecyclingAtomic : Script ()
runIntermediatedLifecyclingAtomic = script do
  parties@TestParties{..} <- setupParties

  -- Setup security accounts
  [investorSecuritiesAccount] <- setupAccounts "Securities Account" csd publicParty [investor]
  [csdAccountAtIssuer] <- setupAccounts "Securities Account" issuer publicParty [csd]

  -- Setup cash accounts at central bank
  [issuerCashAccount, bankCashAccount, csdCashAccount] <-
    setupAccounts "Cash Account" centralBank publicParty [issuer, bank, csd]

  -- Setup investor's cash account at Bank
  [investorCashAccount] <- setupAccounts "Cash Account" bank publicParty [investor]

  -- Originate and distribute central-bank cash
  now <- getTime
  let today = toDateUTC now

  (cashInstrument, cashRoute) <- originateCashAndDefineRoute parties now
  issuerCashHoldingCid <- Account.credit [publicParty] cashInstrument 20_000.0 issuerCashAccount

  -- Originate and distribute bond
  (bondInstrument, bondRoute) <- originateSecurityAndDefineRoute parties now cashInstrument
  csdBondHoldingCid <- Account.credit [publicParty] bondInstrument 1_000_000.0 csdAccountAtIssuer
  investorBondHoldingCid <-
    Account.credit [publicParty] bondInstrument 1_000_000.0 investorSecuritiesAccount

  -- create clock update event
  clockEventCid <- createClockUpdateEvent (S.singleton issuer) today S.empty

  -- Create a lifecycle rule
  lifecycleRuleCid <- toInterfaceContractId @Lifecycle.I <$> submit csd do
    createCmd Lifecycle.Rule with
      providers = S.singleton csd
      observers= M.empty
      lifecycler = issuer
      id = Id "LifecycleRule"
      description = "Rule to lifecycle a generic instrument"

  -- Build key table
  keyTable <- buildKeyTableForLifecycleEvolve @Instrument.T @HolidayCalendar.T @Event.T [issuer]
    clockEventCid bondInstrument

  -- Try to lifecycle the instrument
  (_, [effectCid]) <- submit issuer do
    fst <$> exerciseCmd lifecycleRuleCid Lifecycle.Evolve with
      eventCid = clockEventCid
      observableCids = []
      instrument = bondInstrument
      keyTable

  -- Define settlement routes from CSD to Investor and create batch factory
  let routes = M.fromList [cashRoute, bondRoute]

  routeProviderCid <- toInterfaceContractId <$> submit csd do
    createCmd IntermediatedStatic with
      provider = csd; observers = S.singleton investor; paths = routes

  settlementFactoryCid <- submit csd do
    toInterfaceContractId <$> createCmd Factory with
      provider = csd; observers = S.singleton investor

  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submit csd do
    createCmd Claim.Rule with
      providers = S.singleton csd
      claimers = S.singleton csd
      settlers
      routeProviderCid
      settlementFactoryCid
      netInstructions = False

  -- LIFECYCLE_BOND_ATOMIC_CLAIMEFFECT_BEGIN
  result <- submit csd do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = csd
      holdingCids = [csdBondHoldingCid, investorBondHoldingCid]
      effectCid
      batchId = Id "CouponSettlement"
  -- LIFECYCLE_BOND_ATOMIC_CLAIMEFFECT_END

  -- LIFECYCLE_BOND_ATOMIC_INSTRUCTIONS_BEGIN
  let
    [   csdBondInstructionCid1      -- old bond from CSD to issuer
      , issuerBondInstructionCid    -- new bond from issuer to CSD
      , issuerCashInstructionCid    -- coupon payment from issuer to CSD
      , investorBondInstructionCid  -- old bond from investor to CSD
      , csdBondInstructionCid2      -- new bond from CSD to investor
      , csdCashInstructionCid       -- coupon payment from CSD to investor's bank
      , bankCashInstructionCid      -- coupon payment from investor's bank to investor
      ] = result.instructionCids
  -- LIFECYCLE_BOND_ATOMIC_INSTRUCTIONS_END

  Some issuerCashInstruction <-
    queryContractId csd $ fromInterfaceContractId @Instruction.T issuerCashInstructionCid
  let
    issuerCashInstructionKey = InstructionKey with
      requestors = issuerCashInstruction.requestors
      batchId = issuerCashInstruction.batchId
      id = issuerCashInstruction.id

  Some csdCashInstruction <-
    queryContractId csd $ fromInterfaceContractId @Instruction.T csdCashInstructionCid
  let
    csdCashInstructionKey = InstructionKey with
      requestors = csdCashInstruction.requestors
      batchId = csdCashInstruction.batchId
      id = csdCashInstruction.id

  -- Allocate instructions
  (csdBondInstructionCid1, _) <- allocateAny [csd] csdBondInstructionCid1 $ Pledge csdBondHoldingCid
  (issuerBondInstructionCid, _) <- allocateAny [issuer] issuerBondInstructionCid $ CreditReceiver
  (issuerCashInstructionCid, _) <- allocateAny [issuer] issuerCashInstructionCid $
    Pledge issuerCashHoldingCid
  (investorBondInstructionCid, _) <- allocateAny [investor] investorBondInstructionCid $
    Pledge investorBondHoldingCid
  (csdBondInstructionCid2, _) <- allocateAny [csd] csdBondInstructionCid2 $ CreditReceiver
  (csdCashInstructionCid, _) <- allocateAny [csd] csdCashInstructionCid $
    PassThroughFrom (csdCashAccount, issuerCashInstructionKey)
  (bankCashInstructionCid, _) <- allocateAny [bank] bankCashInstructionCid $ CreditReceiver

  -- Approve instructions
  csdBondInstructionCid1 <- approveAny [issuer] csdBondInstructionCid1 $ DebitSender
  issuerBondInstructionCid <- approveAny [csd] issuerBondInstructionCid $
    TakeDelivery csdAccountAtIssuer
  issuerCashInstructionCid <- approveAny [csd] issuerCashInstructionCid $
    PassThroughTo (csdCashAccount, csdCashInstructionKey)
  investorBondInstructionCid <- approveAny [csd] investorBondInstructionCid $ DebitSender
  csdBondInstructionCid2 <- approveAny [investor] csdBondInstructionCid2 $
    TakeDelivery investorSecuritiesAccount
  csdCashInstructionCid <- approveAny [bank] csdCashInstructionCid $ TakeDelivery bankCashAccount
  bankCashInstructionCid <- approveAny [investor] bankCashInstructionCid $
    TakeDelivery investorCashAccount

  -- Settle batch
  [csdBondHoldingCid, bankCashHoldingCid, investorBondHoldingCid, investorCashHoldingCid] <-
    settleAny (S.toList settlers) [publicParty] result.batchCid

  -- Assert state
  Holding.verifyOwnerOfHolding
    [ (csd, csdBondHoldingCid)
    , (investor, investorBondHoldingCid)
    , (bank, bankCashHoldingCid)
    , (investor, investorCashHoldingCid)
    ]

  pure ()

-- | Service template that allows to claim an effect and settle the corresponding transactions
-- atomically.
template EffectSettlementService
  with
    csd : Party
      -- ^ Owner of the instrument holding. Acts as depository of the instrument.
    issuer : Party
      -- ^ Counterparty of the instrument holding. Issuer of the instrument.
    instrumentId : Id
      -- ^ Defines the instrument to which the contract is applicable.
    securitiesAccount : AccountKey
      -- ^ Security account of CSD @ issuer.
    issuerCashAccount : AccountKey
      -- ^ Cash account of Issuer @ Central Bank.
    csdCashAccount : AccountKey
      -- ^ Cash account of CSD @ Central Bank. Needs to be disclosed to the Issuer (ideally as part
      --   of the creation of this contract).
    settlementRoutes : M.Map Text Hierarchy
  where
    signatory csd, issuer

    ensure
      securitiesAccount.custodian == issuer &&
      securitiesAccount.owner == csd &&
      issuerCashAccount.custodian == csdCashAccount.custodian &&
      issuerCashAccount.owner == issuer &&
      csdCashAccount.owner == csd

    nonconsuming choice ClaimAndSettle
      : (ContractId Effect.I, Optional (ContractId Base.I), [ContractId Base.I], KeyTable)
      with
        instrumentHoldingCid : ContractId Base.I
          -- ^ Holding of CSD @ issuer for the old instrument.
        cashHoldingCid : ContractId Base.I
          -- ^ Cash holding of issuer @ central bank, used to settle the effect's consequences.
        effectCid : ContractId Effect.I
          -- ^ Effect to claim.
        keyTable : KeyTable
          -- ^ The key table needed for the action.
      controller issuer
      do
        effectView <- exercise effectCid Effect.GetView with viewer = issuer

        -- 0. sanity checks
        let
          oldInstrument = effectView.targetInstrument
          newInstrument = effectView.producedInstrument

        oldInstrument.depository === csd
        oldInstrument.issuer === issuer
        oldInstrument.id === instrumentId

        F.forA_ newInstrument $ (=== csd) . (.depository)
        F.forA_ newInstrument $ (=== issuer) . (.issuer)
        F.forA_ newInstrument $ (=== instrumentId) . (.id)

        -- fetch instrument fungible
        fungible <- fetch instrumentHoldingCid
        assertMsg "wrong fungible" $ getInstrument fungible == oldInstrument

        -- 1. csd claims effect against issuer
        routeProviderCid <- toInterfaceContractId <$> create IntermediatedStatic with
          provider = csd; observers = S.empty; paths = settlementRoutes
        settlementFactoryCid <- create Factory with provider = csd; observers = S.empty

        lifecycleClaimRuleCid <- create Claim.Rule with
          providers = S.singleton issuer
          claimers = S.fromList [issuer, csd]
          settlers = S.singleton csd
          routeProviderCid
          settlementFactoryCid = toInterfaceContractId settlementFactoryCid
          netInstructions = False

        result <- exercise (toInterfaceContractId @Claim.I lifecycleClaimRuleCid)
          Claim.ClaimEffect with
            claimer = csd
            holdingCids = [instrumentHoldingCid]
            effectCid
            batchId = Id "EffectSettlement"

        archive settlementFactoryCid
        archive lifecycleClaimRuleCid

        let
          [ csdInstrumentInstructionCid,
            issuerInstrumentInstructionCid,
            issuerCashInstructionCouponCid ] = result.instructionCids

        -- Allocate instructions
        ((csdInstrumentInstructionCid, _), keyTable) <- exercise csdInstrumentInstructionCid
          Instruction.Allocate with
            actors = S.singleton csd; allocation = Pledge instrumentHoldingCid; keyTable
        ((issuerCashInstructionCouponCid, _), keyTable) <- exercise issuerCashInstructionCouponCid
          Instruction.Allocate with
            actors = S.singleton issuer; allocation = Pledge cashHoldingCid; keyTable
        ((issuerInstrumentInstructionCid, _), keyTable) <- exercise issuerInstrumentInstructionCid
          Instruction.Allocate with
            actors = S.singleton issuer; allocation = CreditReceiver; keyTable

        -- Approve instructions
        (csdInstrumentInstructionCid, keyTable) <- exercise csdInstrumentInstructionCid
          Instruction.Approve with
            actors = S.singleton issuer; approval = DebitSender; keyTable

        (issuerCashInstructionCouponCid, keyTable) <- exercise issuerCashInstructionCouponCid
          Instruction.Approve with
            actors = S.singleton csd; approval = TakeDelivery csdCashAccount; keyTable

        (issuerInstrumentInstructionCid, keyTable) <- exercise issuerInstrumentInstructionCid
          Instruction.Approve with
            actors = S.singleton csd; approval = TakeDelivery securitiesAccount; keyTable

        -- Settle batch
        [newInstrumentHoldingCid, investorCashHoldingCouponCid] <-
          fst <$> exercise result.batchCid Batch.Settle with actors = S.singleton csd; keyTable

        -- 2. create effect to be used by investors
        newEffectCid <- exercise effectCid Effect.SetProviders with newProviders = S.singleton csd

        pure (newEffectCid, Some newInstrumentHoldingCid, [investorCashHoldingCouponCid], keyTable)

-- | HIDE
setupParties : Script TestParties
setupParties = do
  [bank, centralBank, csd, issuer, investor, settler, publicParty] <-
    createParties ["Bank", "CentralBank", "CSD", "Issuer", "Investor", "Settler", "PublicParty"]
  pure TestParties with
    bank; centralBank; csd; issuer; investor; settlers = S.singleton settler; publicParty

-- | HIDE
-- Setup a set of accounts.
setupAccounts : Text -> Party -> Party -> [Party] -> Script [AccountKey]
setupAccounts description custodian publicParty owners = do
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory custodian []
  holdingFactoryCid <- toInterfaceContractId <$> submit custodian do
    createCmd Fungible.Factory with
      provider= custodian; observers = M.fromList [("PublicParty", S.singleton publicParty)]
  forA owners $ Account.createAccount description [] accountFactoryCid holdingFactoryCid []
    Account.Owner custodian
