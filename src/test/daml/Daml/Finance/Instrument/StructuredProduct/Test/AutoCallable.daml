-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.StructuredProduct.Test.AutoCallable where

import DA.Date (DayOfWeek(..), Month(..), date)
import DA.Map qualified as Map (fromList)
import DA.Set qualified as Set (singleton)
import Daml.Finance.Data.Numeric.Observation (Observation(..))
import Daml.Finance.Data.Reference.HolidayCalendar (HolidayCalendar(..))
import Daml.Finance.Data.Time.DateClock (dateToDateClockTime)
import Daml.Finance.Instrument.StructuredProduct.Test.Util (originateAutoCallable)
import Daml.Finance.Interface.Types.Common.Types (HoldingStandard(..), Id(..))
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayConventionEnum(..), HolidayCalendarData(..))
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum(..))
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum(..))
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Instrument (originate)
import Daml.Finance.Test.Util.Lifecycle (lifecycleAndVerifyPaymentEffects, verifyNoLifecycleEffects)
import Daml.Finance.Test.Util.Time (createPaymentPeriodicSchedule)
import Daml.Script

-- Define and lifecycle an AutoCallable Yield Note.
run : Script ()
run = script do
  [custodian, issuer, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Calendar Data Provider", "PublicParty"]

  -- Account and holding factory
  let pp = [("FactoryProvider", Set.singleton publicParty)]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", Set.singleton publicParty)]
  cashInstrument <- originate custodian issuer "USD" TransferableFungible "US Dollars" observers now

  -- Create and distribute option
  let
    barrierHigh : Decimal = 30.0
    strikeLow : Decimal = 35.0
    callBarrierLow : Decimal = 38.0
    finalBarrierHigh : Decimal = 40.0
    -- CREATE_AUTO_CALLABLE_VARIABLES_BEGIN
    barrier : Decimal = 26.0 -- TODO: separate into couponBarrier and finalBarrier
    callBarrier = 40.0
    strike : Decimal = 40.0 -- TODO: separate into initialValue and callValue
    finalBarrier : Decimal = 35.0
    expiryDate = date 2024 Sep 28
    --barrierStartDate = expiryDate
    referenceAssetId = "AAPL-CLOSE"
    couponRate : Decimal = 0.05
    initialValuationDate = date 2024 Jan 10
    issueDate = date 2024 Jan 16
    firstRegularObervationDate = date 2024 Mar 28
    firstCouponDate = date 2024 Apr 2
    secondCouponDate = date 2024 Jul 2
    maturityDate = date 2024 Oct 2
    -- CREATE_AUTO_CALLABLE_VARIABLES_END
    businessDayConvention = Following
    couponPeriod = M
    couponPeriodMultiplier = 3
    dayCountConvention = Basis1
    holidayCalendarIds = ["USD"]
    calendar =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = []
    couponSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
      businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    observationSchedule = createPaymentPeriodicSchedule firstRegularObervationDate holidayCalendarIds
      businessDayConvention couponPeriod couponPeriodMultiplier initialValuationDate expiryDate
    notional : Decimal = 1.0

  debug couponSchedule
  debug observationSchedule

  -- CREATE_AUTO_CALLABLE_OBSERVATIONS_BEGIN
  let
    observations = Map.fromList
      [ (dateToDateClockTime $ date 2024 Mar 28, 28.78)
      , (dateToDateClockTime $ date 2024 Jun 28, 39.78)
      , (dateToDateClockTime $ date 2024 Sep 30, 36.0)
      ]
  observableCid <- toInterfaceContractId <$> submit issuer do
    createCmd Observation with
      provider = issuer; id = Id referenceAssetId; observations; observers = mempty
  -- CREATE_AUTO_CALLABLE_OBSERVATIONS_END

  -- A reference data provider publishes the holiday calendar on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with
      provider = calendarDataProvider
      calendar
      observers = Map.fromList pp

  -----------------------------------------------------------------------
  -- 1. AutoCallable without barrier events (and no early redemption)  --
  -----------------------------------------------------------------------

  brcInstrument <- originateAutoCallable issuer issuer "AC" TransferableFungible
    "Option" observers now expiryDate strike barrier callBarrier finalBarrier cashInstrument
    referenceAssetId couponRate observationSchedule couponSchedule holidayCalendarIds dayCountConvention notional
    calendarDataProvider publicParty

  let
    expectedConsumed = []
    expectedProduced = [qty 0.05 cashInstrument]
  Some brcInstrumentAfterCouponDate1 <- lifecycleAndVerifyPaymentEffects [publicParty]
    firstCouponDate brcInstrument issuer [observableCid] expectedConsumed
    expectedProduced

  let
    expectedConsumed = []
    expectedProduced = [qty 0.05 cashInstrument]
  Some brcInstrumentAfterCouponDate2 <- lifecycleAndVerifyPaymentEffects [publicParty] secondCouponDate brcInstrumentAfterCouponDate1 issuer
    [observableCid] expectedConsumed expectedProduced

  let
    expectedConsumed = []
    expectedProduced = [qty 1.05 cashInstrument]
  lifecycleAndVerifyPaymentEffects [publicParty] maturityDate brcInstrumentAfterCouponDate2 issuer
    [observableCid] expectedConsumed expectedProduced

  --------------------------------------------------------------------
  -- 2. AutoCallable with barrier events (and no early redemption)  --
  --------------------------------------------------------------------

  brcInstrument <- originateAutoCallable issuer issuer "AC2" TransferableFungible
    "Option" observers now expiryDate strike barrierHigh callBarrier finalBarrierHigh cashInstrument
    referenceAssetId couponRate observationSchedule couponSchedule holidayCalendarIds dayCountConvention notional
    calendarDataProvider publicParty

  -- The first coupon is not paid because the coupon barrier is hit
  let
    expectedConsumed = []
    expectedProduced = []
  Some brcInstrumentAfterCouponDate1 <- lifecycleAndVerifyPaymentEffects [publicParty]
    firstCouponDate brcInstrument issuer [observableCid] expectedConsumed
    expectedProduced

  -- The second coupon is paid (no barrier hit)
  let
    expectedConsumed = []
    expectedProduced = [qty 0.05 cashInstrument]
  Some brcInstrumentAfterCouponDate2 <- lifecycleAndVerifyPaymentEffects [publicParty] secondCouponDate brcInstrumentAfterCouponDate1 issuer
    [observableCid] expectedConsumed expectedProduced

  -- Redemption amount is less than principal because the final barrier is hit
  let
    expectedConsumed = []
    expectedProduced = [qty 0.95 cashInstrument]
  lifecycleAndVerifyPaymentEffects [publicParty] maturityDate brcInstrumentAfterCouponDate2 issuer
    [observableCid] expectedConsumed expectedProduced

  --------------------------------------------
  -- 3. AutoCallable with early redemption  --
  --------------------------------------------

  brcInstrument <- originateAutoCallable issuer issuer "AC3" TransferableFungible
    "Option" observers now expiryDate strike barrierHigh callBarrierLow finalBarrier cashInstrument
    referenceAssetId couponRate observationSchedule couponSchedule holidayCalendarIds dayCountConvention notional
    calendarDataProvider publicParty

  -- The first coupon is not paid because the coupon barrier is hit
  let
    expectedConsumed = []
    expectedProduced = []
  Some brcInstrumentAfterCouponDate1 <- lifecycleAndVerifyPaymentEffects [publicParty]
    firstCouponDate brcInstrument issuer [observableCid] expectedConsumed
    expectedProduced

  -- Auto-call on the second coupon date
  let
    expectedConsumed = []
    expectedProduced = [qty 1.05 cashInstrument]
  Some brcInstrumentAfterCouponDate2 <- lifecycleAndVerifyPaymentEffects [publicParty] secondCouponDate brcInstrumentAfterCouponDate1 issuer
    [observableCid] expectedConsumed expectedProduced

  -- Ensure no lifecycle effects on a called instrument
  verifyNoLifecycleEffects [publicParty] maturityDate brcInstrumentAfterCouponDate2 issuer
    [observableCid]

  pure ()
