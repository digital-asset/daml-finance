-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.StructuredProduct.Test.BarrierReverseConvertible where

import DA.Date (DayOfWeek(..), Month(..), date)
import DA.Map qualified as M (empty, fromList)
import DA.Set qualified as S (singleton)
import Daml.Finance.Data.Numeric.Observation (Observation(..))
import Daml.Finance.Data.Reference.HolidayCalendar (HolidayCalendar(..))
import Daml.Finance.Instrument.StructuredProduct.Test.Util (originateBarrierReverseConvertible)
import Daml.Finance.Interface.Types.Common.Types (Id(..))
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayConventionEnum(..), HolidayCalendarData(..))
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum(..))
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum(..))
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Instrument (originate)
import Daml.Finance.Test.Util.Lifecycle (lifecycleAndVerifyPaymentEffects, verifyNoLifecycleEffects)
import Daml.Finance.Test.Util.Time (createPaymentPeriodicSchedule, dateToDateClockTime)
import Daml.Script

-- Define and lifecycle barrier call/put options, which are automatically exercised and cash
-- settled.
run : Script ()
run = script do
  [custodian, issuer, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Calendar Data Provider", "PublicParty"]

  -- Account and holding factory
  let pp = [("FactoryProvider", S.singleton publicParty)]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", S.singleton publicParty)]
  cashInstrument <- originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute option
  let
    barrierLow : Decimal = 20.0
    -- CREATE_BARRIER_REVERSE_CONVERTIBLE_VARIABLES_BEGIN
    barrier = 30.0
    barrierStartDate = date 2019 Jan 20
    strike = 40.0
    expiryDate = date 2019 May 15
    referenceAssetId = "AAPL-CLOSE"
    couponRate = 0.011
    issueDate = date 2019 Jan 16
    firstCouponDate = date 2019 May 14
    maturityDate = date 2021 May 14
    -- CREATE_BARRIER_REVERSE_CONVERTIBLE_VARIABLES_END
    longOption = True
    businessDayConvention = Following
    couponPeriod = M
    couponPeriodMultiplier = 3
    dayCountConvention = Act360
    holidayCalendarIds = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = []
    couponSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
      businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    notional = 1.0

  -- CREATE_BARRIER_REVERSE_CONVERTIBLE_OBSERVATIONS_BEGIN
  let
    observations = M.fromList
      [ (dateToDateClockTime $ date 2019 May 13, 28.78)
      , (dateToDateClockTime $ date 2019 May 14, 49.78)
      , (dateToDateClockTime $ date 2019 May 15, 48.78)
      , (dateToDateClockTime $ date 2019 May 16, 18.78)
      , (dateToDateClockTime $ date 2019 May 17, 48.78)
      , (dateToDateClockTime $ date 2019 May 20, 58.78)
      , (dateToDateClockTime $ date 2019 May 21, 48.78)
      ]
  observableCid <- toInterfaceContractId <$> submit issuer do
    createCmd Observation with
      provider = issuer; id = Id referenceAssetId; observations; observers = M.empty
  -- CREATE_BARRIER_REVERSE_CONVERTIBLE_OBSERVATIONS_END

  -- A reference data provider publishes the holiday calendar on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with
      provider = calendarDataProvider
      calendar = cal
      observers = M.fromList pp

  -----------------------------------
  -- 2. Down-And-In barrier option --
  -----------------------------------

  -- Test option with barrier hit (on May 13)
  downAndInLongCallInstrument <- originateBarrierReverseConvertible issuer issuer "DownAndIn"
    "Option" observers now expiryDate strike barrier barrierStartDate cashInstrument
    referenceAssetId couponRate couponSchedule holidayCalendarIds dayCountConvention notional
    calendarDataProvider

  let
    expectedConsumed = []
    expectedProduced = []
  Some optionInstrumentAfterBarrierHit <- lifecycleAndVerifyPaymentEffects [publicParty]
    (date 2019 May 13) downAndInLongCallInstrument issuer [observableCid] expectedConsumed
    expectedProduced

  let
    expectedConsumed = []
    expectedProduced = [qty 0.0036055556 cashInstrument]
  Some optionInstrumentAfterCouponPayment <- lifecycleAndVerifyPaymentEffects [publicParty]
    (date 2019 May 14) optionInstrumentAfterBarrierHit issuer [observableCid] expectedConsumed
    expectedProduced

  -- TODO: This should work after previousEvents has been implemented
  let
    expectedConsumed = [qty 8.78 cashInstrument]
    expectedProduced = []
  lifecycleAndVerifyPaymentEffects [publicParty] expiryDate optionInstrumentAfterCouponPayment issuer
    [observableCid] expectedConsumed expectedProduced


{-
  -- TODO: This should fail after previousEvents has been implemented
  verifyNoLifecycleEffects [publicParty] expiryDate optionInstrumentAfterCouponPayment
    issuer [observableCid]
 -}

  -- Test option without barrier hit. Also test a barrier hit after expiry.
  downAndInLowBarrierLongCallInstrument <- originateBarrierReverseConvertible issuer issuer
    "DownAndInLow" "Option" observers now expiryDate strike barrierLow
    barrierStartDate cashInstrument
    referenceAssetId couponRate couponSchedule holidayCalendarIds dayCountConvention notional
    calendarDataProvider

  verifyNoLifecycleEffects [publicParty] (date 2019 May 13) downAndInLowBarrierLongCallInstrument
    issuer [observableCid]

  let
    expectedConsumed = []
    expectedProduced = [qty 0.0036055556 cashInstrument]
  Some optionInstrumentAfterCouponPayment <- lifecycleAndVerifyPaymentEffects [publicParty]
    (date 2019 May 14) downAndInLowBarrierLongCallInstrument issuer [observableCid] expectedConsumed
    expectedProduced

  verifyNoLifecycleEffects [publicParty] expiryDate optionInstrumentAfterCouponPayment issuer
    [observableCid]

  let
    expectedConsumed = []
    expectedProduced = []
  Some optionInstrumentAfterBarrierHit <- lifecycleAndVerifyPaymentEffects [publicParty]
    (date 2019 May 16) optionInstrumentAfterCouponPayment issuer [observableCid] expectedConsumed
    expectedProduced

  verifyNoLifecycleEffects [publicParty] (date 2019 May 17) optionInstrumentAfterBarrierHit
    issuer [observableCid]

  pure ()
