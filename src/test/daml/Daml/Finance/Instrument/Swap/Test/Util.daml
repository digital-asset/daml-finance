-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Swap.Test.Util where

import DA.Date
import DA.List (head)
import DA.Map qualified as M (fromList)
import DA.Set (empty, fromList, singleton, toList)
import Daml.Finance.Instrument.Swap.Asset.Instrument qualified as AssetSwap (Instrument(..))
import Daml.Finance.Instrument.Swap.CreditDefault.Instrument qualified as CreditDefaultSwap (Instrument(..))
import Daml.Finance.Instrument.Swap.Currency.Instrument qualified as CurrencySwap (Instrument(..))
import Daml.Finance.Instrument.Swap.ForeignExchange.Instrument qualified as ForeignExchange (Instrument(..))
import Daml.Finance.Instrument.Swap.InterestRate.Instrument qualified as InterestRateSwap (Instrument(..))
import Daml.Finance.Interface.Data.Observable qualified as Observable (I)
import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (GetView(..), K, I, toKey)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (I, Evolve(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayAdjustment(..), BusinessDayConventionEnum)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum, RollConventionEnum(..))
import Daml.Finance.Interface.Types.Date.Schedule (Frequency(..), PeriodicSchedule(..))
import Daml.Finance.Lifecycle.Rule.Claim qualified as Claim (Rule(..))
import Daml.Finance.Settlement.Factory (Factory(..))
import Daml.Finance.Test.Util.Holding (verifyOwnerOfHolding)
import Daml.Finance.Test.Util.Instrument (createReference)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (submitExerciseInterfaceByKeyCmd)
import Daml.Finance.Test.Util.Lifecycle (createClockAndEvent)
import Daml.Script

-- | Create a schedule for periodic payments.
createPaymentPeriodicSchedule : Date -> [Text] -> BusinessDayConventionEnum -> PeriodEnum -> Int -> Date -> Date -> PeriodicSchedule
createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate = do
  -- CREATE_SWAP_PERIODIC_SCHEDULE_BEGIN
  let
    (y, m, d) = toGregorian firstCouponDate
    periodicSchedule = PeriodicSchedule with
      businessDayAdjustment =
        BusinessDayAdjustment with
          calendarIds = holidayCalendarIds
          convention = businessDayConvention
      effectiveDateBusinessDayAdjustment = None
      terminationDateBusinessDayAdjustment = None
      frequency =
        Frequency with
          rollConvention = DOM d
          period = couponPeriod
          periodMultiplier = couponPeriodMultiplier
      effectiveDate = issueDate
      firstRegularPeriodStartDate = Some firstCouponDate
      lastRegularPeriodEndDate = Some maturityDate
      stubPeriodType = None
      terminationDate = maturityDate
  -- CREATE_SWAP_PERIODIC_SCHEDULE_END
  periodicSchedule

-- | Originate an interest rate swap.
originateInterestRateSwap : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Text -> Bool -> Script Instrument.K
originateInterestRateSwap depository issuer label description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention fixRate couponPeriod couponPeriodMultiplier currency referenceRateId issuerPaysFix = do
  let
    periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  -- CREATE_INTEREST_RATE_SWAP_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd InterestRateSwap.Instrument with depository; issuer; id = Id label; version = "0"; description; observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; issuerPaysFix; fixRate; referenceRateId; currency
  -- CREATE_INTEREST_RATE_SWAP_INSTRUMENT_END
  createReference cid depository issuer observers

-- | Originate an asset swap.
originateAssetSwap : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Text -> Bool -> Script Instrument.K
originateAssetSwap depository issuer label description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention fixRate couponPeriod couponPeriodMultiplier currency referenceAssetId issuerPaysFix = do
  let
    periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  -- CREATE_ASSET_SWAP_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd AssetSwap.Instrument with depository; issuer; id = Id label; version = "0"; description; observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; issuerPaysFix; fixRate; referenceAssetId; currency
  -- CREATE_ASSET_SWAP_INSTRUMENT_END
  createReference cid depository issuer observers

-- | Originate a credit default swap.
originateCreditDefaultSwap : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Text -> Text -> Bool -> Script Instrument.K
originateCreditDefaultSwap depository issuer label description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention fixRate couponPeriod couponPeriodMultiplier currency defaultProbabilityReferenceId recoveryRateReferenceId issuerPaysFix = do
  let
    periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  -- CREATE_CREDIT_DEFAULT_SWAP_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd CreditDefaultSwap.Instrument with depository; issuer; id = Id label; version = "0"; description; observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; issuerPaysFix; fixRate; defaultProbabilityReferenceId; recoveryRateReferenceId; currency
  -- CREATE_CREDIT_DEFAULT_SWAP_INSTRUMENT_END
  createReference cid depository issuer observers

-- | Originate a currency swap.
originateCurrencySwap : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Instrument.K -> Decimal -> Bool -> Script Instrument.K
originateCurrencySwap depository issuer label description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention baseRate foreignRate couponPeriod couponPeriodMultiplier baseCurrency foreignCurrency fxRate issuerPaysBase = do
  let
    periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  -- CREATE_CURRENCY_SWAP_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd CurrencySwap.Instrument with depository; issuer; id = Id label; version = "0"; description; observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; issuerPaysBase; baseRate; foreignRate; baseCurrency; foreignCurrency; fxRate
  -- CREATE_CURRENCY_SWAP_INSTRUMENT_BEGIN
  createReference cid depository issuer observers

-- | Originate an FX swap.
originateForeignExchangeSwap : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date -> Date -> Date -> Instrument.K -> Instrument.K -> Decimal -> Decimal -> Script Instrument.K
originateForeignExchangeSwap depository issuer label description observers lastEventTimestamp issueDate firstPaymentDate maturityDate baseCurrency foreignCurrency firstFxRate finalFxRate = do
  -- CREATE_FOREIGN_EXCHANGE_SWAP_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd ForeignExchange.Instrument with depository; issuer; id = Id label; version = "0"; description; observers = M.fromList observers; lastEventTimestamp; firstFxRate; finalFxRate; issueDate; firstPaymentDate; maturityDate, baseCurrency; foreignCurrency
  -- CREATE_FOREIGN_EXCHANGE_SWAP_INSTRUMENT_END
  createReference cid depository issuer observers

-- | Lifecycle the instrument as of this date. This is a general function that can be used for both bonds and swaps.
lifecycleInstrument : [Party] -> Date -> Instrument.K -> Parties -> Party -> [ContractId Observable.I] -> Script (ContractId Lifecycle.I, [ContractId Effect.I])
lifecycleInstrument readAs today instrument settlers issuer observableCids = do
  -- CREATE_CLOCK_FOR_BOND_LIFECYCLING_BEGIN
  -- create clock and clock update event
  (clockCid, clockEventCid) <- createClockAndEvent (singleton issuer) today empty
  -- CREATE_CLOCK_FOR_BOND_LIFECYCLING_END

  -- LIFECYCLE_BOND_BEGIN
  -- Try to lifecycle instrument
  (lifecycleCid, effectCids) <- Instrument.submitExerciseInterfaceByKeyCmd @Lifecycle.I [issuer] readAs instrument
    Lifecycle.Evolve with settlers; eventCid = clockEventCid; observableCids; ruleName = "Time"; clockCid
  -- LIFECYCLE_BOND_END

  pure (lifecycleCid, effectCids)

-- | Verify a that there are no lifecycle effects of the instrument on this date. This is a general function that can be used for both bonds and swaps.
verifyNoLifecycleEffects : [Party] -> Date -> Instrument.K -> Parties -> Party -> [ContractId Observable.I] -> Script ()
verifyNoLifecycleEffects readAs today instrument settlers issuer observableCids = do
  (bondLifecycleCid2, effectCids) <- lifecycleInstrument readAs today instrument settlers issuer observableCids
  assertMsg ("There should be no lifecycle effects on " <> show today) (null effectCids)

-- | Verify the payments from a payment date of an interest rate swap.
lifecycleAndVerifySwapPaymentEffectsAndSettlement : [Party] -> Date -> Instrument.K -> Parties -> Party -> Party -> ContractId Transferable.I -> ContractId Transferable.I -> ContractId Transferable.I -> AccountKey -> AccountKey -> [(Text, Parties)] -> Party -> [ContractId Observable.I] -> Script (Instrument.K, ContractId Transferable.I)
lifecycleAndVerifySwapPaymentEffectsAndSettlement readAs today swapInstrument settlers issuer investor investorSwapTransferableCid investorCashTransferableFixLegCid custodianCashTransferableFloatingLegCid custodianAccount investorAccount obs custodian observableCids = do
  (swapLifecycleCid, [effectCid]) <- lifecycleInstrument readAs today swapInstrument settlers issuer observableCids

  newSwapInstrumentKey <- submit issuer do
    Instrument.toKey <$> exerciseCmd @Instrument.I (coerceContractId swapLifecycleCid) Instrument.GetView with viewer = issuer

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId <$> submit investor do createCmd Factory with provider = investor; observers = empty

  -- Claim effect
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submitMulti [custodian, investor] [] do
    createCmd Claim.Rule
      with
        providers = fromList [custodian, investor]
        claimers = singleton investor
        settlers
        settlementFactoryCid

  result <- submitMulti [investor] readAs do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = investor
      holdingCids = [toInterfaceContractId @Base.I investorSwapTransferableCid]
      effectCid
      batchId = Id "InterestSettlement"

  let
    Some [investorSwapHoldingCid] = result.newInstrumentHoldingCids
    [custodianCashInstructionFixLegCid, custodianCashInstructionFloatingLegCid] = result.instructionCids

  -- Allocate instructions
  (custodianCashInstructionFixLegCid, _) <- submitMulti [investor] readAs do exerciseCmd custodianCashInstructionFixLegCid Instruction.Allocate with allocation = Pledge investorCashTransferableFixLegCid; actors = singleton investor
  (custodianCashInstructionFloatingLegCid, _) <- submitMulti [custodian] readAs do exerciseCmd custodianCashInstructionFloatingLegCid Instruction.Allocate with allocation = Pledge custodianCashTransferableFloatingLegCid; actors = singleton custodian

  -- Approve instructions
  investorCashInstructionFixLegCid <- submitMulti [custodian] [] do
    exerciseCmd custodianCashInstructionFixLegCid Instruction.Approve with approval = TakeDelivery custodianAccount; actors = singleton custodian
  custodianCashInstructionFloatingLegCid <- submitMulti [investor] [] do
    exerciseCmd custodianCashInstructionFloatingLegCid Instruction.Approve with approval = TakeDelivery investorAccount; actors = singleton investor

  -- Settle batch
  let settlerUsed = head $ toList settlers
  [investorCashTransferableFixLegCid, investorCashTransferableFloatingLegCid] <- submitMulti [settlerUsed] readAs do exerciseCmd result.batchCid Batch.Settle with actors = singleton settlerUsed

  -- Assert state
  verifyOwnerOfHolding [(investor, investorSwapHoldingCid), (custodian, toInterfaceContractId investorCashTransferableFixLegCid), (investor, toInterfaceContractId investorCashTransferableFloatingLegCid)]

  pure (newSwapInstrumentKey, coerceContractId investorSwapHoldingCid)

-- | Verify the payments from a payment date of an asset swap.
lifecycleAndVerifyAssetSwapPaymentEffectsAndSettlement : [Party] -> Date -> Instrument.K -> Parties -> Party -> Party -> ContractId Transferable.I -> ContractId Transferable.I -> ContractId Transferable.I -> ContractId Transferable.I -> AccountKey -> AccountKey -> [(Text, Parties)] -> Party -> [ContractId Observable.I] -> Script (Instrument.K, ContractId Transferable.I)
lifecycleAndVerifyAssetSwapPaymentEffectsAndSettlement readAs today swapInstrument settlers issuer investor investorSwapTransferableCid investorCashTransferableFixLegCid custodianCashTransferableAssetLegCid investorCashTransferableAssetCorrectionLegCid custodianAccount investorAccount obs custodian observableCids = do
  (swapLifecycleCid, [effectCid]) <- lifecycleInstrument readAs today swapInstrument settlers issuer observableCids

  newSwapInstrumentKey <- submit issuer do
    Instrument.toKey <$> exerciseCmd @Instrument.I (coerceContractId swapLifecycleCid) Instrument.GetView with viewer = issuer

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId <$> submit investor do createCmd Factory with provider = investor; observers = empty

  -- Claim effect
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submitMulti [custodian, investor] [] do
    createCmd Claim.Rule
      with
        providers = fromList [custodian, investor]
        claimers = singleton investor
        settlers
        settlementFactoryCid

  result <- submitMulti [investor] readAs do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = investor
      holdingCids = [toInterfaceContractId @Base.I investorSwapTransferableCid]
      effectCid
      batchId = Id "InterestSettlement"

  let
    Some [investorSwapHoldingCid] = result.newInstrumentHoldingCids
    [custodianCashInstructionFixLegCid, investorCashInstructionAssetCorrectionLegCid, custodianCashInstructionAssetLegCid] = result.instructionCids

  -- Allocate instructions
  (custodianCashInstructionFixLegCid, _) <- submitMulti [investor] readAs do exerciseCmd custodianCashInstructionFixLegCid Instruction.Allocate with allocation = Pledge investorCashTransferableFixLegCid
  (custodianCashInstructionAssetLegCid, _) <- submitMulti [custodian] readAs do exerciseCmd custodianCashInstructionAssetLegCid Instruction.Allocate with allocation = Pledge custodianCashTransferableAssetLegCid
  (investorCashInstructionAssetCorrectionLegCid, _) <- submitMulti [investor] readAs do exerciseCmd investorCashInstructionAssetCorrectionLegCid Instruction.Allocate with allocation = Pledge investorCashTransferableAssetCorrectionLegCid

  -- Approve instructions
  investorCashInstructionFixLegCid <- submitMulti [custodian] [] do
    exerciseCmd custodianCashInstructionFixLegCid Instruction.Approve with approval = TakeDelivery custodianAccount
  custodianCashInstructionAssetLegCid <- submitMulti [investor] [] do
    exerciseCmd custodianCashInstructionAssetLegCid Instruction.Approve with approval = TakeDelivery investorAccount
  custodianCashInstructionAssetCorrectionLegCid <- submitMulti [custodian] [] do
    exerciseCmd investorCashInstructionAssetCorrectionLegCid Instruction.Approve with approval = TakeDelivery custodianAccount

  -- Settle batch
  let settlerUsed = head $ toList settlers
  [investorCashTransferableFixLegCid, investorCashTransferableAssetLegCid, investorCashTransferableAssetCorrectionLegCid] <- submitMulti [settlerUsed] readAs do exerciseCmd result.batchCid Batch.Settle with actors = singleton settlerUsed

  -- Assert state
  verifyOwnerOfHolding [(investor, investorSwapHoldingCid), (custodian, toInterfaceContractId investorCashTransferableFixLegCid), (custodian, toInterfaceContractId investorCashTransferableAssetLegCid), (investor, toInterfaceContractId investorCashTransferableAssetCorrectionLegCid)]

  pure (newSwapInstrumentKey, coerceContractId investorSwapHoldingCid)

-- | Verify the payments from the final payment date of an asset swap.
lifecycleAndVerifyFinalAssetSwapPaymentEffects : [Party] -> Date -> Instrument.K -> Parties -> Party -> Party -> ContractId Transferable.I -> ContractId Transferable.I -> ContractId Transferable.I -> ContractId Transferable.I -> AccountKey -> AccountKey -> [(Text, Parties)] -> Party -> [ContractId Observable.I] -> Script (Instrument.K)
lifecycleAndVerifyFinalAssetSwapPaymentEffects readAs today swapInstrument settlers issuer investor investorSwapTransferableCid investorCashTransferableFixLegCid custodianCashTransferableAssetLegCid investorCashTransferableAssetCorrectionLegCid custodianAccount investorAccount obs custodian observableCids = do
  (swapLifecycleCid, [effectCid]) <- lifecycleInstrument readAs today swapInstrument settlers issuer observableCids

  newSwapInstrumentKey <- submit issuer do
    Instrument.toKey <$> exerciseCmd @Instrument.I (coerceContractId swapLifecycleCid) Instrument.GetView with viewer = issuer

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId <$> submit investor do createCmd Factory with provider = investor; observers = empty

  -- Claim effect
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submitMulti [custodian, investor] [] do
    createCmd Claim.Rule
      with
        providers = fromList [custodian, investor]
        claimers = singleton investor
        settlers
        settlementFactoryCid

  result <- submitMulti [investor] readAs do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = investor
      holdingCids = [toInterfaceContractId @Base.I investorSwapTransferableCid]
      effectCid
      batchId = Id "InterestSettlement"

  let
    [custodianCashInstructionFixLegCid, custodianCashInstructionAssetCorrectionLegCid, custodianCashInstructionAssetLegCid] = result.instructionCids

  -- Allocate instructions
  (custodianCashInstructionFixLegCid, _) <- submitMulti [investor] readAs do exerciseCmd custodianCashInstructionFixLegCid Instruction.Allocate with allocation = Pledge investorCashTransferableFixLegCid
  (custodianCashInstructionAssetLegCid, _) <- submitMulti [custodian] readAs do exerciseCmd custodianCashInstructionAssetLegCid Instruction.Allocate with allocation = Pledge custodianCashTransferableAssetLegCid
  (investorCashInstructionAssetCorrectionLegCid, _) <- submitMulti [investor] readAs do exerciseCmd custodianCashInstructionAssetCorrectionLegCid Instruction.Allocate with allocation = Pledge investorCashTransferableAssetCorrectionLegCid

  -- Approve instructions
  investorCashInstructionFixLegCid <- submitMulti [custodian] [] do
    exerciseCmd custodianCashInstructionFixLegCid Instruction.Approve with approval = TakeDelivery custodianAccount
  custodianCashInstructionAssetLegCid <- submitMulti [investor] [] do
    exerciseCmd custodianCashInstructionAssetLegCid Instruction.Approve with approval = TakeDelivery investorAccount
  custodianCashInstructionAssetCorrectionLegCid <- submitMulti [custodian] [] do
    exerciseCmd investorCashInstructionAssetCorrectionLegCid Instruction.Approve with approval = TakeDelivery custodianAccount

  -- Settle batch
  let settlerUsed = head $ toList settlers
  [investorCashTransferableFixLegCid, investorCashTransferableAssetLegCid, investorCashTransferableAssetCorrectionLegCid] <- submitMulti [settlerUsed] readAs do exerciseCmd result.batchCid Batch.Settle with actors = singleton settlerUsed

  pure (newSwapInstrumentKey)

-- | Verify the payments from the final payment date of an interest rate swap.
lifecycleAndVerifyFinalSwapPaymentEffects : [Party] -> Date -> Instrument.K -> Parties -> Party -> Party -> ContractId Transferable.I -> ContractId Transferable.I -> ContractId Transferable.I -> AccountKey -> AccountKey -> [(Text, Parties)] -> Party -> [ContractId Observable.I] -> Script (Instrument.K)
lifecycleAndVerifyFinalSwapPaymentEffects readAs today swapInstrument settlers issuer investor investorSwapTransferableCid investorCashTransferableFixLegCid custodianCashTransferableFloatingLegCid custodianAccount investorAccount obs custodian observableCids = do
  (swapLifecycleCid, [effectCid]) <- lifecycleInstrument readAs today swapInstrument settlers issuer observableCids

  newSwapInstrumentKey <- submit issuer do
    Instrument.toKey <$> exerciseCmd @Instrument.I (coerceContractId swapLifecycleCid) Instrument.GetView with viewer = issuer

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId <$> submit investor do createCmd Factory with provider = investor; observers = empty

  -- Claim effect
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submitMulti [custodian, investor] [] do
    createCmd Claim.Rule
      with
        providers = fromList [custodian, investor]
        claimers = singleton investor
        settlers
        settlementFactoryCid

  result <- submitMulti [investor] readAs do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = investor
      holdingCids = [toInterfaceContractId @Base.I investorSwapTransferableCid]
      effectCid
      batchId = Id "FinalPaymentSettlement"

  let
    [custodianCashInstructionFixLegCid, custodianCashInstructionFloatingLegCid] = result.instructionCids

  -- Allocate instructions
  (custodianCashInstructionFixLegCid, _) <- submitMulti [investor] readAs do exerciseCmd custodianCashInstructionFixLegCid Instruction.Allocate with allocation = Pledge investorCashTransferableFixLegCid; actors = singleton investor
  (custodianCashInstructionFloatingLegCid, _) <- submitMulti [custodian] readAs do exerciseCmd custodianCashInstructionFloatingLegCid Instruction.Allocate with allocation = Pledge custodianCashTransferableFloatingLegCid; actors = singleton custodian

  -- Approve instructions
  investorCashInstructionFixLegCid <- submitMulti [custodian] [] do
    exerciseCmd custodianCashInstructionFixLegCid Instruction.Approve with approval = TakeDelivery custodianAccount; actors = singleton custodian
  custodianCashInstructionFloatingLegCid <- submitMulti [investor] [] do
    exerciseCmd custodianCashInstructionFloatingLegCid Instruction.Approve with approval = TakeDelivery investorAccount; actors = singleton investor

  -- Settle batch
  let settlerUsed = head $ toList settlers
  [investorCashTransferableFixLegCid, investorCashTransferableFloatingLegCid] <- submitMulti [settlerUsed] readAs do exerciseCmd result.batchCid Batch.Settle with actors = singleton settlerUsed

  pure (newSwapInstrumentKey)

-- | Verify the fix payments from a payment date of a credit default swap.
lifecycleAndVerifyCreditDefaultSwapPaymentEffectsAndSettlement : [Party] -> Date -> Instrument.K -> Parties -> Party -> Party -> ContractId Transferable.I -> ContractId Transferable.I -> AccountKey -> AccountKey -> [(Text, Parties)] -> Party -> [ContractId Observable.I] -> Script (Instrument.K, ContractId Transferable.I)
lifecycleAndVerifyCreditDefaultSwapPaymentEffectsAndSettlement readAs today swapInstrument settlers issuer investor investorSwapTransferableCid investorCashTransferableFixLegCid custodianAccount investorAccount obs custodian observableCids = do
  (swapLifecycleCid, [effectCid]) <- lifecycleInstrument readAs today swapInstrument settlers issuer observableCids

  newSwapInstrumentKey <- submit issuer do
    Instrument.toKey <$> exerciseCmd @Instrument.I (coerceContractId swapLifecycleCid) Instrument.GetView with viewer = issuer

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId <$> submit investor do createCmd Factory with provider = investor; observers = empty

  -- Claim effect
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submitMulti [custodian, investor] [] do
    createCmd Claim.Rule
      with
        providers = fromList [custodian, investor]
        claimers = singleton investor
        settlers
        settlementFactoryCid

  result <- submitMulti [investor] readAs do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = investor
      holdingCids = [toInterfaceContractId @Base.I investorSwapTransferableCid]
      effectCid
      batchId = Id "InterestSettlement"

  let
    Some [investorSwapHoldingCid] = result.newInstrumentHoldingCids
    [custodianCashInstructionFixLegCid] = result.instructionCids

  -- Allocate instructions
  (custodianCashInstructionFixLegCid, _) <- submitMulti [investor] readAs do exerciseCmd custodianCashInstructionFixLegCid Instruction.Allocate with allocation = Pledge investorCashTransferableFixLegCid; actors = singleton investor

  -- Approve instructions
  investorCashInstructionFixLegCid <- submitMulti [custodian] [] do
    exerciseCmd custodianCashInstructionFixLegCid Instruction.Approve with approval = TakeDelivery custodianAccount; actors = singleton custodian

  -- Settle batch
  let settlerUsed = head $ toList settlers
  [investorCashTransferableFixLegCid] <- submitMulti [settlerUsed] readAs do exerciseCmd result.batchCid Batch.Settle with actors = singleton settlerUsed

  -- Assert state
  verifyOwnerOfHolding [(investor, investorSwapHoldingCid), (custodian, toInterfaceContractId investorCashTransferableFixLegCid)]

  pure (newSwapInstrumentKey, coerceContractId investorSwapHoldingCid)

-- | Verify the credit default payment of a credit default swap.
lifecycleAndVerifyCreditDefaultFinalSwapPaymentEffects : [Party] -> Date -> Instrument.K -> Parties -> Party -> Party -> ContractId Transferable.I  -> ContractId Transferable.I -> AccountKey -> AccountKey -> [(Text, Parties)] -> Party -> [ContractId Observable.I] -> Script (Instrument.K)
lifecycleAndVerifyCreditDefaultFinalSwapPaymentEffects readAs today swapInstrument settlers issuer investor investorSwapTransferableCid custodianCashTransferableDefaultPaymentLegCid custodianAccount investorAccount obs custodian observableCids = do
  (swapLifecycleCid, [effectCid]) <- lifecycleInstrument readAs today swapInstrument settlers issuer observableCids

  newSwapInstrumentKey <- submit issuer do
    Instrument.toKey <$> exerciseCmd @Instrument.I (coerceContractId swapLifecycleCid) Instrument.GetView with viewer = issuer

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId <$> submit investor do createCmd Factory with provider = investor; observers = empty

  -- Claim effect
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submitMulti [custodian, investor] [] do
    createCmd Claim.Rule
      with
        providers = fromList [custodian, investor]
        claimers = singleton investor
        settlers
        settlementFactoryCid

  result <- submitMulti [investor] readAs do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = investor
      holdingCids = [toInterfaceContractId @Base.I investorSwapTransferableCid]
      effectCid
      batchId = Id "CreditDefaultSettlement"

  let
    [custodianCashInstructionFixLegCid] = result.instructionCids

  -- Allocate instructions
  (custodianCashInstructionDefaultPaymentCid, _) <- submitMulti [custodian] readAs do exerciseCmd custodianCashInstructionFixLegCid Instruction.Allocate with allocation = Pledge custodianCashTransferableDefaultPaymentLegCid; actors = singleton custodian

  -- Approve instructions
  custodianCashInstructionDefaultPaymentLegCid <- submitMulti [investor] [] do
    exerciseCmd custodianCashInstructionDefaultPaymentCid Instruction.Approve with approval = TakeDelivery investorAccount; actors = singleton investor

  -- Settle batch
  let settlerUsed = head $ toList settlers
  [investorCashTransferableFixLegCid] <- submitMulti [settlerUsed] readAs do exerciseCmd result.batchCid Batch.Settle with actors = singleton settlerUsed

  pure (newSwapInstrumentKey)
