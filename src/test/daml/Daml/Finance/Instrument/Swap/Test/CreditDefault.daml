-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Swap.Test.CreditDefault where

import DA.Date
import DA.Map qualified as M (empty, fromList)
import DA.Set (singleton)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Instrument.Generic.Util
import Daml.Finance.Instrument.Swap.Test.Util
import Daml.Finance.Interface.Types.Common (Id(..))
import Daml.Finance.Interface.Types.Date.Calendar
import Daml.Finance.Interface.Types.Date.DayCount
import Daml.Finance.Interface.Types.Date.RollConvention
import Daml.Finance.Data.Reference.HolidayCalendar
import Daml.Finance.Data.Observable.Observation (Observation(..))
import Daml.Finance.Test.Util.Account qualified as Account (createAccount, createFactory, credit)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (originate)
import Daml.Script

-- Calculate credit default swap payments (test case with a credit event), including lifecycling and creation of new instrument version.
run : Script ()
run = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Account and holding factory
  let fp = [("FactoryProvider", singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory custodian fp
  holdingFactoryCid <- toInterfaceContractId <$> submitMulti [custodian] [] do
    createCmd Fungible.Factory with provider = custodian; observers = M.fromList fp

  -- Create accounts
  [custodianAccount, investorAccount] <- mapA (Account.createAccount "Default Account" [publicParty] accountFactoryCid holdingFactoryCid [] custodian) [custodian, investor]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- CREATE_CREDIT_DEFAULT_SWAP_VARIABLES_BEGIN
  let
    issueDate = date 2019 Jan 16
    firstPaymentDate = date 2019 Feb 15
    maturityDate = date 2019 May 15
    defaultProbabilityReferenceId = "TSLA-DEFAULT-PROB"
    recoveryRateReferenceId = "TSLA-RECOVERY-RATE"
    issuerPaysFix = False
    fixRate = 0.0201
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    -- CREATE_CREDIT_DEFAULT_SWAP_VARIABLES_END
    firstFixPaymentAmount = 1675.0
    creditEventPaymentAmount = 400000.0
    principalAmount = 1_000_000.0
    creditEventDate = date 2019 Mar 15
    probIfNoCreditEvent = 0.2
    probIfCreditEvent = 1.0
    recoveryRate = 0.6
    defaultProbabilityObservations = M.fromList [(dateToDateClockTime (subtractDays firstPaymentDate 1), probIfNoCreditEvent), (dateToDateClockTime firstPaymentDate, probIfNoCreditEvent), (dateToDateClockTime (addDays firstPaymentDate 1), probIfNoCreditEvent), (dateToDateClockTime creditEventDate, probIfCreditEvent), (dateToDateClockTime maturityDate, probIfNoCreditEvent)]
    recoveryRateObservations = M.fromList [(dateToDateClockTime issueDate, recoveryRate), (dateToDateClockTime firstPaymentDate, recoveryRate), (dateToDateClockTime creditEventDate, recoveryRate)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]

  -- A reference data provider publishes the holiday calendar on the ledger
  calendarCid <- submitMulti [calendarDataProvider] [] do
    createCmd HolidayCalendar with
      agency = calendarDataProvider
      entity = cal.id
      calendar = cal
      observers = M.fromList fp

  observableDefaultProbabilityCid <- coerceContractId <$> submitMulti [issuer] [] do createCmd Observation with provider = issuer; id = Id defaultProbabilityReferenceId; observations = defaultProbabilityObservations; observers = M.empty
  observableRecoveryRateCid <- coerceContractId <$> submitMulti [issuer] [] do createCmd Observation with provider = issuer; id = Id recoveryRateReferenceId; observations = recoveryRateObservations; observers = M.empty
  let observableCids = [observableDefaultProbabilityCid, observableRecoveryRateCid]

  swapInstrument <- originateCreditDefaultSwap custodian issuer "SwapTest1" "Credit default swap" fp now issueDate holidayCalendarId calendarDataProvider firstPaymentDate maturityDate dayCountConvention businessDayConvention fixRate paymentPeriod paymentPeriodMultiplier cashInstrumentCid defaultProbabilityReferenceId recoveryRateReferenceId issuerPaysFix
  investorSwapTransferableCid <- Account.credit [publicParty] swapInstrument principalAmount investorAccount

  let settlers = singleton custodian

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays firstPaymentDate 1) swapInstrument settlers issuer observableCids

  -- First payment date: Lifecycle and verify that there are lifecycle effects for the fix payment.
  investorCashForFixPaymentTransferableCid <- Account.credit [publicParty] cashInstrumentCid firstFixPaymentAmount investorAccount
  (swapInstrumentAfterFirstPayment, investorSwapTransferableCid) <- lifecycleAndVerifyCreditDefaultSwapPaymentEffectsAndSettlement [publicParty] firstPaymentDate swapInstrument settlers issuer investor investorSwapTransferableCid investorCashForFixPaymentTransferableCid custodianAccount investorAccount observers custodian observableCids

  -- One day after the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (addDays firstPaymentDate 1) swapInstrumentAfterFirstPayment settlers issuer observableCids

  -- Credit event date: Lifecycle and verify that there is a lifecycle effect for the (1-recoveryRate) payment.
  custodianCashForCreditEventPaymentTransferableCid <- Account.credit [publicParty] cashInstrumentCid creditEventPaymentAmount custodianAccount
  lifecycleAndVerifyCreditDefaultFinalSwapPaymentEffects [publicParty] creditEventDate swapInstrumentAfterFirstPayment settlers issuer investor investorSwapTransferableCid custodianCashForCreditEventPaymentTransferableCid custodianAccount investorAccount observers custodian observableCids

  -- One day after credit event date: try to lifecycle and verify that the instrument has automatically expired.
  -- TODO: implement this after having included expire logic (of Until nodes) somewhere in the lifecycle process.

  pure ()

-- Calculate credit default swap payments (test case without a credit event), including lifecycling and creation of new instrument version.
runNoCreditEvent : Script ()
runNoCreditEvent = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Account and holding factory
  let fp = [("FactoryProvider", singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory custodian fp
  holdingFactoryCid <- toInterfaceContractId <$> submitMulti [custodian] [] do
    createCmd Fungible.Factory with provider = custodian; observers = M.fromList fp

  -- Create accounts
  [custodianAccount, investorAccount] <- mapA (Account.createAccount "Default Account" [publicParty] accountFactoryCid holdingFactoryCid [] custodian) [custodian, investor]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  let
    issueDate = date 2019 Jan 16
    firstPaymentDate = date 2019 Feb 15
    maturityDate = date 2019 May 15
    defaultProbabilityReferenceId = "TSLA-DEFAULT-PROB"
    recoveryRateReferenceId = "TSLA-RECOVERY-RATE"
    issuerPaysFix = False
    fixRate = 0.0201
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    firstFixPaymentAmount = 1675.0
    secondFixPaymentAmount = 4969.1667
    principalAmount = 1_000_000.0
    probIfNoCreditEvent = 0.2
    defaultProbabilityObservations = M.fromList [(dateToDateClockTime (subtractDays firstPaymentDate 1), probIfNoCreditEvent), (dateToDateClockTime firstPaymentDate, probIfNoCreditEvent), (dateToDateClockTime (addDays firstPaymentDate 1), probIfNoCreditEvent), (dateToDateClockTime maturityDate, probIfNoCreditEvent), (dateToDateClockTime (addDays maturityDate 1), probIfNoCreditEvent)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]

  -- A reference data provider publishes the holiday calendar on the ledger
  calendarCid <- submitMulti [calendarDataProvider] [] do
    createCmd HolidayCalendar with
      agency = calendarDataProvider
      entity = cal.id
      calendar = cal
      observers = M.fromList fp

  observableDefaultProbabilityCid <- coerceContractId <$> submitMulti [issuer] [] do createCmd Observation with provider = issuer; id = Id defaultProbabilityReferenceId; observations = defaultProbabilityObservations; observers = M.empty
  let observableCids = [observableDefaultProbabilityCid]

  swapInstrument <- originateCreditDefaultSwap custodian issuer "SwapTest1" "Credit default swap" fp now issueDate holidayCalendarId calendarDataProvider firstPaymentDate maturityDate dayCountConvention businessDayConvention fixRate paymentPeriod paymentPeriodMultiplier cashInstrumentCid defaultProbabilityReferenceId recoveryRateReferenceId issuerPaysFix
  investorSwapTransferableCid <- Account.credit [publicParty] swapInstrument principalAmount investorAccount

  let settlers = singleton custodian

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays firstPaymentDate 1) swapInstrument settlers issuer observableCids

  -- First payment date: Lifecycle and verify that there are lifecycle effects for the fix payment.
  investorCashForFixPaymentTransferableCid <- Account.credit [publicParty] cashInstrumentCid firstFixPaymentAmount investorAccount
  (swapInstrumentAfterFirstPayment, investorSwapTransferableCid) <- lifecycleAndVerifyCreditDefaultSwapPaymentEffectsAndSettlement [publicParty] firstPaymentDate swapInstrument settlers issuer investor investorSwapTransferableCid investorCashForFixPaymentTransferableCid custodianAccount investorAccount observers custodian observableCids

  -- One day after the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (addDays firstPaymentDate 1) swapInstrumentAfterFirstPayment settlers issuer observableCids

  -- Second payment date: Lifecycle and verify that there are lifecycle effects for the fix payment.
  investorCashForFixPaymentTransferableCid <- Account.credit [publicParty] cashInstrumentCid secondFixPaymentAmount investorAccount
  (swapInstrumentAfterSecondPayment, investorSwapTransferableCid) <- lifecycleAndVerifyCreditDefaultSwapPaymentEffectsAndSettlement [publicParty] maturityDate swapInstrumentAfterFirstPayment settlers issuer investor investorSwapTransferableCid investorCashForFixPaymentTransferableCid custodianAccount investorAccount observers custodian observableCids

  -- One day after the maturity: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (addDays maturityDate 1) swapInstrumentAfterSecondPayment settlers issuer observableCids

  -- TODO: same as above, after having included expire logic (of Until nodes) somewhere in the lifecycle process, verify that the instrument automatically expires as expected.

  pure ()
