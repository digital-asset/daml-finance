-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Swap.Test.Fpml where

import DA.Date
import DA.Map qualified as M (empty, fromList)
import DA.Set (singleton)
import Daml.Finance.Data.Observable.Observation (Observation(..))
import Daml.Finance.Data.Reference.HolidayCalendar
import Daml.Finance.Instrument.Generic.Util
import Daml.Finance.Instrument.Swap.Test.Util
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Types.Common (Id(..))
import Daml.Finance.Interface.Types.Date.Calendar
import Daml.Finance.Interface.Types.Date.DayCount
import Daml.Finance.Interface.Types.Date.RollConvention
import Daml.Finance.Interface.Types.Fpml
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (originate)
import Daml.Script

-- Calculate interest rate payment on an interest rate swap (represented using FpML swapStreams), including lifecycling and creation of new instrument version.
run : Script ()
run = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Fix vs floating interest rate swap: Libor 3M vs 2.01% p.a. payment every 3M
  -- CREATE_INTEREST_RATE_SWAP_VARIABLES_BEGIN
  let
    issueDate = date 2019 Jan 16
    firstPaymentDate = date 2019 Feb 15
    maturityDate = date 2019 May 15
    referenceRateId = "USD/LIBOR/3M"
    issuerPaysFix = False
    fixRate = 0.0201
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    -- CREATE_INTEREST_RATE_SWAP_VARIABLES_END
    observations = M.fromList [(dateToDateClockTime (date 2019 Jan 11), 0.0027406), (dateToDateClockTime (date 2019 Feb 13), 0.002035)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        -- id = "floatingLegCalcPeriodDates"
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstPaymentDate
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      resetDates = Some ResetDates with
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None

    swapStreamFixedLeg = SwapStream with
      payerPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        -- id = "fixedLegCalcPeriodDates"
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstPaymentDate
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      resetDates = None
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              currency = "USD"
          floatingRateCalculation = None
          fixedRateSchedule = Some FixedRateSchedule with
            initialValue = fixRate
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList observers
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList observers

  observableCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations; observers = M.empty

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" observers now swapStreams calendarDataProvider cashInstrumentCid issuerPartyRef

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  let settlers = singleton custodian
  verifyNoLifecycleEffects [publicParty] (subtractDays firstPaymentDate 1) swapInstrument settlers issuer [observableCid]

  -- First payment date: Lifecycle and verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 0.0014466167 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] firstPaymentDate swapInstrument settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  -- One day after the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (addDays firstPaymentDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- One day before expiry: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays maturityDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- Lifecycle on the second payment date, which is also the expiry date. Verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 0.0044660695 cashInstrumentCid]
    expectedProducedQuantities = []
  lifecycleAndVerifySwapPaymentEffects [publicParty] maturityDate swapInstrumentAfterFirstPayment settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test two stub periods (intial and final) in the same trade.
runDualStub : Script ()
runDualStub = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Account and holding factory
  let fp = [("FactoryProvider", singleton publicParty)]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Fix vs floating interest rate swap: Libor 3M vs 2.01% p.a. payment every 3M
  let
    issueDate = date 2019 Jan 16
    firstRegularPeriodDate = date 2019 Feb 15
    lastRegularPeriodDate = date 2019 May 15
    maturityDate = date 2019 Jul 15
    referenceRateId = "USD/LIBOR/3M"
    issuerPaysFix = False
    fixRate = 0.0201
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    observations = M.fromList [(dateToDateClockTime (date 2019 Jan 11), 0.0027406), (dateToDateClockTime (date 2019 Feb 13), 0.002035), (dateToDateClockTime (date 2019 May 13), 0.0027406)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      resetDates = Some ResetDates with
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1000000.0
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = Some StubCalculationPeriodAmount with
        initialStub = Some StubValue with
          stubRate = Some 0.0027406
          floatingRate = None
        finalStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex=referenceRateId;indexTenor=Some (Period with period=M;periodMultiplier=3)), (StubFloatingRate with floatingRateIndex=referenceRateId;indexTenor=Some (Period with period=M;periodMultiplier=1))]

    swapStreamFixedLeg = SwapStream with
      payerPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      resetDates = None
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1000000.0
              currency = "USD"
          floatingRateCalculation = None
          fixedRateSchedule = Some FixedRateSchedule with
            initialValue = fixRate
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]

  debug swapStreamFloatingLeg

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submitMulti [calendarDataProvider] [] do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList fp
  fixingCalendarCid <- submitMulti [calendarDataProvider] [] do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList fp

  observableCid <- coerceContractId <$> submitMulti [issuer] [] do createCmd Observation with provider = issuer; id = Id referenceRateId; observations; observers = M.empty

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" fp now swapStreams calendarDataProvider cashInstrumentCid issuerPartyRef

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  let settlers = singleton custodian
  verifyNoLifecycleEffects [publicParty] (subtractDays firstRegularPeriodDate 1) swapInstrument settlers issuer [observableCid]

  -- First payment date: Lifecycle and verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 1446.6167 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] firstRegularPeriodDate swapInstrument settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  -- One day after the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (addDays firstRegularPeriodDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- One day before the second payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays lastRegularPeriodDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- Second payment date: Lifecycle and verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 4466.0695 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterSecondPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] lastRegularPeriodDate swapInstrumentAfterFirstPayment settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  -- One day after the second payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (addDays lastRegularPeriodDate 1) swapInstrumentAfterSecondPayment settlers issuer [observableCid]

  -- One day before expiry: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays maturityDate 1) swapInstrumentAfterSecondPayment settlers issuer [observableCid]

  -- Lifecycle on the second payment date, which is also the expiry date. Verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 2941.4539 cashInstrumentCid]
    expectedProducedQuantities = []
  lifecycleAndVerifySwapPaymentEffects [publicParty] maturityDate swapInstrumentAfterSecondPayment settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test interpolation of two floating rates for a stub period, according to the calculation here:
-- https://www.isda.org/a/aWkgE/Linear-interpolation-04022022.pdf
runStubRateInterpolation : Script ()
runStubRateInterpolation = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Account and holding factory
  let fp = [("FactoryProvider", singleton publicParty)]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create swap
  let
    issueDate = date 2022 Jan 10
    firstRegularPeriodDate = date 2022 Mar 20
    lastRegularPeriodDate = date 2022 Jun 20
    maturityDate = date 2022 Jun 20
    referenceRateId = "USD/LIBOR/3M"
    referenceRateOneMonthId = "USD/LIBOR/1M"
    issuerPaysFix = False
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Basis1 -- Use basis 1/1 in order to easily compare the interpolated rate calculation with the ISDA paper
    businessDayConvention = ModifiedFollowing
    observations = M.fromList [(dateToDateClockTime (date 2022 Jan 06), 0.0023129), (dateToDateClockTime (date 2022 Mar 17), 0.002035)]
    observationsOneMonth = M.fromList [(dateToDateClockTime (date 2022 Jan 06), 0.0010414), (dateToDateClockTime (date 2022 Mar 17), 0.002035)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 20
      resetDates = Some ResetDates with
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = Some StubCalculationPeriodAmount with
        initialStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex=referenceRateOneMonthId;indexTenor=Some (Period with period=M;periodMultiplier=1)), (StubFloatingRate with floatingRateIndex=referenceRateId;indexTenor=Some (Period with period=M;periodMultiplier=3))]
        finalStub = None

    swapStreams = [swapStreamFloatingLeg]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submitMulti [calendarDataProvider] [] do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList fp
  fixingCalendarCid <- submitMulti [calendarDataProvider] [] do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList fp

  observableCid <- coerceContractId <$> submitMulti [issuer] [] do createCmd Observation with provider = issuer; id = Id referenceRateId; observations; observers = M.empty
  observableOneMonthCid <- coerceContractId <$> submitMulti [issuer] [] do createCmd Observation with provider = issuer; id = Id referenceRateOneMonthId; observations=observationsOneMonth; observers = M.empty

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" fp now swapStreams calendarDataProvider cashInstrumentCid issuerPartyRef

  let settlers = singleton custodian

  -- First payment date (after weekend adjustment): Lifecycle stub period and verify the lifecycle effects for floating payment.
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 0.001867875 cashInstrumentCid]  -- interpolated stub rate from the ISDA paper
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (addDays firstRegularPeriodDate 1) swapInstrument settlers issuer investor observers custodian [observableCid, observableOneMonthCid] expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test sample trade with two stub periods (intial and final) in the same trade.
runDualStubSampleTrade : Script ()
runDualStubSampleTrade = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Account and holding factory
  let fp = [("FactoryProvider", singleton publicParty)]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Fix vs floating interest rate swap: Libor 3M vs 2.0% p.a.
  let
    issueDate = date 2022 Sep 14
    firstRegularPeriodDate = date 2022 Sep 20
    secondRegularPeriodDate = date 2022 Dec 20
    thirdRegularPeriodDate = date 2023 Mar 20
    lastRegularPeriodDate = date 2023 Jun 20
    maturityDate = date 2023 Sep 14
    firstRegularPeriodDateFixLeg = date 2022 Sep 20
    lastRegularPeriodDateFixLeg = firstRegularPeriodDateFixLeg
    referenceRateId = "USD/LIBOR/3M"
    referenceRateOneMonthId = "USD/LIBOR/1M"
    issuerPaysFix = False
    fixRate = 0.02
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    observations = M.fromList [(dateToDateClockTime (date 2022 Sep 16), 0.01), (dateToDateClockTime (date 2022 Dec 16), 0.01), (dateToDateClockTime (date 2023 Mar 16), 0.01), (dateToDateClockTime (date 2023 Jun 16), 0.01) ]
    observationsOneMonth = M.fromList [(dateToDateClockTime (date 2023 Jun 16), 0.02)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 20
      resetDates = Some ResetDates with
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1000000.0
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.005
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = Some StubCalculationPeriodAmount with
        initialStub = Some StubValue with
          stubRate = Some 0.015
          floatingRate = None
        finalStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex=referenceRateOneMonthId;indexTenor=Some (Period with period=M;periodMultiplier=1)), (StubFloatingRate with floatingRateIndex=referenceRateId;indexTenor=Some (Period with period=M;periodMultiplier=3))]

    swapStreamFixedLeg = SwapStream with
      payerPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDateFixLeg
        lastRegularPeriodEndDate = Some lastRegularPeriodDateFixLeg
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = 1
          period = Y
          rollConvention = DOM 20
      resetDates = None
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1000000.0
              currency = "USD"
          floatingRateCalculation = None
          fixedRateSchedule = Some FixedRateSchedule with
            initialValue = fixRate
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submitMulti [calendarDataProvider] [] do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList fp
  fixingCalendarCid <- submitMulti [calendarDataProvider] [] do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList fp

  observableCid <- coerceContractId <$> submitMulti [issuer] [] do createCmd Observation with provider = issuer; id = Id referenceRateId; observations; observers = M.empty
  observableOneMonthCid <- coerceContractId <$> submitMulti [issuer] [] do createCmd Observation with provider = issuer; id = Id referenceRateOneMonthId; observations=observationsOneMonth; observers = M.empty

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" fp now swapStreams calendarDataProvider cashInstrumentCid issuerPartyRef

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  let settlers = singleton custodian
  verifyNoLifecycleEffects [publicParty] (subtractDays firstRegularPeriodDate 1) swapInstrument settlers issuer [observableCid]

  -- First payment date: Lifecycle and verify the net fix vs floating payment (stub period).
  let
    expectedConsumedQuantities = [Instrument.qty 83.3333 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] firstRegularPeriodDate swapInstrument settlers issuer investor observers custodian [observableCid, observableOneMonthCid] expectedConsumedQuantities expectedProducedQuantities

  -- Second payment date: Lifecycle and verify the floating payment (regular period, 3M).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 3791.6667 cashInstrumentCid]
  swapInstrumentAfterSecondPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] secondRegularPeriodDate swapInstrumentAfterFirstPayment settlers issuer investor observers custodian [observableCid, observableOneMonthCid] expectedConsumedQuantities expectedProducedQuantities

  -- Third payment date: Lifecycle and verify the floating payment (regular period, 3M).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 3750.0 cashInstrumentCid]
  swapInstrumentAfterThirdPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] thirdRegularPeriodDate swapInstrumentAfterSecondPayment settlers issuer investor observers custodian [observableCid, observableOneMonthCid] expectedConsumedQuantities expectedProducedQuantities

  -- Fourth payment date: Lifecycle and verify the floating payment (regular period, 3M).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 3833.3333 cashInstrumentCid]
  swapInstrumentAfterFourthPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] lastRegularPeriodDate swapInstrumentAfterThirdPayment settlers issuer investor observers custodian [observableCid, observableOneMonthCid] expectedConsumedQuantities expectedProducedQuantities

  -- Final payment date: Lifecycle and verify the net fix vs floating payment (stub period).
  let
    expectedConsumedQuantities = [Instrument.qty 17324.3727 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFinalPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] maturityDate swapInstrumentAfterFourthPayment settlers issuer investor observers custodian [observableCid, observableOneMonthCid] expectedConsumedQuantities expectedProducedQuantities

  pure ()
