-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Swap.Test.Fpml where

import DA.Date
import DA.Map qualified as M (empty, fromList)
import DA.Set (singleton)
import Daml.Finance.Data.Observable.Observation (Observation(..))
import Daml.Finance.Data.Reference.HolidayCalendar
import Daml.Finance.Instrument.Generic.Util
import Daml.Finance.Instrument.Swap.Test.Util
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Types.Common (Id(..))
import Daml.Finance.Interface.Types.Date.Calendar
import Daml.Finance.Interface.Types.Date.DayCount
import Daml.Finance.Interface.Types.Date.RollConvention
import Daml.Finance.Interface.Types.Fpml
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (originate)
import Daml.Script

-- Calculate interest rate payment on an interest rate swap (represented using FpML swapStreams), including lifecycling and creation of new instrument version.
run : Script ()
run = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Fix vs floating interest rate swap: Libor 3M vs 2.01% p.a. payment every 3M
  let
    issueDate = date 2019 Jan 16
    firstPaymentDate = date 2019 Feb 15
    maturityDate = date 2019 May 15
    referenceRateId = "USD/LIBOR/3M"
    fixRate = 0.0201
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    observations = M.fromList [(dateToDateClockTime (date 2019 Jan 11), 0.0027406), (dateToDateClockTime (date 2019 Feb 13), 0.002035)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      receiverPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "floatingLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstPaymentDate
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        firstPaymentDate = Some firstPaymentDate
        lastRegularPaymentDate = None
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = Some ResetDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
        resetFrequency = ResetFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        resetDatesAdjustments = ResetDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          fxLinkedNotionalSchedule = None
          notionalSchedule = Some NotionalSchedule with
            id = "floatingLegNotionalSchedule"
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              step = []
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None

    swapStreamFixedLeg = SwapStream with
      payerPartyReference = clientPartyRef
      receiverPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "fixedLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstPaymentDate
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "fixedLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        firstPaymentDate = Some firstPaymentDate
        lastRegularPaymentDate = None
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = None
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          fxLinkedNotionalSchedule = None
          notionalSchedule = Some NotionalSchedule with
            id = "fixedLegNotionalSchedule"
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              step = []
              currency = "USD"
          floatingRateCalculation = None
          fixedRateSchedule = Some FixedRateSchedule with
            initialValue = fixRate
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]
    currencies = [cashInstrumentCid, cashInstrumentCid]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList observers
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList observers

  observableCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations; observers = M.empty

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" observers now swapStreams calendarDataProvider currencies issuerPartyRef

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  let settlers = singleton custodian
  verifyNoLifecycleEffects [publicParty] (subtractDays firstPaymentDate 1) swapInstrument settlers issuer [observableCid]

  -- First payment date: Lifecycle and verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 0.0014466167 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] firstPaymentDate swapInstrument settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  -- One day after the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (addDays firstPaymentDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- One day before expiry: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays maturityDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- Lifecycle on the second payment date, which is also the expiry date. Verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 0.0044660695 cashInstrumentCid]
    expectedProducedQuantities = []
  lifecycleAndVerifySwapPaymentEffects [publicParty] maturityDate swapInstrumentAfterFirstPayment settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test interpolation of two floating rates for a stub period, according to the calculation here:
-- https://www.isda.org/a/aWkgE/Linear-interpolation-04022022.pdf
runStubRateInterpolation : Script ()
runStubRateInterpolation = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create swap
  let
    issueDate = date 2022 Jan 10
    firstRegularPeriodDate = date 2022 Mar 20
    lastRegularPeriodDate = date 2022 Jun 20
    maturityDate = date 2022 Jun 20
    referenceRateId = "USD/LIBOR/3M"
    referenceRateOneMonthId = "USD/LIBOR/1M"
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Basis1 -- Use basis 1/1 in order to easily compare the interpolated rate calculation with the ISDA paper
    businessDayConvention = ModifiedFollowing
    observationsLibor3M = M.fromList [(dateToDateClockTime (date 2022 Jan 06), 0.0023129), (dateToDateClockTime (date 2022 Mar 17), 0.002035)]
    observationsLibor1M = M.fromList [(dateToDateClockTime (date 2022 Jan 06), 0.0010414), (dateToDateClockTime (date 2022 Mar 17), 0.002035)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      receiverPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "floatingLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 20
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        firstPaymentDate = Some firstRegularPeriodDate
        lastRegularPaymentDate = Some lastRegularPeriodDate
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = Some ResetDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
        resetFrequency = ResetFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        resetDatesAdjustments = ResetDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          fxLinkedNotionalSchedule = None
          notionalSchedule = Some NotionalSchedule with
            id = "floatingLegNotionalSchedule"
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              step = []
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = Some StubCalculationPeriodAmount with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        initialStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex=referenceRateOneMonthId;indexTenor=Some (Period with period=M;periodMultiplier=1)), (StubFloatingRate with floatingRateIndex=referenceRateId;indexTenor=Some (Period with period=M;periodMultiplier=3))]
        finalStub = None

    swapStreams = [swapStreamFloatingLeg]
    currencies = [cashInstrumentCid]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList observers
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList observers

  observableLibor3MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations=observationsLibor3M; observers = M.empty
  observableLibor1MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateOneMonthId; observations=observationsLibor1M; observers = M.empty
  let observableCids = [observableLibor3MCid, observableLibor1MCid]

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" observers now swapStreams calendarDataProvider currencies issuerPartyRef

  let settlers = singleton custodian

  -- First payment date (after weekend adjustment): Lifecycle stub period and verify the lifecycle effects for floating payment.
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 0.001867875 cashInstrumentCid]  -- interpolated stub rate from the ISDA paper
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (addDays firstRegularPeriodDate 1) swapInstrument settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test sample trade with two stub periods (intial and final) in the same trade.
runDualStubSampleTrade : Script ()
runDualStubSampleTrade = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Fix vs floating interest rate swap: Libor 3M vs 2.0% p.a.
  -- CREATE_FPML_SWAP_VARIABLES_BEGIN
  let
    issueDate = date 2022 Sep 14
    firstRegularPeriodDate = date 2022 Sep 20
    lastRegularPeriodDate = date 2023 Jun 20
    maturityDate = date 2023 Sep 14
    firstRegularPeriodDateFixLeg = date 2022 Sep 20
    lastRegularPeriodDateFixLeg = firstRegularPeriodDateFixLeg
    referenceRateId = "USD/LIBOR/3M"
    referenceRateOneMonthId = "USD/LIBOR/1M"
    fixRate = 0.02
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"
    -- CREATE_FPML_SWAP_VARIABLES_END
    secondRegularPeriodDate = date 2022 Dec 20
    thirdRegularPeriodDate = date 2023 Mar 20
    observationsLibor3M = M.fromList [(dateToDateClockTime (date 2022 Sep 16), 0.01), (dateToDateClockTime (date 2022 Dec 16), 0.01), (dateToDateClockTime (date 2023 Mar 16), 0.01), (dateToDateClockTime (date 2023 Jun 16), 0.01) ]
    observationsLibor1M = M.fromList [(dateToDateClockTime (date 2023 Jun 16), 0.02)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    -- CREATE_FPML_SWAP_FLOAT_LEG_BEGIN
    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      receiverPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "floatingLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 20
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        firstPaymentDate = Some firstRegularPeriodDate
        lastRegularPaymentDate = Some lastRegularPeriodDate
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = Some ResetDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
        resetFrequency = ResetFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        resetDatesAdjustments = ResetDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          fxLinkedNotionalSchedule = None
          notionalSchedule = Some NotionalSchedule with
            id = "floatingLegNotionalSchedule"
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1000000.0
              step = []
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.005
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = Some StubCalculationPeriodAmount with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        initialStub = Some StubValue with
          stubRate = Some 0.015
          floatingRate = None
        finalStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex=referenceRateOneMonthId;indexTenor=Some (Period with period=M;periodMultiplier=1)), (StubFloatingRate with floatingRateIndex=referenceRateId;indexTenor=Some (Period with period=M;periodMultiplier=3))]
    -- CREATE_FPML_SWAP_FLOAT_LEG_END

    -- CREATE_FPML_SWAP_FIX_LEG_BEGIN
    swapStreamFixedLeg = SwapStream with
      payerPartyReference = clientPartyRef
      receiverPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "fixedLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDateFixLeg
        lastRegularPeriodEndDate = Some lastRegularPeriodDateFixLeg
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = 1
          period = Y
          rollConvention = DOM 20
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "fixedLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = 1
          period = Y
        firstPaymentDate = Some firstRegularPeriodDateFixLeg
        lastRegularPaymentDate = Some lastRegularPeriodDateFixLeg
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = None
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          fxLinkedNotionalSchedule = None
          notionalSchedule = Some NotionalSchedule with
            id = "fixedLegNotionalSchedule"
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1000000.0
              step = []
              currency = "USD"
          floatingRateCalculation = None
          fixedRateSchedule = Some FixedRateSchedule with
            initialValue = fixRate
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None
    -- CREATE_FPML_SWAP_FIX_LEG_END

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]
    currencies = [cashInstrumentCid, cashInstrumentCid]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList observers
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList observers

  observableLibor3MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations=observationsLibor3M; observers = M.empty
  observableLibor1MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateOneMonthId; observations=observationsLibor1M; observers = M.empty
  let observableCids = [observableLibor3MCid, observableLibor1MCid]

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" observers now swapStreams calendarDataProvider currencies issuerPartyRef

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  let settlers = singleton custodian
  verifyNoLifecycleEffects [publicParty] (subtractDays firstRegularPeriodDate 1) swapInstrument settlers issuer observableCids

  -- First payment date: Lifecycle and verify the net fix vs floating payment (stub period).
  let
    expectedConsumedQuantities = [Instrument.qty 83.3333 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] firstRegularPeriodDate swapInstrument settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Second payment date: Lifecycle and verify the floating payment (regular period, 3M).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 3791.6667 cashInstrumentCid]
  swapInstrumentAfterSecondPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] secondRegularPeriodDate swapInstrumentAfterFirstPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Third payment date: Lifecycle and verify the floating payment (regular period, 3M).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 3750.0 cashInstrumentCid]
  swapInstrumentAfterThirdPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] thirdRegularPeriodDate swapInstrumentAfterSecondPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Fourth payment date: Lifecycle and verify the floating payment (regular period, 3M).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 3833.3333 cashInstrumentCid]
  swapInstrumentAfterFourthPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] lastRegularPeriodDate swapInstrumentAfterThirdPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Final payment date: Lifecycle and verify the net fix vs floating payment (stub period).
  let
    expectedConsumedQuantities = [Instrument.qty 17324.3727 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFinalPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] maturityDate swapInstrumentAfterFourthPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test sample trade with a payment frequency different from the calculation frequency.
runSeparatePaymentFrequencySampleTrade : Script ()
runSeparatePaymentFrequencySampleTrade = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Fix vs floating interest rate swap: Libor 6M vs 2.0% p.a.
  -- CREATE_FPML_SWAP_VARIABLES_BEGIN
  let
    issueDate = date 2022 Oct 17
    firstRegularPeriodDate = date 2022 Oct 26
    maturityDate = date 2027 Oct 26
    referenceRateId = "USD/LIBOR/6M"
    referenceRate1MId = "USD/LIBOR/1M"
    referenceRate1DId = "USD/LIBOR/1D"
    fixRate = 0.02
    dayCountConventionFixLeg = Basis30360
    dayCountConventionFloatingLeg = Act360
    businessDayConvention = ModifiedFollowing
    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"
    -- CREATE_FPML_SWAP_VARIABLES_END
    observationsLibor6M = M.fromList [(dateToDateClockTime (date 2022 Oct 24), 0.01), (dateToDateClockTime (date 2023 Apr 24), 0.01), (dateToDateClockTime (date 2023 Oct 24), 0.01)]
    observationsLibor1M = M.fromList [(dateToDateClockTime (date 2022 Oct 13), 0.02)]
    observationsLibor1D = M.fromList [(dateToDateClockTime (date 2022 Oct 13), 0.03)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    -- CREATE_FPML_SWAP_FLOAT_LEG_BEGIN
    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      receiverPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "floatingLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = 6
          period = M
          rollConvention = DOM 26
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = 1
          period = Y
        firstPaymentDate = Some firstRegularPeriodDate
        lastRegularPaymentDate = None
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = Some ResetDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
        resetFrequency = ResetFrequency with
          periodMultiplier = 6
          period = M
        resetDatesAdjustments = ResetDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          fxLinkedNotionalSchedule = None
          notionalSchedule = Some NotionalSchedule with
            id = "floatingLegNotionalSchedule"
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 5000000.0
              step = []
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = 6
              period = M
            spreadSchedule = SpreadSchedule with
              initialValue = 0.0025
          fixedRateSchedule = None
          dayCountFraction = dayCountConventionFloatingLeg
      stubCalculationPeriodAmount = Some StubCalculationPeriodAmount with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        initialStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex = referenceRate1MId; indexTenor = Some (Period with period = M; periodMultiplier = 1)), (StubFloatingRate with floatingRateIndex = referenceRate1DId; indexTenor = Some (Period with period = D; periodMultiplier = 1))]
        finalStub = None
    -- CREATE_FPML_SWAP_FLOAT_LEG_END

    -- CREATE_FPML_SWAP_FIX_LEG_BEGIN
    swapStreamFixedLeg = SwapStream with
      payerPartyReference = clientPartyRef
      receiverPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "fixedLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = 3
          period = M
          rollConvention = DOM 26
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "fixedLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = 3
          period = M
        firstPaymentDate = Some firstRegularPeriodDate
        lastRegularPaymentDate = None
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = None
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          fxLinkedNotionalSchedule = None
          notionalSchedule = Some NotionalSchedule with
            id = "fixedLegNotionalSchedule"
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 5000000.0
              step = []
              currency = "USD"
          floatingRateCalculation = None
          fixedRateSchedule = Some FixedRateSchedule with
            initialValue = fixRate
          dayCountFraction = dayCountConventionFixLeg
      stubCalculationPeriodAmount = None
    -- CREATE_FPML_SWAP_FIX_LEG_END

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]
    currencies = [cashInstrumentCid, cashInstrumentCid]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList observers
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList observers

  observableLibor6MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations=observationsLibor6M; observers = M.empty
  observableLibor1MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRate1MId; observations=observationsLibor1M; observers = M.empty
  observableLibor1DCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRate1DId; observations=observationsLibor1D; observers = M.empty
  let observableCids = [observableLibor6MCid, observableLibor1MCid, observableLibor1DCid]

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" observers now swapStreams calendarDataProvider currencies issuerPartyRef

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  let settlers = singleton custodian
  verifyNoLifecycleEffects [publicParty] (subtractDays firstRegularPeriodDate 1) swapInstrument settlers issuer observableCids

  -- First payment date: Lifecycle and verify the net fix vs floating payment (stub period).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 916.6665 cashInstrumentCid]
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] firstRegularPeriodDate swapInstrument settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Lifecycle and verify the fix payment (regular period, 3M).
  let
    expectedConsumedQuantities = [Instrument.qty 25000.0 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterSecondPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (date 2023 Jan 26) swapInstrumentAfterFirstPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Lifecycle and verify the fix (regular period, 3M). The 6M float payment is calculated but only paid every 12M.
  let
    expectedConsumedQuantities = [Instrument.qty 25000.0 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterThirdPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (date 2023 Apr 26) swapInstrumentAfterSecondPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Lifecycle and verify the fix payment (regular period, 3M).
  let
    expectedConsumedQuantities = [Instrument.qty 25000.0 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFourthPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (date 2023 Jul 26) swapInstrumentAfterThirdPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Lifecycle and verify the fix payment (regular period, 3M) + floating payment (regular period, 12M).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 38368.0555 cashInstrumentCid]
  lifecycleAndVerifySwapPaymentEffects [publicParty] (date 2023 Oct 26) swapInstrumentAfterFourthPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test sample trade with different currencies and exchange of principal.
runCurrencySwapSampleTrade : Script ()
runCurrencySwapSampleTrade = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentEurCid <- Instrument.originate custodian issuer "EUR" "Euro" observers now
  cashInstrumentUsdCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Float vs float currency swap: Euribor 3M vs Libor 3M
  -- CREATE_FPML_SWAP_VARIABLES_BEGIN
  let
    issueDate = date 2022 Oct 17
    maturityDate = date 2027 Oct 17
    referenceRateUsdId = "USD/LIBOR/3M"
    referenceRateEurId = "EUR/EURIBOR/3M"
    referenceRateFxId = "WMRPSPOT01"
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"
    -- CREATE_FPML_SWAP_VARIABLES_END
    observationsLibor3M = M.fromList [(dateToDateClockTime (date 2022 Oct 13), 0.02), (dateToDateClockTime (date 2023 Jan 13), 0.02), (dateToDateClockTime (date 2023 Apr 13), 0.02), (dateToDateClockTime (date 2023 Jul 13), 0.02)]
    observationsEuribor3M = M.fromList [(dateToDateClockTime (date 2022 Oct 13), 0.01), (dateToDateClockTime (date 2023 Jan 13), 0.01), (dateToDateClockTime (date 2023 Apr 13), 0.01), (dateToDateClockTime (date 2023 Jul 13), 0.01)]
    observationsFx = M.fromList [(dateToDateClockTime (date 2022 Oct 13), 1.02), (dateToDateClockTime (date 2023 Jan 13), 1.02), (dateToDateClockTime (date 2023 Apr 13), 1.02), (dateToDateClockTime (date 2023 Jul 13), 1.02), (dateToDateClockTime (date 2023 Oct 13), 1.02)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    -- CREATE_FPML_SWAP_FLOAT_LEG_BEGIN
    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = clientPartyRef
      receiverPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "eurLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = None
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 17
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "eurLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        firstPaymentDate = None
        lastRegularPaymentDate = None
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = Some ResetDates with
        calculationPeriodDatesReference = "eurLegCalcPeriodDates"
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
        resetFrequency = ResetFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        resetDatesAdjustments = ResetDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with -- todo: adapt for EUR
        calculation = Calculation with
          fxLinkedNotionalSchedule = None
{-
          fxLinkedNotionalSchedule = Some FxLinkedNotionalSchedule with -- todo: verify fxLinkedNotionalSchedule does not exist
            constantNotionalScheduleReference = "usdScheduleConstant"
            initialValue = 5100000.0
            varyingNotionalCurrency = "USD"
            varyingNotionalFixingDates = FixingDates with
              periodMultiplier = -2
              period = D
              dayType = Business
              businessDayConvention = NoAdjustment
              businessCenters = fixingHolidayCalendarId
            fxSpotRateSource = FxSpotRateSource with
              primaryRateSource = InformationSource with
                rateSource = "Reuters"
                rateSourcePage = "WMRPSPOT01"
              fixingTime = Some BusinessCenterTime with
                hourMinuteTime = "11:00:00"
                businessCenter = "LIB"
                 -}
          notionalSchedule = Some NotionalSchedule with
            id = "notionalScheduleConstant"
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 5000000.0
              step = []
              currency = "EUR"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateEurId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with -- make optional?
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None
    -- CREATE_FPML_SWAP_FLOAT_LEG_END

    -- CREATE_FPML_SWAP_FIX_LEG_BEGIN
    swapStreamFixedLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      receiverPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "usdLeg2CalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = None
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 17
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "usdLeg2CalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        firstPaymentDate = None
        lastRegularPaymentDate = None
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = Some ResetDates with
        calculationPeriodDatesReference = "usdLeg2CalcPeriodDates"
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
        resetFrequency = ResetFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        resetDatesAdjustments = ResetDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with -- todo: adapt for USD
        calculation = Calculation with
          fxLinkedNotionalSchedule = Some FxLinkedNotionalSchedule with
            constantNotionalScheduleReference = "notionalScheduleConstant"
            initialValue = 5100000.0
            varyingNotionalCurrency = "USD"
            varyingNotionalFixingDates = FixingDates with
              periodMultiplier = -2
              period = D
              dayType = Business
              businessDayConvention = NoAdjustment
              businessCenters = fixingHolidayCalendarId
            fxSpotRateSource = FxSpotRateSource with
              primaryRateSource = InformationSource with
                rateSource = "Reuters"
                rateSourcePage = referenceRateFxId
              fixingTime = Some BusinessCenterTime with
                hourMinuteTime = "11:00:00"
                businessCenter = "LIB"
          notionalSchedule = Some NotionalSchedule with -- todo: verify that either notionalSchedule or fxLinkedNotionalSchedule exist but not both
            id = "usdLegNotionalSchedule"
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 5100000.0
              step = []
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateUsdId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with -- make optional?
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None
    -- CREATE_FPML_SWAP_FIX_LEG_END

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]
    currencies = [cashInstrumentEurCid, cashInstrumentUsdCid]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList observers
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList observers

  observableLibor3MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateUsdId; observations=observationsLibor3M; observers = M.empty
  observableEuribor3MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateEurId; observations=observationsEuribor3M; observers = M.empty
  observableFxCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateFxId; observations=observationsFx; observers = M.empty
  let observableCids = [observableLibor3MCid, observableEuribor3MCid, observableFxCid]

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" observers now swapStreams calendarDataProvider currencies issuerPartyRef
  let settlers = singleton custodian

  -- Lifecycle and verify Euribor vs Libor payment.
  let
    expectedConsumedQuantities = [Instrument.qty 12777.778 cashInstrumentEurCid]
    expectedProducedQuantities = [Instrument.qty 26066.66661 cashInstrumentUsdCid]
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (date 2023 Jan 17) swapInstrument settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Lifecycle and verify Euribor vs Libor payment.
  let
    expectedConsumedQuantities = [Instrument.qty 12500.0 cashInstrumentEurCid]
    expectedProducedQuantities = [Instrument.qty 25500.0 cashInstrumentUsdCid]
  swapInstrumentAfterSecondPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (date 2023 Apr 17) swapInstrumentAfterFirstPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Lifecycle and verify Euribor vs Libor payment.
  let
    expectedConsumedQuantities = [Instrument.qty 12638.889 cashInstrumentEurCid]
    expectedProducedQuantities = [Instrument.qty 25783.33356 cashInstrumentUsdCid]
  swapInstrumentAfterThirdPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (date 2023 Jul 17) swapInstrumentAfterSecondPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test sample trade with amortizing notional.
runAmortizingNotionalSampleTrade : Script ()
runAmortizingNotionalSampleTrade = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Fix vs floating interest rate swap with amortizing notional: Libor 3M vs 2.0% p.a.
  -- CREATE_FPML_SWAP_VARIABLES_BEGIN
  let
    issueDate = date 2022 Oct 17
    firstRegularPeriodDate = date 2022 Oct 20
    lastRegularPeriodDate = date 2027 Oct 20
    maturityDate = date 2027 Oct 27
    firstRegularPeriodDateFixLeg = date 2022 Oct 20
    lastRegularPeriodDateFixLeg = date 2027 Oct 20
    referenceRateId = "USD/LIBOR/3M"
    referenceRate1MId = "USD/LIBOR/1M"
    referenceRate1DId = "USD/LIBOR/1D"
    fixRate = 0.02
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"
    -- CREATE_FPML_SWAP_VARIABLES_END
    secondRegularPeriodDate = date 2022 Oct 20
    thirdRegularPeriodDate = date 2027 Oct 20
    observationsLibor3M = M.fromList [(dateToDateClockTime (date 2022 Oct 18), 0.01), (dateToDateClockTime (date 2023 Jan 18), 0.01), (dateToDateClockTime (date 2023 Apr 18), 0.01), (dateToDateClockTime (date 2023 Jul 18), 0.01), (dateToDateClockTime (date 2023 Oct 18), 0.01) ]
    observationsLibor1M = M.fromList [(dateToDateClockTime (date 2022 Oct 13), 0.02)]
    observationsLibor1D = M.fromList [(dateToDateClockTime (date 2022 Oct 13), 0.03)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    swapStreamFixedLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      receiverPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "fixedLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDateFixLeg
        lastRegularPeriodEndDate = Some lastRegularPeriodDateFixLeg
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = 6
          period = M
          rollConvention = DOM 20
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "fixedLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = 6
          period = M
        firstPaymentDate = Some firstRegularPeriodDateFixLeg
        lastRegularPaymentDate = Some lastRegularPeriodDateFixLeg
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = None
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          fxLinkedNotionalSchedule = None
          notionalSchedule = Some NotionalSchedule with
            id = "fixedLegNotionalSchedule"
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 5000000.0
              step = [
                (Step with stepDate = date 2022 Oct 17; stepValue = 5000000.0),
                (Step with stepDate = date 2022 Oct 20; stepValue = 4500000.0),
                (Step with stepDate = date 2023 Apr 20; stepValue = 4000000.0),
                (Step with stepDate = date 2023 Oct 20; stepValue = 3500000.0),
                (Step with stepDate = date 2024 Apr 20; stepValue = 3000000.0),
                (Step with stepDate = date 2024 Oct 20; stepValue = 2500000.0),
                (Step with stepDate = date 2025 Apr 20; stepValue = 2000000.0),
                (Step with stepDate = date 2025 Oct 20; stepValue = 1500000.0),
                (Step with stepDate = date 2026 Apr 20; stepValue = 1000000.0),
                (Step with stepDate = date 2026 Oct 20; stepValue = 1000000.0),
                (Step with stepDate = date 2027 Apr 20; stepValue = 1000000.0),
                (Step with stepDate = date 2027 Oct 20; stepValue = 1000000.0)
                ]
              currency = "USD"
          floatingRateCalculation = None
          fixedRateSchedule = Some FixedRateSchedule with
            initialValue = fixRate
          dayCountFraction = Basis30360
      stubCalculationPeriodAmount = None

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = clientPartyRef
      receiverPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "floatingLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 20
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        firstPaymentDate = Some firstRegularPeriodDate
        lastRegularPaymentDate = Some lastRegularPeriodDate
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = Some ResetDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
        resetFrequency = ResetFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        resetDatesAdjustments = ResetDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          fxLinkedNotionalSchedule = None
          notionalSchedule = Some NotionalSchedule with
            id = "floatingLegNotionalSchedule"
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 5000000.0
              step = [
                (Step with stepDate = date 2022 Oct 17; stepValue = 5000000.0),
                (Step with stepDate = date 2022 Oct 20; stepValue = 4500000.0),
                (Step with stepDate = date 2023 Jan 20; stepValue = 4500000.0),
                (Step with stepDate = date 2023 Apr 20; stepValue = 4000000.0),
                (Step with stepDate = date 2023 Jul 20; stepValue = 4000000.0),
                (Step with stepDate = date 2023 Oct 20; stepValue = 3500000.0),
                (Step with stepDate = date 2024 Jan 20; stepValue = 3500000.0),
                (Step with stepDate = date 2024 Apr 20; stepValue = 3000000.0),
                (Step with stepDate = date 2024 Jul 20; stepValue = 3000000.0),
                (Step with stepDate = date 2024 Oct 20; stepValue = 2500000.0),
                (Step with stepDate = date 2025 Jan 20; stepValue = 2500000.0),
                (Step with stepDate = date 2025 Apr 20; stepValue = 2000000.0),
                (Step with stepDate = date 2025 Jul 20; stepValue = 2000000.0),
                (Step with stepDate = date 2025 Oct 20; stepValue = 1500000.0),
                (Step with stepDate = date 2026 Jan 20; stepValue = 1500000.0),
                (Step with stepDate = date 2026 Apr 20; stepValue = 1000000.0),
                (Step with stepDate = date 2026 Jul 20; stepValue = 1000000.0),
                (Step with stepDate = date 2026 Oct 20; stepValue = 1000000.0),
                (Step with stepDate = date 2027 Jan 20; stepValue = 1000000.0),
                (Step with stepDate = date 2027 Apr 20; stepValue = 1000000.0),
                (Step with stepDate = date 2027 Jul 20; stepValue = 1000000.0),
                (Step with stepDate = date 2027 Oct 20; stepValue = 1000000.0)
                ]
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with -- make optional?
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = Some StubCalculationPeriodAmount with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        initialStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex = referenceRate1MId; indexTenor = Some (Period with period = M; periodMultiplier = 1)), (StubFloatingRate with floatingRateIndex = referenceRate1DId; indexTenor = Some (Period with period = D; periodMultiplier = 1))]
        finalStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex = referenceRate1MId; indexTenor = Some (Period with period = M; periodMultiplier = 1)), (StubFloatingRate with floatingRateIndex = referenceRate1DId; indexTenor = Some (Period with period = D; periodMultiplier = 1))]

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]
    currencies = [cashInstrumentCid, cashInstrumentCid]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList observers
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList observers

  observableLibor3MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations=observationsLibor3M; observers = M.empty
  observableLibor1MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRate1MId; observations=observationsLibor1M; observers = M.empty
  observableLibor1DCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRate1DId; observations=observationsLibor1D; observers = M.empty
  let observableCids = [observableLibor3MCid, observableLibor1MCid, observableLibor1DCid]

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" observers now swapStreams calendarDataProvider currencies issuerPartyRef
  let settlers = singleton custodian

  -- First payment date: Lifecycle and verify the net fix vs floating payment (stub period).
  let
    expectedConsumedQuantities = [Instrument.qty 388.8885 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (date 2022 Oct 20) swapInstrument settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Second payment date: Lifecycle and verify the floating payment (regular period, 3M).
  let
    expectedConsumedQuantities = [Instrument.qty 12777.778 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterSecondPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (date 2023 Jan 20) swapInstrumentAfterFirstPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Third payment date: Lifecycle and verify the fix vs floating payment (regular period, 3M float vs 6M fix).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 37500.0 cashInstrumentCid]
  swapInstrumentAfterThirdPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (date 2023 Apr 20) swapInstrumentAfterSecondPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  pure ()
