-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Swap.Test.Fpml where

import DA.Date
import DA.Map qualified as M (empty, fromList)
import DA.Set (singleton)
import Daml.Finance.Data.Observable.Observation (Observation(..))
import Daml.Finance.Data.Reference.HolidayCalendar
import Daml.Finance.Instrument.Generic.Util
import Daml.Finance.Instrument.Swap.Test.Util
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Types.Common (Id(..))
import Daml.Finance.Interface.Types.Date.Calendar
import Daml.Finance.Interface.Types.Date.DayCount
import Daml.Finance.Interface.Types.Date.RollConvention
import Daml.Finance.Interface.Types.Fpml
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (originate)
import Daml.Script

-- Calculate interest rate payment on an interest rate swap (represented using FpML swapStreams), including lifecycling and creation of new instrument version.
run : Script ()
run = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Fix vs floating interest rate swap: Libor 3M vs 2.01% p.a. payment every 3M
  let
    issueDate = date 2019 Jan 16
    firstPaymentDate = date 2019 Feb 15
    maturityDate = date 2019 May 15
    referenceRateId = "USD/LIBOR/3M"
    fixRate = 0.0201
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    observations = M.fromList [(dateToDateClockTime (date 2019 Jan 11), 0.0027406), (dateToDateClockTime (date 2019 Feb 13), 0.002035)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      receiverPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "floatingLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstPaymentDate
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        firstPaymentDate = Some firstPaymentDate
        lastRegularPaymentDate = None
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = Some ResetDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
        resetFrequency = ResetFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        resetDatesAdjustments = ResetDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None

    swapStreamFixedLeg = SwapStream with
      payerPartyReference = clientPartyRef
      receiverPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "fixedLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstPaymentDate
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "fixedLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        firstPaymentDate = Some firstPaymentDate
        lastRegularPaymentDate = None
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = None
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              currency = "USD"
          floatingRateCalculation = None
          fixedRateSchedule = Some FixedRateSchedule with
            initialValue = fixRate
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList observers
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList observers

  observableCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations; observers = M.empty

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" observers now swapStreams calendarDataProvider cashInstrumentCid issuerPartyRef

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  let settlers = singleton custodian
  verifyNoLifecycleEffects [publicParty] (subtractDays firstPaymentDate 1) swapInstrument settlers issuer [observableCid]

  -- First payment date: Lifecycle and verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 0.0014466167 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] firstPaymentDate swapInstrument settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  -- One day after the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (addDays firstPaymentDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- One day before expiry: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays maturityDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- Lifecycle on the second payment date, which is also the expiry date. Verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 0.0044660695 cashInstrumentCid]
    expectedProducedQuantities = []
  lifecycleAndVerifySwapPaymentEffects [publicParty] maturityDate swapInstrumentAfterFirstPayment settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test interpolation of two floating rates for a stub period, according to the calculation here:
-- https://www.isda.org/a/aWkgE/Linear-interpolation-04022022.pdf
runStubRateInterpolation : Script ()
runStubRateInterpolation = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create swap
  let
    issueDate = date 2022 Jan 10
    firstRegularPeriodDate = date 2022 Mar 20
    lastRegularPeriodDate = date 2022 Jun 20
    maturityDate = date 2022 Jun 20
    referenceRateId = "USD/LIBOR/3M"
    referenceRateOneMonthId = "USD/LIBOR/1M"
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Basis1 -- Use basis 1/1 in order to easily compare the interpolated rate calculation with the ISDA paper
    businessDayConvention = ModifiedFollowing
    observationsLibor3M = M.fromList [(dateToDateClockTime (date 2022 Jan 06), 0.0023129), (dateToDateClockTime (date 2022 Mar 17), 0.002035)]
    observationsLibor1M = M.fromList [(dateToDateClockTime (date 2022 Jan 06), 0.0010414), (dateToDateClockTime (date 2022 Mar 17), 0.002035)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      receiverPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "floatingLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 20
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        firstPaymentDate = Some firstRegularPeriodDate
        lastRegularPaymentDate = Some lastRegularPeriodDate
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = Some ResetDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
        resetFrequency = ResetFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        resetDatesAdjustments = ResetDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = Some StubCalculationPeriodAmount with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        initialStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex=referenceRateOneMonthId;indexTenor=Some (Period with period=M;periodMultiplier=1)), (StubFloatingRate with floatingRateIndex=referenceRateId;indexTenor=Some (Period with period=M;periodMultiplier=3))]
        finalStub = None

    swapStreams = [swapStreamFloatingLeg]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList observers
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList observers

  observableLibor3MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations=observationsLibor3M; observers = M.empty
  observableLibor1MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateOneMonthId; observations=observationsLibor1M; observers = M.empty
  let observableCids = [observableLibor3MCid, observableLibor1MCid]

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" observers now swapStreams calendarDataProvider cashInstrumentCid issuerPartyRef

  let settlers = singleton custodian

  -- First payment date (after weekend adjustment): Lifecycle stub period and verify the lifecycle effects for floating payment.
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 0.001867875 cashInstrumentCid]  -- interpolated stub rate from the ISDA paper
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (addDays firstRegularPeriodDate 1) swapInstrument settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test sample trade with two stub periods (intial and final) in the same trade.
runDualStubSampleTrade : Script ()
runDualStubSampleTrade = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Fix vs floating interest rate swap: Libor 3M vs 2.0% p.a.
  -- CREATE_FPML_SWAP_VARIABLES_BEGIN
  let
    issueDate = date 2022 Sep 14
    firstRegularPeriodDate = date 2022 Sep 20
    lastRegularPeriodDate = date 2023 Jun 20
    maturityDate = date 2023 Sep 14
    firstRegularPeriodDateFixLeg = date 2022 Sep 20
    lastRegularPeriodDateFixLeg = firstRegularPeriodDateFixLeg
    referenceRateId = "USD/LIBOR/3M"
    referenceRateOneMonthId = "USD/LIBOR/1M"
    fixRate = 0.02
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"
    -- CREATE_FPML_SWAP_VARIABLES_END
    secondRegularPeriodDate = date 2022 Dec 20
    thirdRegularPeriodDate = date 2023 Mar 20
    observationsLibor3M = M.fromList [(dateToDateClockTime (date 2022 Sep 16), 0.01), (dateToDateClockTime (date 2022 Dec 16), 0.01), (dateToDateClockTime (date 2023 Mar 16), 0.01), (dateToDateClockTime (date 2023 Jun 16), 0.01) ]
    observationsLibor1M = M.fromList [(dateToDateClockTime (date 2023 Jun 16), 0.02)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    -- CREATE_FPML_SWAP_FLOAT_LEG_BEGIN
    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      receiverPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "floatingLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 20
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        firstPaymentDate = Some firstRegularPeriodDate
        lastRegularPaymentDate = Some lastRegularPeriodDate
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = Some ResetDates with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
        resetFrequency = ResetFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
        resetDatesAdjustments = ResetDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1000000.0
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.005
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = Some StubCalculationPeriodAmount with
        calculationPeriodDatesReference = "floatingLegCalcPeriodDates"
        initialStub = Some StubValue with
          stubRate = Some 0.015
          floatingRate = None
        finalStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex=referenceRateOneMonthId;indexTenor=Some (Period with period=M;periodMultiplier=1)), (StubFloatingRate with floatingRateIndex=referenceRateId;indexTenor=Some (Period with period=M;periodMultiplier=3))]
    -- CREATE_FPML_SWAP_FLOAT_LEG_END

    -- CREATE_FPML_SWAP_FIX_LEG_BEGIN
    swapStreamFixedLeg = SwapStream with
      payerPartyReference = clientPartyRef
      receiverPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        id = "fixedLegCalcPeriodDates"
        effectiveDate = AdjustableDate with
          unadjustedDate = issueDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = NoAdjustment
            businessCenters = None
        terminationDate = AdjustableDate with
          unadjustedDate = maturityDate
          dateAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDateFixLeg
        lastRegularPeriodEndDate = Some lastRegularPeriodDateFixLeg
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = 1
          period = Y
          rollConvention = DOM 20
      paymentDates = PaymentDates with
        calculationPeriodDatesReference = "fixedLegCalcPeriodDates"
        paymentFrequency = PaymentFrequency with
          periodMultiplier = 1
          period = Y
        firstPaymentDate = Some firstRegularPeriodDateFixLeg
        lastRegularPaymentDate = Some lastRegularPeriodDateFixLeg
        payRelativeTo = CalculationPeriodEndDate
        paymentDatesAdjustments = BusinessDayAdjustments with
            businessDayConvention = ModifiedFollowing
            businessCenters = Some holidayCalendarId
      resetDates = None
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1000000.0
              currency = "USD"
          floatingRateCalculation = None
          fixedRateSchedule = Some FixedRateSchedule with
            initialValue = fixRate
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None
    -- CREATE_FPML_SWAP_FIX_LEG_END

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList observers
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList observers

  observableLibor3MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations=observationsLibor3M; observers = M.empty
  observableLibor1MCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateOneMonthId; observations=observationsLibor1M; observers = M.empty
  let observableCids = [observableLibor3MCid, observableLibor1MCid]

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" observers now swapStreams calendarDataProvider cashInstrumentCid issuerPartyRef

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  let settlers = singleton custodian
  verifyNoLifecycleEffects [publicParty] (subtractDays firstRegularPeriodDate 1) swapInstrument settlers issuer observableCids

  -- First payment date: Lifecycle and verify the net fix vs floating payment (stub period).
  let
    expectedConsumedQuantities = [Instrument.qty 83.3333 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] firstRegularPeriodDate swapInstrument settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Second payment date: Lifecycle and verify the floating payment (regular period, 3M).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 3791.6667 cashInstrumentCid]
  swapInstrumentAfterSecondPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] secondRegularPeriodDate swapInstrumentAfterFirstPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Third payment date: Lifecycle and verify the floating payment (regular period, 3M).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 3750.0 cashInstrumentCid]
  swapInstrumentAfterThirdPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] thirdRegularPeriodDate swapInstrumentAfterSecondPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Fourth payment date: Lifecycle and verify the floating payment (regular period, 3M).
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 3833.3333 cashInstrumentCid]
  swapInstrumentAfterFourthPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] lastRegularPeriodDate swapInstrumentAfterThirdPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  -- Final payment date: Lifecycle and verify the net fix vs floating payment (stub period).
  let
    expectedConsumedQuantities = [Instrument.qty 17324.3727 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFinalPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] maturityDate swapInstrumentAfterFourthPayment settlers issuer investor observers custodian observableCids expectedConsumedQuantities expectedProducedQuantities

  pure ()
