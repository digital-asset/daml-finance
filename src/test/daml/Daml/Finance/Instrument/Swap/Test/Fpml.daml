-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Swap.Test.Fpml where

import DA.Date
import DA.Map qualified as M (empty, fromList)
import DA.Set (singleton)
import Daml.Finance.Data.Observable.Observation (Observation(..))
import Daml.Finance.Data.Reference.HolidayCalendar
import Daml.Finance.Instrument.Generic.Util
import Daml.Finance.Instrument.Swap.Test.Util
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Types.Common (Id(..))
import Daml.Finance.Interface.Types.Date.Calendar
import Daml.Finance.Interface.Types.Date.DayCount
import Daml.Finance.Interface.Types.Date.RollConvention
import Daml.Finance.Interface.Types.Fpml
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (originate)
import Daml.Script

-- Calculate interest rate payment on an interest rate swap (represented using FpML swapStreams), including lifecycling and creation of new instrument version.
run : Script ()
run = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Fix vs floating interest rate swap: Libor 3M vs 2.01% p.a. payment every 3M
  -- CREATE_INTEREST_RATE_SWAP_VARIABLES_BEGIN
  let
    issueDate = date 2019 Jan 16
    firstPaymentDate = date 2019 Feb 15
    maturityDate = date 2019 May 15
    referenceRateId = "USD/LIBOR/3M"
    issuerPaysFix = False
    fixRate = 0.0201
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    -- CREATE_INTEREST_RATE_SWAP_VARIABLES_END
    observations = M.fromList [(dateToDateClockTime (date 2019 Jan 11), 0.0027406), (dateToDateClockTime (date 2019 Feb 13), 0.002035)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        -- id = "floatingLegCalcPeriodDates"
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstPaymentDate
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      resetDates = Some ResetDates with
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None

    swapStreamFixedLeg = SwapStream with
      payerPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        -- id = "fixedLegCalcPeriodDates"
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstPaymentDate
        lastRegularPeriodEndDate = None
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      resetDates = None
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              currency = "USD"
          floatingRateCalculation = None
          fixedRateSchedule = Some FixedRateSchedule with
            initialValue = fixRate
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList observers
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList observers

  observableCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations; observers = M.empty

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" observers now swapStreams calendarDataProvider cashInstrumentCid issuerPartyRef

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  let settlers = singleton custodian
  verifyNoLifecycleEffects [publicParty] (subtractDays firstPaymentDate 1) swapInstrument settlers issuer [observableCid]

  -- First payment date: Lifecycle and verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 0.0014466167 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] firstPaymentDate swapInstrument settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  -- One day after the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (addDays firstPaymentDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- One day before expiry: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays maturityDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- Lifecycle on the second payment date, which is also the expiry date. Verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 0.0044660695 cashInstrumentCid]
    expectedProducedQuantities = []
  lifecycleAndVerifySwapPaymentEffects [publicParty] maturityDate swapInstrumentAfterFirstPayment settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test two stub periods (intial and final) in the same trade.
runDualStub : Script ()
runDualStub = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Account and holding factory
  let fp = [("FactoryProvider", singleton publicParty)]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create and distribute swap
  -- Fix vs floating interest rate swap: Libor 3M vs 2.01% p.a. payment every 3M
  let
    issueDate = date 2019 Jan 16
    firstRegularPeriodDate = date 2019 Feb 15
    lastRegularPeriodDate = date 2019 May 15
    maturityDate = date 2019 Jul 15
    referenceRateId = "USD/LIBOR/3M"
    issuerPaysFix = False
    fixRate = 0.0201
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Act360
    businessDayConvention = ModifiedFollowing
    observations = M.fromList [(dateToDateClockTime (date 2019 Jan 11), 0.0027406), (dateToDateClockTime (date 2019 Feb 13), 0.002035), (dateToDateClockTime (date 2019 May 13), 0.0027406)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      resetDates = Some ResetDates with
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1000000.0
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = Some StubCalculationPeriodAmount with
        initialStub = Some StubValue with
          stubRate = Some 0.0027406
          floatingRate = None
        finalStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex=referenceRateId;indexTenor=Some (Period with period=M;periodMultiplier=3)), (StubFloatingRate with floatingRateIndex=referenceRateId;indexTenor=Some (Period with period=M;periodMultiplier=1))]

    swapStreamFixedLeg = SwapStream with
      payerPartyReference = clientPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 15
      resetDates = None
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1000000.0
              currency = "USD"
          floatingRateCalculation = None
          fixedRateSchedule = Some FixedRateSchedule with
            initialValue = fixRate
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = None

    swapStreams = [swapStreamFloatingLeg, swapStreamFixedLeg]

  debug swapStreamFloatingLeg

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList fp
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList fp

  observableCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations; observers = M.empty

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" fp now swapStreams calendarDataProvider cashInstrumentCid issuerPartyRef

  -- One day before the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  let settlers = singleton custodian
  verifyNoLifecycleEffects [publicParty] (subtractDays firstRegularPeriodDate 1) swapInstrument settlers issuer [observableCid]

  -- First payment date: Lifecycle and verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 1446.6167 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] firstRegularPeriodDate swapInstrument settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  -- One day after the first payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (addDays firstRegularPeriodDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- One day before the second payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays lastRegularPeriodDate 1) swapInstrumentAfterFirstPayment settlers issuer [observableCid]

  -- Second payment date: Lifecycle and verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 4466.0695 cashInstrumentCid]
    expectedProducedQuantities = []
  swapInstrumentAfterSecondPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] lastRegularPeriodDate swapInstrumentAfterFirstPayment settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  -- One day after the second payment date: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (addDays lastRegularPeriodDate 1) swapInstrumentAfterSecondPayment settlers issuer [observableCid]

  -- One day before expiry: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays maturityDate 1) swapInstrumentAfterSecondPayment settlers issuer [observableCid]

  -- Lifecycle on the second payment date, which is also the expiry date. Verify the lifecycle effects for fix and floating payments.
  let
    expectedConsumedQuantities = [Instrument.qty 2941.4539 cashInstrumentCid]
    expectedProducedQuantities = []
  lifecycleAndVerifySwapPaymentEffects [publicParty] maturityDate swapInstrumentAfterSecondPayment settlers issuer investor observers custodian [observableCid] expectedConsumedQuantities expectedProducedQuantities

  pure ()

-- Test interpolation of two floating rates for a stub period, according to the calculation here:
-- https://www.isda.org/a/aWkgE/Linear-interpolation-04022022.pdf
runStubRateInterpolation : Script ()
runStubRateInterpolation = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider", "PublicParty"]

  -- Account and holding factory
  let fp = [("FactoryProvider", singleton publicParty)]

  -- Distribute commercial-bank cash
  now <- getTime
  let observers = [("PublicParty", singleton publicParty)]
  cashInstrumentCid <- Instrument.originate custodian issuer "USD" "US Dollars" observers now

  -- Create swap
  let
    issueDate = date 2022 Jan 10
    firstRegularPeriodDate = date 2022 Mar 20
    lastRegularPeriodDate = date 2022 Jun 20
    maturityDate = date 2022 Jun 20
    referenceRateId = "USD/LIBOR/3M"
    referenceRateOneMonthId = "USD/LIBOR/1M"
    issuerPaysFix = False
    paymentPeriod = M
    paymentPeriodMultiplier = 3
    dayCountConvention = Basis1 -- Use basis 1/1 in order to easily compare the interpolated rate calculation with the ISDA paper
    businessDayConvention = ModifiedFollowing
    observations = M.fromList [(dateToDateClockTime (date 2022 Jan 06), 0.0023129), (dateToDateClockTime (date 2022 Mar 17), 0.002035)]
    observationsOneMonth = M.fromList [(dateToDateClockTime (date 2022 Jan 06), 0.0010414), (dateToDateClockTime (date 2022 Mar 17), 0.002035)]
    holidayCalendarId = ["USD"]
    cal =
      HolidayCalendarData with
        id = "USD"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    fixingHolidayCalendarId = ["LIB"]
    fixingCal =
      HolidayCalendarData with
        id = "LIB"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Jan 14]

    issuerPartyRef = "Counterparty"
    clientPartyRef = "ExecutingParty"

    swapStreamFloatingLeg = SwapStream with
      payerPartyReference = issuerPartyRef
      calculationPeriodDates = CalculationPeriodDates with
        effectiveDate = issueDate
        terminationDate = maturityDate
        calculationPeriodDatesAdjustments = CalculationPeriodDatesAdjustments with
          businessDayConvention = ModifiedFollowing
          businessCenters = holidayCalendarId
        firstRegularPeriodStartDate = Some firstRegularPeriodDate
        lastRegularPeriodEndDate = Some lastRegularPeriodDate
        calculationPeriodFrequency = CalculationPeriodFrequency with
          periodMultiplier = paymentPeriodMultiplier
          period = paymentPeriod
          rollConvention = DOM 20
      resetDates = Some ResetDates with
        resetRelativeTo = CalculationPeriodStartDate
        fixingDates = FixingDates with
          periodMultiplier = -2
          period = D
          dayType = Business
          businessDayConvention = NoAdjustment
          businessCenters = fixingHolidayCalendarId
      calculationPeriodAmount = CalculationPeriodAmount with
        calculation = Calculation with
          notionalSchedule = NotionalSchedule with
            notionalStepSchedule = NotionalStepSchedule with
              initialValue = 1.0
              currency = "USD"
          floatingRateCalculation = Some FloatingRateCalculation with
            floatingRateIndex = referenceRateId
            indexTenor = Some Period with
              periodMultiplier = paymentPeriodMultiplier
              period = paymentPeriod
            spreadSchedule = SpreadSchedule with
              initialValue = 0.0
          fixedRateSchedule = None
          dayCountFraction = dayCountConvention
      stubCalculationPeriodAmount = Some StubCalculationPeriodAmount with
        initialStub = Some StubValue with
          stubRate = None
          floatingRate = Some [(StubFloatingRate with floatingRateIndex=referenceRateOneMonthId;indexTenor=Some (Period with period=M;periodMultiplier=1)), (StubFloatingRate with floatingRateIndex=referenceRateId;indexTenor=Some (Period with period=M;periodMultiplier=3))]
        finalStub = None

    swapStreams = [swapStreamFloatingLeg]

  -- A reference data provider publishes the holiday calendars on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = cal.id; calendar = cal; observers = M.fromList fp
  fixingCalendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with agency = calendarDataProvider; entity = fixingCal.id; calendar = fixingCal; observers = M.fromList fp

  observableCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateId; observations; observers = M.empty
  observableOneMonthCid <- coerceContractId <$> submit issuer do createCmd Observation with provider = issuer; id = Id referenceRateOneMonthId; observations=observationsOneMonth; observers = M.empty

  swapInstrument <- originateFpmlSwap custodian issuer "SwapTest1" "Interest rate swap" fp now swapStreams calendarDataProvider cashInstrumentCid issuerPartyRef

  let settlers = singleton custodian

  -- First payment date (after weekend adjustment): Lifecycle stub period and verify the lifecycle effects for floating payment.
  let
    expectedConsumedQuantities = []
    expectedProducedQuantities = [Instrument.qty 0.001867875 cashInstrumentCid]  -- interpolated stub rate from the ISDA paper
  swapInstrumentAfterFirstPayment <- lifecycleAndVerifySwapPaymentEffects [publicParty] (addDays firstRegularPeriodDate 1) swapInstrument settlers issuer investor observers custodian [observableCid, observableOneMonthCid] expectedConsumedQuantities expectedProducedQuantities

  pure ()
