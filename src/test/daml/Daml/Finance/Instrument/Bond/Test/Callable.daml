-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Bond.Test.Callable where

import DA.Date
import DA.Map qualified as M (empty, fromList)
import DA.Optional (fromSome)
import DA.Set qualified as S (singleton)
import Daml.Finance.Data.Numeric.Observation (Observation(..))
import Daml.Finance.Data.Reference.HolidayCalendar
import Daml.Finance.Instrument.Bond.Test.Util
import Daml.Finance.Interface.Types.Common.Types (Id(..))
import Daml.Finance.Interface.Types.Date.Calendar
import Daml.Finance.Interface.Types.Date.DayCount
import Daml.Finance.Interface.Types.Date.RollConvention
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Instrument (originate, verifyNoLifecycleEffects)
import Daml.Finance.Test.Util.Time (dateToDateClockTime)
import Daml.Script

-- Create and lifecycle a fixed coupon callable bond.
run : Script ()
run = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider",
      "PublicParty"]

  -- Account and holding factory
  let pp = [("FactoryProvider", S.singleton publicParty)]

  -- Originate commercial-bank cash
  now <- getTime
  cashInstrumentCid <- originate custodian issuer "EUR" "Euro" pp now

  -- Create and distribute bond
  -- 1.1% coupon every 12M
  -- CREATE_CALLABLE_BOND_VARIABLES_BEGIN
  let
    issueDate = date 2019 Jan 16
    firstCouponDate = date 2019 May 15
    secondCouponDate = date 2020 May 15
    maturityDate = date 2021 May 15
    maturityDateAdj = date 2021 May 17
    notional = 1.0
    referenceRateId = None
    couponRate = 0.011
    couponPeriod = M
    couponPeriodMultiplier = 12
    dayCountConvention = Act365Fixed
    businessDayConvention = Following
    -- CREATE_CALLABLE_BOND_VARIABLES_END
    holidayCalendarIds = ["EUR"]
    cal =
      HolidayCalendarData with
        id = "EUR"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]

  -- A reference data provider publishes the holiday calendar on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with
      provider = calendarDataProvider
      calendar = cal
      observers = M.fromList pp

  bondInstrument <- originateCallableBond issuer issuer "BONDTEST1" "Callable Bond" pp now
    issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate
    dayCountConvention businessDayConvention referenceRateId couponRate couponPeriod
    couponPeriodMultiplier cashInstrumentCid notional

  -- One day before the first coupon date: try to lifecycle and verify that there are no lifecycle
  -- effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays firstCouponDate 1) bondInstrument issuer []

  let
    amount = 1.0
    electorIsOwner = False

  -- First coupon date: Lifecycle and verify that there is an effect for one coupon.
  let
    expectedConsumed = []
    expectedProduced = [qty 0.0035863014 cashInstrumentCid]
  (Some bondInstrumentAfterFirstCoupon, effectCids) <- electAndVerifyPaymentEffects firstCouponDate
    amount bondInstrument electorIsOwner issuer investor [publicParty] "NOT CALLED" []
    expectedConsumed expectedProduced

  -- Second coupon date: Lifecycle and verify that there is an effect for one coupon.
  let
    expectedConsumed = []
    expectedProduced = [qty 0.011030137 cashInstrumentCid]
  (Some bondInstrumentAfterSecondCoupon, effectCids) <- electAndVerifyPaymentEffects
    secondCouponDate amount bondInstrumentAfterFirstCoupon electorIsOwner issuer investor
    [publicParty] "NOT CALLED" [] expectedConsumed expectedProduced

  -- lifecycle on the maturity date
  let
    expectedConsumed = []
    expectedProduced =
      [(qty 0.011060274 cashInstrumentCid), (qty 1.0 cashInstrumentCid)]
  bondInstrumentAfterThirdCoupon <- electAndVerifyPaymentEffects maturityDateAdj amount
    bondInstrumentAfterSecondCoupon electorIsOwner issuer investor [publicParty] "NOT CALLED" []
    expectedConsumed expectedProduced

  pure ()

-- Create and lifecycle a floating coupon callable bond.
runFloating : Script ()
runFloating = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider",
      "PublicParty"]

  -- Account and holding factory
  let pp = [("FactoryProvider", S.singleton publicParty)]

  -- Originate commercial-bank cash
  now <- getTime
  cashInstrumentCid <- originate custodian issuer "EUR" "Euro" pp now

  -- Create and distribute bond
  -- Libor + 0.1% coupon every 12M
  -- CREATE_CALLABLE_BOND_VARIABLES_BEGIN
  let
    issueDate = date 2019 Jan 16
    firstCouponDate = date 2019 May 15
    secondCouponDate = date 2020 May 15
    maturityDate = date 2021 May 15
    maturityDateAdj = date 2021 May 17
    notional = 1.0
    referenceRateId = Some "USD/LIBOR/12M"
    couponRate = 0.011
    couponPeriod = M
    couponPeriodMultiplier = 12
    dayCountConvention = Act365Fixed
    businessDayConvention = Following
    -- CREATE_CALLABLE_BOND_VARIABLES_END
    observations = M.fromList
      [ (dateToDateClockTime $ date 2019 Jan 16, -0.00311)
      , (dateToDateClockTime $ date 2019 Feb 15, -0.00266)
      ]
    holidayCalendarIds = ["EUR"]
    cal =
      HolidayCalendarData with
        id = "EUR"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]

  -- A reference data provider publishes the holiday calendar on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with
      provider = calendarDataProvider
      calendar = cal
      observers = M.fromList pp

  observableCid <- toInterfaceContractId <$> submit issuer do
    createCmd Observation with
      provider = issuer; id = Id $ fromSome referenceRateId; observations; observers = M.empty

  bondInstrument <- originateCallableBond issuer issuer "BONDTEST1" "Callable Bond" pp now
    issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate
    dayCountConvention businessDayConvention referenceRateId couponRate couponPeriod
    couponPeriodMultiplier cashInstrumentCid notional

  -- One day before the first coupon date: try to lifecycle and verify that there are no lifecycle
  -- effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays firstCouponDate 1) bondInstrument issuer
    [observableCid]

  let
    amount = 1.0
    electorIsOwner = False

  -- First coupon date: Lifecycle and verify that there is an effect for one coupon.
  let
    expectedConsumed = []
    expectedProduced = [qty 0.0035863014 cashInstrumentCid]
  (Some bondInstrumentAfterFirstCoupon, effectCids) <- electAndVerifyPaymentEffects firstCouponDate
    amount bondInstrument electorIsOwner issuer investor [publicParty] "NOT CALLED" [observableCid]
    expectedConsumed expectedProduced

  -- Second coupon date: Lifecycle and verify that there is an effect for one coupon.
  let
    expectedConsumed = []
    expectedProduced = [qty 0.011030137 cashInstrumentCid]
  (Some bondInstrumentAfterSecondCoupon, effectCids) <- electAndVerifyPaymentEffects
    secondCouponDate amount bondInstrumentAfterFirstCoupon electorIsOwner issuer investor
    [publicParty] "NOT CALLED" [observableCid] expectedConsumed expectedProduced

  -- lifecycle on the maturity date
  let
    expectedConsumed = []
    expectedProduced =
      [(qty 0.011060274 cashInstrumentCid), (qty 1.0 cashInstrumentCid)]
  bondInstrumentAfterThirdCoupon <- electAndVerifyPaymentEffects maturityDateAdj amount
    bondInstrumentAfterSecondCoupon electorIsOwner issuer investor [publicParty] "NOT CALLED"
    [observableCid] expectedConsumed expectedProduced

  pure ()
