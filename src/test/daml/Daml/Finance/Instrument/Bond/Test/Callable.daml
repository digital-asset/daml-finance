-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Bond.Test.Callable where

import DA.Date
import DA.Map qualified as M (fromList)
import DA.Set qualified as S (singleton)
import Daml.Finance.Data.Reference.HolidayCalendar
import Daml.Finance.Instrument.Bond.Test.Util
import Daml.Finance.Interface.Types.Date.Calendar
import Daml.Finance.Interface.Types.Date.DayCount
import Daml.Finance.Interface.Types.Date.RollConvention
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Instrument (originate, verifyNoLifecycleEffects)
import Daml.Script

-- Penultimate coupon payment on a bond showing creation of new instrument version
run : Script ()
run = script do
  [custodian, issuer, investor, calendarDataProvider, publicParty] <-
    createParties ["Custodian", "Issuer", "Investor", "Calendar Data Provider",
      "PublicParty"]

  -- Account and holding factory
  let pp = [("FactoryProvider", S.singleton publicParty)]

  -- Originate commercial-bank cash
  now <- getTime
  cashInstrumentCid <- originate custodian issuer "EUR" "Euro" pp now

  -- Create and distribute bond
  -- Ireland 1.1% coupon every 12M
  -- todo: change dayCountConvention to ActAct (implement this first)
  -- CREATE_FIXED_RATE_BOND_VARIABLES_BEGIN
  let
    issueDate = date 2019 Jan 16
    firstCouponDate = date 2019 May 15
    secondCouponDate = date 2020 May 15
    maturityDate = date 2021 May 15
    maturityDateAdj = date 2021 May 17
    -- TODO: change to bond with 3 coupons to verify that historic event list works as expected
    couponRate : Decimal = 0.011
    couponPeriod = M
    couponPeriodMultiplier = 12
    dayCountConvention = Act365Fixed
    businessDayConvention = Following
    -- CREATE_FIXED_RATE_BOND_VARIABLES_END
    -- Test specifying 2 calendars (the union of the two will be used)
    holidayCalendarIds = ["EUR", "EUR2"]
    cal =
      HolidayCalendarData with
        id = "EUR"
        weekend = [Saturday, Sunday]
        holidays = [date 2019 Dec 19]
    cal2 =
      HolidayCalendarData with
        id = "EUR2"
        weekend = [Saturday, Sunday]
        holidays = [date 2020 Dec 19]

  -- A reference data provider publishes the holiday calendar on the ledger
  calendarCid <- submit calendarDataProvider do
    createCmd HolidayCalendar with
      provider = calendarDataProvider
      calendar = cal
      observers = M.fromList pp

  calendarCid2 <- submit calendarDataProvider do
    createCmd HolidayCalendar with
      provider = calendarDataProvider
      calendar = cal2
      observers = M.fromList pp

  bondInstrument <- originateCallableBond issuer issuer "BONDTEST1" "Fixed Rate Bond" pp now
    issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate
    dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier
    cashInstrumentCid

  -- One day before the first coupon date: try to lifecycle and verify that there are no lifecycle
  -- effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays firstCouponDate 1) bondInstrument issuer []

  let
    amount : Decimal = 1.0
    electorIsOwner = False

  -- First coupon date: Lifecycle and verify that there is an effect for one coupon.
  let
    expectedConsumed = []
    expectedProduced = [qty 0.0035863014 cashInstrumentCid]
  (Some bondInstrumentAfterFirstCoupon, effectCids) <- electAndVerifyPaymentEffects firstCouponDate amount
    bondInstrument electorIsOwner issuer investor [publicParty] "NOT CALLED" expectedConsumed expectedProduced

  -- One day after the first coupon date: try to lifecycle and verify that there are no lifecycle
  -- effects.
  verifyNoLifecycleEffects [publicParty] (addDays firstCouponDate 1) bondInstrumentAfterFirstCoupon
    issuer []

  -- One day before expiry: try to lifecycle and verify that there are no lifecycle effects.
  verifyNoLifecycleEffects [publicParty] (subtractDays maturityDate 1)
    bondInstrumentAfterFirstCoupon issuer []

  -- Second coupon date: Lifecycle and verify that there is an effect for one coupon.
  let
    expectedConsumed = []
    expectedProduced = [qty 0.011030137 cashInstrumentCid]
  (Some bondInstrumentAfterSecondCoupon, effectCids) <- electAndVerifyPaymentEffects secondCouponDate amount
    bondInstrumentAfterFirstCoupon electorIsOwner issuer investor [publicParty] "NOT CALLED" expectedConsumed expectedProduced
  debug "bondInstrumentAfterSecondCoupon"
  debug bondInstrumentAfterSecondCoupon

  -- lifecycle on the maturity date
  let
    expectedConsumed = []
    expectedProduced =
      [(qty 0.011060274 cashInstrumentCid), (qty 1.0 cashInstrumentCid)]
  bondInstrumentAfterThirdCoupon <- electAndVerifyPaymentEffects maturityDateAdj amount
    bondInstrumentAfterSecondCoupon electorIsOwner issuer investor [publicParty] "NOT CALLED" expectedConsumed expectedProduced
  debug bondInstrumentAfterThirdCoupon

  pure ()
