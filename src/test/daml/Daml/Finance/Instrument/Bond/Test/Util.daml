-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Bond.Test.Util where

import DA.Map qualified as M
import DA.Set (Set, empty, singleton)
import Daml.Finance.Common.Date.Calendar
import Daml.Finance.Common.Date.DayCount
import Daml.Finance.Common.Date.RollConvention
import Daml.Finance.Instrument.Bond.FixedRate qualified as FixedRate (Instrument(..))
import Daml.Finance.Instrument.Bond.FloatingRate qualified as FloatingRate (Instrument(..))
import Daml.Finance.Instrument.Bond.InflationLinked qualified as InflationLinked (Instrument(..))
import Daml.Finance.Instrument.Bond.ZeroCoupon qualified as ZeroCoupon (Instrument(..))
import Daml.Finance.Interface.Common.Types
import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (GetView(..), K, I, toKey)
import Daml.Finance.Interface.Instrument.Generic.Types (Deliverable)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I)
import Daml.Finance.Interface.Lifecycle.Lifecyclable qualified as Lifecyclable (I, Lifecycle(..))
import Daml.Finance.Interface.Lifecycle.Observable qualified as Observable (I)
import Daml.Finance.Interface.Lifecycle.SettlementRule qualified as SettlementRule (Claim(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Lifecycle.Rule.Settlement (Rule(..))
import Daml.Finance.RefData.Time.DateClock (DateClock(..), DateClockUpdateEvent(..), Unit(..))
import Daml.Finance.Settlement.Factory (Factory(..))
import Daml.Finance.Test.Util.Holding (verifyOwnerOfHolding)
import Daml.Finance.Test.Util.Instrument (createReference)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (submitExerciseInterfaceByKeyCmd)
import Daml.Script
import Prelude hiding (lookup)

originateFixedRateBond : Party -> Party -> Text -> [(Text, Set Parties)] -> Time -> Date -> [Text] -> Party -> Date-> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Script Instrument.K
originateFixedRateBond depository issuer label observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency = do
  -- CREATE_FIXED_RATE_BOND_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId @Instrument.I <$> submitMulti [depository, issuer] [] do
    createCmd FixedRate.Instrument with depository; issuer; id = (Id with label; version = "0"); observers = M.fromList observers; lastEventTimestamp; issueDate; holidayCalendarIds; calendarDataProvider; firstCouponDate; maturityDate; dayCountConvention; businessDayConvention; couponRate; couponPeriod; couponPeriodMultiplier; currency
  -- CREATE_FIXED_RATE_BOND_INSTRUMENT_END
  createReference cid depository issuer observers

originateZeroCouponBond : Party -> Party -> Text -> [(Text, Set Parties)] -> Time -> Date -> Date -> Deliverable -> Script Instrument.K
originateZeroCouponBond depository issuer label observers lastEventTimestamp issueDate maturityDate currency = do
  -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd ZeroCoupon.Instrument with depository; issuer; id = (Id with label; version = "0"); observers = M.fromList observers; lastEventTimestamp; issueDate; maturityDate; currency
  -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_END
  createReference cid depository issuer observers

originateFloatingRateBond : Party -> Party -> Text -> [(Text, Set Parties)] -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Text -> Script Instrument.K
originateFloatingRateBond depository issuer label observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency referenceRateId = do
  -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd FloatingRate.Instrument with depository; issuer; id = (Id with label; version = "0"); observers = M.fromList observers; lastEventTimestamp; issueDate; holidayCalendarIds; calendarDataProvider; firstCouponDate; maturityDate; dayCountConvention; businessDayConvention; couponSpread=couponRate; referenceRateId; couponPeriod; couponPeriodMultiplier; currency
  -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_END
  createReference cid depository issuer observers

originateInflationLinkedBond : Party -> Party -> Text -> [(Text, Set Parties)] -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Text -> Decimal -> Script Instrument.K
originateInflationLinkedBond depository issuer label observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency inflationIndexId inflationIndexBaseValue = do
  -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd InflationLinked.Instrument with depository; issuer; id = (Id with label; version = "0"); observers = M.fromList observers; lastEventTimestamp; issueDate; holidayCalendarIds; calendarDataProvider; firstCouponDate; maturityDate; dayCountConvention; businessDayConvention; couponRate; inflationIndexId; couponPeriod; couponPeriodMultiplier; currency; inflationIndexBaseValue
  -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_END
  createReference cid depository issuer observers

lifecycleBond : [Party] -> Date -> Instrument.K -> Party -> Party -> [ContractId Observable.I] -> Script (ContractId Lifecyclable.I, [ContractId Effect.I])
lifecycleBond readAs today bondInstrument settler issuer observableCids = do
  -- CREATE_CLOCK_FOR_BOND_LIFECYCLING_BEGIN
  -- create clock and clock update event
  let clock = DateClock with u = Unit today; id = show today; provider = issuer; observers = M.empty
  clockCid <- toInterfaceContractId <$> submitMulti [issuer] [] do createCmd clock
  clockEventCid <- toInterfaceContractId <$> submitMulti [issuer] [] do createCmd DateClockUpdateEvent with id = "Update to " <> show today, clock
  -- CREATE_CLOCK_FOR_BOND_LIFECYCLING_END

  -- LIFECYCLE_BOND_BEGIN
  -- Try to lifecycle bond
  (bondLifecyclableCid2, effectCids) <- Instrument.submitExerciseInterfaceByKeyCmd @Lifecyclable.I [issuer] readAs bondInstrument
    Lifecyclable.Lifecycle with settler; eventCid = clockEventCid; observableCids; ruleName = "Time"; clockCid
  -- LIFECYCLE_BOND_END

  pure (bondLifecyclableCid2, effectCids)

verifyNoLifecycleEffects : [Party] -> Date -> Instrument.K -> Party -> Party -> [ContractId Observable.I] -> Script ()
verifyNoLifecycleEffects readAs today bondInstrument settler issuer observableCids = do
  (bondLifecyclableCid2, effectCids) <- lifecycleBond readAs today bondInstrument settler issuer observableCids
  assertMsg ("There should be no lifecycle effects on " <> show today) (null effectCids)

lifecycleAndVerifyCouponEffectsAndSettlement : [Party] -> Date -> Instrument.K -> Party -> Party -> Party -> ContractId Transferable.I -> ContractId Transferable.I -> AccountKey -> AccountKey -> [(Text, Set Parties)] -> Party -> [ContractId Observable.I] ->  Script (Instrument.K, ContractId Transferable.I)
lifecycleAndVerifyCouponEffectsAndSettlement readAs today bondInstrument settler issuer investor investorBondTransferableCid custodianCashTransferableCid custodianAccount investorAccount obs custodian observableCids = do
  (bondLifecyclableCid, [effectCid]) <- lifecycleBond readAs today bondInstrument settler issuer observableCids

  newBondInstrumentKey <- submitMulti [issuer] [] do
    Instrument.toKey <$> exerciseCmd @Instrument.I (coerceContractId bondLifecyclableCid) Instrument.GetView with viewer = issuer

  -- CREATE_SETTLEMENT_FACTORY_BOND_BEGIN
  -- Create settlement factory
  settlementFactoryCid <- submitMulti [investor] [] do createCmd Factory with provider = investor; observers = empty
  -- CREATE_SETTLEMENT_FACTORY_BOND_END

  -- CLAIM_EFFECT_BOND_BEGIN
  -- Claim effect
  settlementRuleCid <- submitMulti [custodian, investor] [] do
    createCmd Rule
      with
        custodian
        owner = investor
        claimers = singleton investor
        settler
        factoryCid = toInterfaceContractId settlementFactoryCid

  result <- submitMulti [investor] readAs do
    exerciseCmd settlementRuleCid SettlementRule.Claim with
      claimer = investor
      holdingCids = [toInterfaceContractId @Base.I investorBondTransferableCid]
      effectCid
  -- CLAIM_EFFECT_BOND_END

  -- ALLOCATE_APPROVE_SETTLE_INSTRUCTIONS_BOND_BEGIN
  let
    Some [investorBondHoldingCid] = result.newInstrumentHoldingCids
    [custodianCashInstructionCid] = result.instructionCids

  -- Allocate instructions
  custodianCashInstructionCid <- submitMulti [custodian] readAs do exerciseCmd custodianCashInstructionCid Instruction.Allocate with transferableCid = custodianCashTransferableCid

  -- Approve instructions
  custodianCashInstructionCid <- submitMulti [investor] [] do
    exerciseCmd custodianCashInstructionCid Instruction.Approve with receiverAccount = investorAccount

  -- Settle container
  [investorCashTransferableCid] <- submitMulti [settler] readAs do exerciseCmd result.containerCid Batch.Settle
  -- ALLOCATE_APPROVE_SETTLE_INSTRUCTIONS_BOND_END

  -- Assert state
  verifyOwnerOfHolding [(investor, investorBondHoldingCid), (investor, toInterfaceContractId investorCashTransferableCid)]

  pure (newBondInstrumentKey, coerceContractId investorBondHoldingCid)

lifecycleAndVerifyRedemptionEffectsAndSettlement : [Party] -> Date -> Instrument.K -> Party -> Party -> Party -> ContractId Transferable.I -> ContractId Transferable.I -> ContractId Transferable.I -> AccountKey -> AccountKey -> [(Text, Set Parties)] -> Party -> [ContractId Observable.I] -> Script Instrument.K
lifecycleAndVerifyRedemptionEffectsAndSettlement readAs today bondInstrument settler issuer investor investorBondTransferableCid custodianCashCouponTransferableCid custodianCashRedemptionTransferableCid custodianAccount investorAccount obs custodian observableCids = do
  (bondLifecyclableCid, [effectCid]) <- lifecycleBond readAs today bondInstrument settler issuer observableCids

  newBondInstrumentKey <- submitMulti [issuer] [] do
    Instrument.toKey <$> exerciseCmd @Instrument.I (coerceContractId bondLifecyclableCid) Instrument.GetView with viewer = issuer

  -- Create settlement factory
  settlementFactoryCid <- submitMulti [investor] [] do createCmd Factory with provider = investor; observers = empty

  -- Claim effect
  settlementRuleCid <- submitMulti [custodian, investor] [] do
    createCmd Rule
      with
        custodian
        owner = investor
        claimers = singleton investor
        settler
        factoryCid = toInterfaceContractId settlementFactoryCid

  result <- submitMulti [investor] readAs do
    exerciseCmd settlementRuleCid SettlementRule.Claim with
      claimer = investor
      holdingCids = [toInterfaceContractId @Base.I investorBondTransferableCid]
      effectCid

  let
    [custodianCouponInstructionCid, custodianRedemptionInstructionCid] = result.instructionCids

  -- Allocate instructions
  custodianCouponInstructionCid <- submitMulti [custodian] [] do exerciseCmd custodianCouponInstructionCid Instruction.Allocate with transferableCid = custodianCashCouponTransferableCid
  custodianRedemptionInstructionCid <- submitMulti [custodian] [] do exerciseCmd custodianRedemptionInstructionCid Instruction.Allocate with transferableCid = custodianCashRedemptionTransferableCid

  -- Approve instructions
  custodianBondInstructionCid <- submitMulti [investor] [] do
    exerciseCmd custodianCouponInstructionCid Instruction.Approve with receiverAccount = investorAccount
  custodianCashInstructionCid <- submitMulti [investor] [] do
    exerciseCmd custodianRedemptionInstructionCid Instruction.Approve with receiverAccount = investorAccount

  -- Settle container
  [investorCouponTransferableCid, investorRedemptionTransferableCid] <-
    submitMulti [settler] readAs do exerciseCmd result.containerCid Batch.Settle

  -- Assert state
  verifyOwnerOfHolding [(investor, investorCouponTransferableCid), (investor, investorRedemptionTransferableCid)]

  pure newBondInstrumentKey
