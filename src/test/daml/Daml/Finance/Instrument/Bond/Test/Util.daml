-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Bond.Test.Util where

import DA.Map qualified as M (empty, fromList)
import Daml.Finance.Instrument.Bond.Callable.Factory qualified as Callable (Factory(..))
import Daml.Finance.Instrument.Bond.Callable.Instrument qualified as Callable (Instrument(..))
import Daml.Finance.Instrument.Bond.FixedRate.Instrument qualified as FixedRate (Instrument(..))
import Daml.Finance.Instrument.Bond.FloatingRate.Instrument qualified as FloatingRate (Instrument(..))
import Daml.Finance.Instrument.Bond.InflationLinked.Instrument qualified as InflationLinked (Instrument(..))
import Daml.Finance.Instrument.Bond.ZeroCoupon.Instrument qualified as ZeroCoupon (Instrument(..))
import Daml.Finance.Interface.Claims.Types (Deliverable)
import Daml.Finance.Interface.Instrument.Bond.Callable.Factory qualified as Callable (Create(..), F(..))
import Daml.Finance.Interface.Instrument.Bond.Callable.Types (Callable(..))
import Daml.Finance.Interface.Instrument.Bond.Types (FloatingRate)
import Daml.Finance.Interface.Types.Common.Types (Id(..), InstrumentKey(..), Parties)
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayConventionEnum)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum)
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule)
import Daml.Finance.Test.Util.Instrument (createReference)
import Daml.Finance.Test.Util.Time (createPaymentPeriodicSchedule)
import Daml.Script

originateFixedRateBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  [Text] -> Party -> Date-> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal ->
  Script InstrumentKey
originateFixedRateBond depository issuer label description observers lastEventTimestamp issueDate
  holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency notional = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_FIXED_RATE_BOND_INSTRUMENT_BEGIN
    cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
      createCmd FixedRate.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponRate; currency; notional
    -- CREATE_FIXED_RATE_BOND_INSTRUMENT_END
    createReference cid depository issuer observers

originateCallableBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  [Text] -> Party -> Date -> Date -> DayCountConventionEnum ->
  Bool -> BusinessDayConventionEnum -> Optional FloatingRate -> Decimal -> Optional Decimal ->
  Optional Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal -> Int -> Party ->
  Script InstrumentKey
originateCallableBond depository issuer label description observers lastEventTimestamp issueDate
  holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  useAdjustedDatesForDcf businessDayConvention floatingRate couponRate capRate
  floorRate couponPeriod couponPeriodMultiplier currency notional noticeDays publicParty = do
    let
      couponSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
      callSchedule = couponSchedule

    -- Create a floating rate bond factory
    callableBondFactoryCid <- toInterfaceContractId @Callable.F <$> submit issuer do
      createCmd Callable.Factory with
        provider = issuer
        observers = M.empty

    -- CREATE_CALLABLE_BOND_INSTRUMENT_BEGIN
    let
      instrument = InstrumentKey with
        issuer
        depository
        id = Id label
        version = "0"

    cid <- submitMulti [issuer] [publicParty] do
      exerciseCmd callableBondFactoryCid Callable.Create with
        callable = Callable with
          instrument
          description = "Instrument representing units of a callable bond"
          floatingRate
          couponRate
          capRate
          floorRate
          couponSchedule
          noticeDays
          callSchedule
          holidayCalendarIds
          calendarDataProvider
          dayCountConvention
          useAdjustedDatesForDcf
          currency
          notional
          lastEventTimestamp
          prevElections = []
        observers = M.fromList observers
    -- CREATE_CALLABLE_BOND_INSTRUMENT_END
    pure instrument

originateMultiScheduleCallableBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time ->
  [Text] -> Party -> DayCountConventionEnum -> Bool -> Optional FloatingRate ->
  Decimal -> Optional Decimal -> Optional Decimal -> InstrumentKey -> Decimal -> PeriodicSchedule
  -> PeriodicSchedule -> Int -> Script InstrumentKey
originateMultiScheduleCallableBond depository issuer label description observers lastEventTimestamp
  holidayCalendarIds calendarDataProvider dayCountConvention useAdjustedDatesForDcf floatingRate
  couponRate capRate floorRate currency notional couponSchedule
  callSchedule noticeDays = do
    -- CREATE_MULTI_SCHEDULE_CALLABLE_BOND_INSTRUMENT_BEGIN
    cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
      createCmd Callable.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; prevElections = []; couponSchedule
        callSchedule; noticeDays; holidayCalendarIds; calendarDataProvider; dayCountConvention
        useAdjustedDatesForDcf; floatingRate; couponRate; capRate; floorRate; currency; notional
    -- CREATE_MULTI_SCHEDULE_CALLABLE_BOND_INSTRUMENT_END
    createReference cid depository issuer observers

originateZeroCouponBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  Date -> Deliverable -> Decimal ->
  Script InstrumentKey
originateZeroCouponBond depository issuer label description observers lastEventTimestamp issueDate
  maturityDate currency notional = do
    -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_BEGIN
    cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
      createCmd ZeroCoupon.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; issueDate; maturityDate; currency
        notional
    -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_END
    createReference cid depository issuer observers

originateFloatingRateBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  [Text] -> Party -> Date -> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal ->
  Text -> Script InstrumentKey
originateFloatingRateBond depository issuer label description observers lastEventTimestamp issueDate
  holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponSpread couponPeriod couponPeriodMultiplier currency notional
  referenceRateId = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_BEGIN
    cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
      createCmd FloatingRate.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponSpread; referenceRateId; currency; notional
    -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_END
    createReference cid depository issuer observers

originateInflationLinkedBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time ->
  Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal ->
  Text -> Decimal -> Script InstrumentKey
originateInflationLinkedBond depository issuer label description observers lastEventTimestamp
  issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency notional
  inflationIndexId inflationIndexBaseValue = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_BEGIN
    cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
      createCmd InflationLinked.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponRate; inflationIndexId; currency; notional
        inflationIndexBaseValue
    -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_END
    createReference cid depository issuer observers
