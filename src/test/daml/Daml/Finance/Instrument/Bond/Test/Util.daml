-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Bond.Test.Util where

import DA.Map qualified as M (fromList)
import Daml.Finance.Instrument.Bond.FixedRate.Instrument qualified as FixedRate (Instrument(..))
import Daml.Finance.Instrument.Bond.FloatingRate.Instrument qualified as FloatingRate (Instrument(..))
import Daml.Finance.Instrument.Bond.InflationLinked.Instrument qualified as InflationLinked (Instrument(..))
import Daml.Finance.Instrument.Bond.ZeroCoupon.Instrument qualified as ZeroCoupon (Instrument(..))
import Daml.Finance.Interface.Claims.Types (Deliverable)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as BaseInstrument (I)
import Daml.Finance.Interface.Types.Common.Types (Id(..), InstrumentKey, Parties)
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayConventionEnum)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum)
import Daml.Finance.Interface.Util.KeyTable (getKey)
import Daml.Finance.Test.Util.Time (createPaymentPeriodicSchedule)
import Daml.Script

originateFixedRateBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  [Text] -> Party -> Date-> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Script InstrumentKey
originateFixedRateBond depository issuer label description observers lastEventTimestamp issueDate
  holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_FIXED_RATE_BOND_INSTRUMENT_BEGIN
    let
      instrument = FixedRate.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponRate; currency
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_FIXED_RATE_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateZeroCouponBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  Date -> Deliverable -> Script InstrumentKey
originateZeroCouponBond depository issuer label description observers lastEventTimestamp issueDate
  maturityDate currency = do
    -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_BEGIN
    let
      instrument =
        ZeroCoupon.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; issueDate; maturityDate; currency
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateFloatingRateBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  [Text] -> Party -> Date -> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey ->
  Text -> Script InstrumentKey
originateFloatingRateBond depository issuer label description observers lastEventTimestamp issueDate
  holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponSpread couponPeriod couponPeriodMultiplier currency
  referenceRateId = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_BEGIN
    let
      instrument = FloatingRate.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponSpread; referenceRateId; currency
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateInflationLinkedBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time ->
  Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Text ->
  Decimal -> Script InstrumentKey
originateInflationLinkedBond depository issuer label description observers lastEventTimestamp
  issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency inflationIndexId
  inflationIndexBaseValue = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_BEGIN
    let
      instrument = InflationLinked.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponRate; inflationIndexId; currency
        inflationIndexBaseValue
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument
