-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Finance.Instrument.Bond.Test.Util where

import DA.Map qualified as M (fromList)
import Daml.Finance.Instrument.Bond.Callable.Instrument qualified as Callable (Instrument(..))
import Daml.Finance.Instrument.Bond.FixedRate.Instrument qualified as FixedRate (Instrument(..))
import Daml.Finance.Instrument.Bond.FloatingRate.Instrument qualified as FloatingRate (Instrument(..))
import Daml.Finance.Instrument.Bond.InflationLinked.Instrument qualified as InflationLinked (Instrument(..))
import Daml.Finance.Instrument.Bond.ZeroCoupon.Instrument qualified as ZeroCoupon (Instrument(..))
import Daml.Finance.Interface.Claims.Types (Deliverable)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as BaseInstrument (I)
import Daml.Finance.Interface.Instrument.Bond.Types (FloatingRate)
import Daml.Finance.Interface.Types.Common.Types (Id(..), InstrumentKey, Parties)
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayConventionEnum)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum)
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule)
import Daml.Finance.Interface.Util.KeyTable (getKey)
import Daml.Finance.Test.Util.Time (createPaymentPeriodicSchedule)
import Daml.Script

originateFixedRateBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  [Text] -> Party -> Date-> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal ->
  Script InstrumentKey
originateFixedRateBond depository issuer label description observers lastEventTimestamp issueDate
  holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency notional = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_FIXED_RATE_BOND_INSTRUMENT_BEGIN
    let
      instrument = FixedRate.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponRate; currency; notional
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_FIXED_RATE_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateCallableBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  [Text] -> Party -> Date -> Date -> DayCountConventionEnum ->
  Bool -> BusinessDayConventionEnum -> Optional FloatingRate -> Decimal -> Optional Decimal ->
  Optional Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal -> Int -> Script InstrumentKey
originateCallableBond depository issuer label description observers lastEventTimestamp issueDate
  holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  useAdjustedDatesForDcf businessDayConvention floatingRate couponRate capRate floorRate
  couponPeriod couponPeriodMultiplier currency notional noticeDays = do
    let
      couponSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
      callSchedule = couponSchedule
    -- CREATE_CALLABLE_BOND_INSTRUMENT_BEGIN
    let
      instrument = Callable.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; prevElections = []; couponSchedule
        callSchedule; noticeDays; holidayCalendarIds; calendarDataProvider; dayCountConvention
        useAdjustedDatesForDcf; floatingRate; couponRate; capRate; floorRate; currency; notional
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_CALLABLE_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateMultiScheduleCallableBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time ->
  [Text] -> Party -> DayCountConventionEnum -> Bool -> Optional FloatingRate ->
  Decimal -> Optional Decimal -> Optional Decimal -> InstrumentKey -> Decimal -> PeriodicSchedule
  -> PeriodicSchedule -> Int -> Script InstrumentKey
originateMultiScheduleCallableBond depository issuer label description observers lastEventTimestamp
  holidayCalendarIds calendarDataProvider dayCountConvention useAdjustedDatesForDcf floatingRate
  couponRate capRate floorRate currency notional couponSchedule
  callSchedule noticeDays = do
    -- CREATE_MULTI_SCHEDULE_CALLABLE_BOND_INSTRUMENT_BEGIN
    let
      instrument =
        Callable.Instrument with
          depository; issuer; id = Id label; version = "0"; description
          observers = M.fromList observers; lastEventTimestamp; prevElections = []; couponSchedule
          callSchedule; noticeDays; holidayCalendarIds; calendarDataProvider; dayCountConvention
          useAdjustedDatesForDcf; floatingRate; couponRate; capRate; floorRate; currency; notional
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_MULTI_SCHEDULE_CALLABLE_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateZeroCouponBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  Date -> Deliverable -> Decimal ->
  Script InstrumentKey
originateZeroCouponBond depository issuer label description observers lastEventTimestamp issueDate
  maturityDate currency notional = do
    -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_BEGIN
    let
      instrument =
        ZeroCoupon.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; issueDate; maturityDate; currency
        notional
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateFloatingRateBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  [Text] -> Party -> Date -> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal ->
  Text -> Script InstrumentKey
originateFloatingRateBond depository issuer label description observers lastEventTimestamp issueDate
  holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponSpread couponPeriod couponPeriodMultiplier currency notional
  referenceRateId = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_BEGIN
    let
      instrument = FloatingRate.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponSpread; referenceRateId; currency; notional
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateInflationLinkedBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time ->
  Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal ->
  Text -> Decimal -> Script InstrumentKey
originateInflationLinkedBond depository issuer label description observers lastEventTimestamp
  issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency notional
  inflationIndexId inflationIndexBaseValue = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_BEGIN
    let
      instrument = InflationLinked.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponRate; inflationIndexId; currency; notional
        inflationIndexBaseValue
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument
