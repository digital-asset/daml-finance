-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Bond.Test.Util where

import DA.Date
import DA.Map qualified as M
import DA.Set (Set, empty, singleton)
import Daml.Finance.Instrument.Bond.FixedRate qualified as FixedRate (Instrument(..))
import Daml.Finance.Instrument.Bond.FloatingRate qualified as FloatingRate (Instrument(..))
import Daml.Finance.Instrument.Bond.InflationLinked qualified as InflationLinked (Instrument(..))
import Daml.Finance.Instrument.Bond.InterestRateSwap qualified as InterestRateSwap (Instrument(..))
import Daml.Finance.Instrument.Bond.ZeroCoupon qualified as ZeroCoupon (Instrument(..))
import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (GetView(..), K, I, toKey)
import Daml.Finance.Interface.Instrument.Generic.Types (Deliverable)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I)
import Daml.Finance.Interface.Lifecycle.Observable qualified as Observable (I)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (I, Evolve(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayAdjustment(..), BusinessDayConventionEnum)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum, RollConventionEnum(..))
import Daml.Finance.Interface.Types.Date.Schedule (Frequency(..), PeriodicSchedule(..))
import Daml.Finance.Lifecycle.Rule.Claim qualified as Claim (Rule(..))
import Daml.Finance.RefData.Time.DateClock (DateClock(..), DateClockUpdateEvent(..), Unit(..))
import Daml.Finance.Settlement.Factory (Factory(..))
import Daml.Finance.Test.Util.Holding (verifyOwnerOfHolding)
import Daml.Finance.Test.Util.Instrument (createReference)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (submitExerciseInterfaceByKeyCmd)
import Daml.Script
import Prelude hiding (lookup)

-- | Create a schedule for the periodic coupon payments.
createCouponPeriodicSchedule : Date -> [Text] -> BusinessDayConventionEnum -> PeriodEnum -> Int -> Date -> Date -> PeriodicSchedule
createCouponPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate = do
  -- CREATE_BOND_PERIODIC_SCHEDULE_BEGIN
  let
    (y, m, d) = toGregorian firstCouponDate
    periodicSchedule = PeriodicSchedule with
      businessDayAdjustment =
        BusinessDayAdjustment with
          calendarIds = holidayCalendarIds
          convention = businessDayConvention
      effectiveDateBusinessDayAdjustment = None
      terminationDateBusinessDayAdjustment = None
      frequency =
        Frequency with
          rollConvention = DOM d
          period = couponPeriod
          periodMultiplier = couponPeriodMultiplier
      effectiveDate = issueDate
      firstRegularPeriodStartDate = Some firstCouponDate
      lastRegularPeriodEndDate = Some maturityDate
      stubPeriodType = None
      terminationDate = maturityDate
  -- CREATE_BOND_PERIODIC_SCHEDULE_END
  periodicSchedule

originateFixedRateBond : Party -> Party -> Text -> Text -> [(Text, Set Parties)] -> Time -> Date -> [Text] -> Party -> Date-> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Script Instrument.K
originateFixedRateBond depository issuer label description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency = do
  let
    periodicSchedule = createCouponPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  -- CREATE_FIXED_RATE_BOND_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId @Instrument.I <$> submitMulti [depository, issuer] [] do
    createCmd FixedRate.Instrument with depository; issuer; id = Id label; version = "0"; description; observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; couponRate; currency
  -- CREATE_FIXED_RATE_BOND_INSTRUMENT_END
  createReference cid depository issuer observers

originateZeroCouponBond : Party -> Party -> Text -> Text -> [(Text, Set Parties)] -> Time -> Date -> Date -> Deliverable -> Script Instrument.K
originateZeroCouponBond depository issuer label description observers lastEventTimestamp issueDate maturityDate currency = do
  -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd ZeroCoupon.Instrument with depository; issuer; id = Id label; version = "0"; description; observers = M.fromList observers; lastEventTimestamp; issueDate; maturityDate; currency
  -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_END
  createReference cid depository issuer observers

originateFloatingRateBond : Party -> Party -> Text -> Text -> [(Text, Set Parties)] -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Text -> Script Instrument.K
originateFloatingRateBond depository issuer label description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency referenceRateId = do
  let
    periodicSchedule = createCouponPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd FloatingRate.Instrument with depository; issuer; id = Id label; version = "0"; description; observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; couponSpread=couponRate; referenceRateId; currency
  -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_END
  createReference cid depository issuer observers

originateInflationLinkedBond : Party -> Party -> Text -> Text -> [(Text, Set Parties)] -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Text -> Decimal -> Script Instrument.K
originateInflationLinkedBond depository issuer label description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency inflationIndexId inflationIndexBaseValue = do
  let
    periodicSchedule = createCouponPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd InflationLinked.Instrument with depository; issuer; id = Id label; version = "0"; description; observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; couponRate; inflationIndexId; currency; inflationIndexBaseValue
  -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_END
  createReference cid depository issuer observers

originateInterestRateSwap : Party -> Party -> Text -> Text -> [(Text, Set Parties)] -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Text -> Script Instrument.K
originateInterestRateSwap depository issuer label description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency referenceRateId = do
  let
    periodicSchedule = createCouponPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  -- CREATE_INTEREST_RATE_SWAP_INSTRUMENT_BEGIN
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd InterestRateSwap.Instrument with depository; issuer; id = Id label; version = "0"; description; observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; fixRate=couponRate; referenceRateId; currency
  -- CREATE_INTEREST_RATE_SWAP_INSTRUMENT_END
  createReference cid depository issuer observers

lifecycleBond : [Party] -> Date -> Instrument.K -> Party -> Party -> [ContractId Observable.I] -> Script (ContractId Lifecycle.I, [ContractId Effect.I])
lifecycleBond readAs today bondInstrument settler issuer observableCids = do
  -- CREATE_CLOCK_FOR_BOND_LIFECYCLING_BEGIN
  -- create clock and clock update event
  let clock = DateClock with u = Unit today; id = Id (show today); provider = issuer; observers = M.empty
  clockCid <- toInterfaceContractId <$> submitMulti [issuer] [] do createCmd clock
  clockEventCid <- toInterfaceContractId <$> submitMulti [issuer] [] do createCmd DateClockUpdateEvent with id = Id (show today); clock
  -- CREATE_CLOCK_FOR_BOND_LIFECYCLING_END

  -- LIFECYCLE_BOND_BEGIN
  -- Try to lifecycle bond
  (bondLifecycleCid2, effectCids) <- Instrument.submitExerciseInterfaceByKeyCmd @Lifecycle.I [issuer] readAs bondInstrument
    Lifecycle.Evolve with settler; eventCid = clockEventCid; observableCids; ruleName = "Time"; clockCid
  -- LIFECYCLE_BOND_END

  pure (bondLifecycleCid2, effectCids)

verifyNoLifecycleEffects : [Party] -> Date -> Instrument.K -> Party -> Party -> [ContractId Observable.I] -> Script ()
verifyNoLifecycleEffects readAs today bondInstrument settler issuer observableCids = do
  (bondLifecycleCid2, effectCids) <- lifecycleBond readAs today bondInstrument settler issuer observableCids
  assertMsg ("There should be no lifecycle effects on " <> show today) (null effectCids)

lifecycleAndVerifyCouponEffectsAndSettlement : [Party] -> Date -> Instrument.K -> Party -> Party -> Party -> ContractId Transferable.I -> ContractId Transferable.I -> AccountKey -> AccountKey -> [(Text, Set Parties)] -> Party -> [ContractId Observable.I] -> Script (Instrument.K, ContractId Transferable.I)
lifecycleAndVerifyCouponEffectsAndSettlement readAs today bondInstrument settler issuer investor investorBondTransferableCid custodianCashTransferableCid custodianAccount investorAccount obs custodian observableCids = do
  (bondLifecycleCid, [effectCid]) <- lifecycleBond readAs today bondInstrument settler issuer observableCids

  newBondInstrumentKey <- submitMulti [issuer] [] do
    Instrument.toKey <$> exerciseCmd @Instrument.I (coerceContractId bondLifecycleCid) Instrument.GetView with viewer = issuer

  -- CREATE_SETTLEMENT_FACTORY_BOND_BEGIN
  -- Create settlement factory
  settlementFactoryCid <- submitMulti [investor] [] do createCmd Factory with provider = investor; observers = empty
  -- CREATE_SETTLEMENT_FACTORY_BOND_END

  -- CLAIM_EFFECT_BOND_BEGIN
  -- Claim effect
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submitMulti [custodian, investor] [] do
    createCmd Claim.Rule
      with
        custodian
        owner = investor
        claimers = singleton investor
        settler
        factoryCid = toInterfaceContractId settlementFactoryCid

  result <- submitMulti [investor] readAs do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = investor
      holdingCids = [toInterfaceContractId @Base.I investorBondTransferableCid]
      effectCid
  -- CLAIM_EFFECT_BOND_END

  -- ALLOCATE_APPROVE_SETTLE_INSTRUCTIONS_BOND_BEGIN
  let
    Some [investorBondHoldingCid] = result.newInstrumentHoldingCids
    [custodianCashInstructionCid] = result.instructionCids

  -- Allocate instructions
  custodianCashInstructionCid <- submitMulti [custodian] readAs do exerciseCmd custodianCashInstructionCid Instruction.Allocate with allocation = Pledge custodianCashTransferableCid

  -- Approve instructions
  custodianCashInstructionCid <- submitMulti [investor] [] do
    exerciseCmd custodianCashInstructionCid Instruction.Approve with approval = TakeDelivery investorAccount

  -- Settle batch
  [investorCashTransferableCid] <- submitMulti [settler] readAs do exerciseCmd result.batchCid Batch.Settle
  -- ALLOCATE_APPROVE_SETTLE_INSTRUCTIONS_BOND_END

  -- Assert state
  verifyOwnerOfHolding [(investor, investorBondHoldingCid), (investor, toInterfaceContractId investorCashTransferableCid)]

  pure (newBondInstrumentKey, coerceContractId investorBondHoldingCid)

lifecycleAndVerifySecondCouponEffectsAndSettlement : [Party] -> Date -> Instrument.K -> Party -> Party -> Party -> ContractId Transferable.I -> ContractId Transferable.I -> AccountKey -> AccountKey -> [(Text, Set Parties)] -> Party -> [ContractId Observable.I] -> Script Instrument.K
lifecycleAndVerifySecondCouponEffectsAndSettlement readAs today bondInstrument settler issuer investor investorBondTransferableCid custodianCashTransferableCid custodianAccount investorAccount obs custodian observableCids = do
  (bondLifecycleCid, [effectCid]) <- lifecycleBond readAs today bondInstrument settler issuer observableCids

  newBondInstrumentKey <- submitMulti [issuer] [] do
    Instrument.toKey <$> exerciseCmd @Instrument.I (coerceContractId bondLifecycleCid) Instrument.GetView with viewer = issuer

  -- Create settlement factory
  settlementFactoryCid <- submitMulti [investor] [] do createCmd Factory with provider = investor; observers = empty

  -- Claim effect
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submitMulti [custodian, investor] [] do
    createCmd Claim.Rule
      with
        custodian
        owner = investor
        claimers = singleton investor
        settler
        factoryCid = toInterfaceContractId settlementFactoryCid

  result <- submitMulti [investor] readAs do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = investor
      holdingCids = [toInterfaceContractId @Base.I investorBondTransferableCid]
      effectCid

  let
    [custodianCashInstructionCid] = result.instructionCids

  -- Allocate instructions
  custodianCashInstructionCid <- submitMulti [custodian] readAs do exerciseCmd custodianCashInstructionCid Instruction.Allocate with allocation = Pledge custodianCashTransferableCid

  -- Approve instructions
  custodianCashInstructionCid <- submitMulti [investor] [] do
    exerciseCmd custodianCashInstructionCid Instruction.Approve with approval = TakeDelivery investorAccount

  -- Settle batch
  [investorCashTransferableCid] <- submitMulti [settler] readAs do exerciseCmd result.batchCid Batch.Settle

  pure newBondInstrumentKey


lifecycleAndVerifyRedemptionEffectsAndSettlement : [Party] -> Date -> Instrument.K -> Party -> Party -> Party -> ContractId Transferable.I -> ContractId Transferable.I -> ContractId Transferable.I -> AccountKey -> AccountKey -> [(Text, Set Parties)] -> Party -> [ContractId Observable.I] -> Script Instrument.K
lifecycleAndVerifyRedemptionEffectsAndSettlement readAs today bondInstrument settler issuer investor investorBondTransferableCid custodianCashCouponTransferableCid custodianCashRedemptionTransferableCid custodianAccount investorAccount obs custodian observableCids = do
  (bondLifecycleCid, [effectCid]) <- lifecycleBond readAs today bondInstrument settler issuer observableCids

  newBondInstrumentKey <- submitMulti [issuer] [] do
    Instrument.toKey <$> exerciseCmd @Instrument.I (coerceContractId bondLifecycleCid) Instrument.GetView with viewer = issuer

  -- Create settlement factory
  settlementFactoryCid <- submitMulti [investor] [] do createCmd Factory with provider = investor; observers = empty

  -- Claim effect
  lifecycleClaimRuleCid <- toInterfaceContractId @Claim.I <$> submitMulti [custodian, investor] [] do
    createCmd Claim.Rule
      with
        custodian
        owner = investor
        claimers = singleton investor
        settler
        factoryCid = toInterfaceContractId settlementFactoryCid

  result <- submitMulti [investor] readAs do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = investor
      holdingCids = [toInterfaceContractId @Base.I investorBondTransferableCid]
      effectCid

  let [custodianCouponInstructionCid, custodianRedemptionInstructionCid] = result.instructionCids

  -- Allocate instructions
  custodianCouponInstructionCid <- submitMulti [custodian] [] do exerciseCmd custodianCouponInstructionCid Instruction.Allocate with allocation = Pledge custodianCashCouponTransferableCid
  custodianRedemptionInstructionCid <- submitMulti [custodian] [] do exerciseCmd custodianRedemptionInstructionCid Instruction.Allocate with allocation = Pledge custodianCashRedemptionTransferableCid

  -- Approve instructions
  custodianBondInstructionCid <- submitMulti [investor] [] do
    exerciseCmd custodianCouponInstructionCid Instruction.Approve with approval = TakeDelivery investorAccount
  custodianCashInstructionCid <- submitMulti [investor] [] do
    exerciseCmd custodianRedemptionInstructionCid Instruction.Approve with approval = TakeDelivery investorAccount

  -- Settle batch
  [investorCouponTransferableCid, investorRedemptionTransferableCid] <-
    submitMulti [settler] readAs do exerciseCmd result.batchCid Batch.Settle

  -- Assert state
  verifyOwnerOfHolding [(investor, investorCouponTransferableCid), (investor, investorRedemptionTransferableCid)]

  pure newBondInstrumentKey
