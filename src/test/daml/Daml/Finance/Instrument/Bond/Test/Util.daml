-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Finance.Instrument.Bond.Test.Util where

import DA.List (sort)
import DA.Map qualified as M (empty, fromList)
import DA.Set qualified as S (fromList, singleton)
import Daml.Finance.Claims.Lifecycle.ElectionRule qualified as Lifecycle (Rule(..))
import Daml.Finance.Instrument.Bond.Callable.Instrument qualified as Callable (Instrument(..))
import Daml.Finance.Instrument.Bond.FixedRate.Instrument qualified as FixedRate (Instrument(..))
import Daml.Finance.Instrument.Bond.FloatingRate.Instrument qualified as FloatingRate (Instrument(..))
import Daml.Finance.Instrument.Bond.InflationLinked.Instrument qualified as InflationLinked (Instrument(..))
import Daml.Finance.Instrument.Bond.ZeroCoupon.Instrument qualified as ZeroCoupon (Instrument(..))
import Daml.Finance.Interface.Claims.Types (Deliverable)
import Daml.Finance.Interface.Data.Reference.HolidayCalendar qualified as HolidayCalendar (I)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as BaseInstrument (I)
import Daml.Finance.Interface.Instrument.Bond.Callable.BondTypes (FloatingRate)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (GetView(..), I)
import Daml.Finance.Interface.Lifecycle.Election qualified as Election (Apply(..))
import Daml.Finance.Interface.Lifecycle.Election.Factory qualified as Election (Create(..), F)
import Daml.Finance.Interface.Lifecycle.Observable.NumericObservable qualified as NumericObservable (I)
import Daml.Finance.Interface.Types.Common.Types (Id(..), InstrumentKey, InstrumentQuantity, Parties)
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayConventionEnum)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum)
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule)
import Daml.Finance.Interface.Util.KeyTable (getKey)
import Daml.Finance.Lifecycle.Election qualified as Election (Factory(..))
import Daml.Finance.Test.Util.Instrument qualified as Instrument (buildKeyTable)
import Daml.Finance.Test.Util.Time (createPaymentPeriodicSchedule, dateToDateClockTime)
import Daml.Script

originateFixedRateBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  [Text] -> Party -> Date-> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal ->
  Script InstrumentKey
originateFixedRateBond depository issuer label description observers lastEventTimestamp issueDate
  holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency notional = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_FIXED_RATE_BOND_INSTRUMENT_BEGIN
    let
      instrument = FixedRate.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponRate; currency; notional
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_FIXED_RATE_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateCallableBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  [Text] -> Party -> Date -> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Optional FloatingRate -> Decimal -> Optional Decimal ->
  Optional Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal -> Script InstrumentKey
originateCallableBond depository issuer label description observers lastEventTimestamp issueDate
  holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention floatingRate couponRate capRate floorRate couponPeriod
  couponPeriodMultiplier currency notional = do
    let
      couponSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
      callSchedule = couponSchedule
      prevElections = []
    -- CREATE_CALLABLE_BOND_INSTRUMENT_BEGIN
    let
      instrument = Callable.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; prevElections; couponSchedule
        callSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; floatingRate
        couponRate; capRate; floorRate; currency; notional
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_CALLABLE_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateMultiScheduleCallableBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time ->
  [Text] -> Party -> DayCountConventionEnum -> Optional FloatingRate -> Decimal -> Optional Decimal
   -> Optional Decimal -> InstrumentKey -> Decimal -> PeriodicSchedule -> PeriodicSchedule
   -> Script InstrumentKey
originateMultiScheduleCallableBond depository issuer label description observers lastEventTimestamp
  holidayCalendarIds calendarDataProvider dayCountConvention floatingRate couponRate capRate
  floorRate currency notional couponSchedule callSchedule = do
    let prevElections = []
    -- CREATE_MULTI_SCHEDULE_CALLABLE_BOND_INSTRUMENT_BEGIN
    let
      instrument =
        Callable.Instrument with
          depository; issuer; id = Id label; version = "0"; description
          observers = M.fromList observers; lastEventTimestamp; prevElections; couponSchedule
          callSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; floatingRate
          couponRate; capRate; floorRate; currency; notional
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_MULTI_SCHEDULE_CALLABLE_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateZeroCouponBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  Date -> Deliverable -> Decimal ->
  Script InstrumentKey
originateZeroCouponBond depository issuer label description observers lastEventTimestamp issueDate
  maturityDate currency notional = do
    -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_BEGIN
    let
      instrument =
        ZeroCoupon.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; issueDate; maturityDate; currency
        notional
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_ZERO_COUPON_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateFloatingRateBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time -> Date ->
  [Text] -> Party -> Date -> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal ->
  Text -> Script InstrumentKey
originateFloatingRateBond depository issuer label description observers lastEventTimestamp issueDate
  holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponSpread couponPeriod couponPeriodMultiplier currency notional
  referenceRateId = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_BEGIN
    let
      instrument = FloatingRate.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponSpread; referenceRateId; currency; notional
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_FLOATING_RATE_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

originateInflationLinkedBond : Party -> Party -> Text -> Text -> [(Text, Parties)] -> Time ->
  Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum ->
  BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Decimal ->
  Text -> Decimal -> Script InstrumentKey
originateInflationLinkedBond depository issuer label description observers lastEventTimestamp
  issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention
  businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency notional
  inflationIndexId inflationIndexBaseValue = do
    let
      periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds
        businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
    -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_BEGIN
    let
      instrument = InflationLinked.Instrument with
        depository; issuer; id = Id label; version = "0"; description
        observers = M.fromList observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds
        calendarDataProvider; dayCountConvention; couponRate; inflationIndexId; currency; notional
        inflationIndexBaseValue
    submitMulti [depository, issuer] [] do createCmd instrument
    -- CREATE_INFLATION_LINKED_BOND_INSTRUMENT_END
    pure $ getKey $ toInterface @BaseInstrument.I instrument

-- | Verify the payments of an instrument after an election (excluding settlement)
electAndVerifyPaymentEffects : forall t1 t2.
  ( Template t1
  , HasAgreement t1
  , HasToInterface t1 BaseInstrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  )
  => Date -> Decimal -> InstrumentKey -> Bool -> Party -> Party -> [Party]
  -> Text -> [ContractId NumericObservable.I] -> [InstrumentQuantity] -> [InstrumentQuantity]
  -> Script (Optional InstrumentKey, ContractId Effect.I)
electAndVerifyPaymentEffects today amount instrument electorIsOwner issuer elector readAs
  electedTag observableCids expectedConsumedQuantities expectedProducedQuantities = do

    -- Create election factory to allow holders to create elections
    electionFactoryCid <- submit issuer do
      toInterfaceContractId @Election.F <$> createCmd Election.Factory with
        provider = issuer
        observers = M.fromList [("Observers", S.fromList [elector, issuer])]

    -- Create a lifecycle rule
    lifecycleRuleCid <- toInterfaceContractId <$> submit issuer do
      createCmd Lifecycle.Rule with
        providers = S.singleton issuer
        observers = M.empty
        lifecycler = issuer
        id = Id "LifecycleRule"
        description = "Rule to lifecycle an Election based instrument"

    -- Apply election to generate new instrument version + effects
    let
      counterparty = issuer
      description = "election for a callable bond"
    exerciseOptionCid <- submit elector do
      exerciseCmd electionFactoryCid Election.Create with
        actors = S.singleton elector
        id = Id "election id"
        description
        claim = electedTag
        electionTime = dateToDateClockTime today
        electorIsOwner
        elector
        counterparty
        instrument
        amount
        observers = M.fromList [("Holders", S.fromList [issuer, elector, counterparty])]
        provider = issuer

    -- Build key table
    keyTable <- Instrument.buildKeyTable @t1 @t2 [issuer] instrument

    -- Apply election
    (newInstrumentKey, [effectCid]) <- submitMulti [issuer] readAs do
      fst <$> exerciseCmd exerciseOptionCid Election.Apply with
        observableCids
        exercisableCid = lifecycleRuleCid
        keyTable

    -- Get the effect
    effectView <- submit issuer do
      exerciseCmd effectCid Effect.GetView with viewer = issuer

    -- Verify that the consumed/produced quantities match the expected ones
    assertMsg "The consumed quantities do not match the expected ones" $
      sort expectedConsumedQuantities == sort effectView.otherConsumed
    assertMsg "The produced quantities do not match the expected ones" $
      sort expectedProducedQuantities == sort effectView.otherProduced

    pure (newInstrumentKey, effectCid)
