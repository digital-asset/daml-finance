-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Equity.Test.CashDividend where

import DA.Date (toDateUTC)
import DA.Map qualified as M (empty, fromList)
import DA.Set (singleton)
import Daml.Finance.Asset.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Asset.Test.Util.Account qualified as Account (createAccount, createFactory, credit)
import Daml.Finance.Asset.Test.Util.Holding qualified as Holding (verifyOwnerOfHolding)
import Daml.Finance.Asset.Test.Util.Instrument (originate)
import Daml.Finance.Asset.Test.Util.Instrument qualified as Instrument (submitExerciseInterfaceByKeyCmd)
import Daml.Finance.Equity.Test.Util (originateEquity)
import Daml.Finance.Interface.Asset.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Equity.Instrument qualified as Equity (Distribution(..), I)
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I)
import Daml.Finance.Interface.Lifecycle.Lifecyclable qualified as Lifecyclable (I, Lifecycle(..))
import Daml.Finance.Interface.Lifecycle.SettlementRule qualified as SettlementRule (Claim(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Settleable qualified as Settleable (Settle(..))
import Daml.Finance.Lifecycle.SettlementRule (Rule(..))
import Daml.Finance.RefData.Time.DateClock (DateClock(..), Unit(..))
import Daml.Finance.Settlement.Batch (BatchFactory(..))
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Script

-- Cash dividend lifecycling and settlement
run : Script ()
run = script do
  -- Create parties
  [cb, depository, bank, issuer, investor, settler, provider, publicParty] <-
    createParties ["CentralBank", "CSD", "Bank", "Issuer", "Investor", "Settler", "Provider", "PublicParty"]

  -- Account and holding factory
  let pp = [("factoryProvider", singleton $ singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory provider pp
  holdingFactoryCid <- toInterfaceContractId <$> submitMulti [provider] [] do
    createCmd Fungible.Factory with provider; observers = M.fromList pp

  -- Create accounts
  [bankAccount, investorAccount] <- mapA (Account.createAccount [publicParty] accountFactoryCid holdingFactoryCid [] bank) [bank, investor]

  -- Distribute assets
  now <- getTime
  let obs = [("public party", singleton $ singleton publicParty)]
  equityInstrument <- originateEquity depository issuer "AAPL" "0" obs now
  investorEquityTransferableCid <- Account.credit [publicParty] equityInstrument 1_000.0 investorAccount
  cashInstrument <- originate cb issuer "USD" obs now
  bankCashTransferableCid <- Account.credit [publicParty] cashInstrument 2_000.0 bankAccount

  -- Originate new equity version
  equityInstrument2 <- originateEquity depository issuer "AAPL" "1" [] now

  -- Create cash dividend
  cashDividendCid <- Instrument.submitExerciseInterfaceByKeyCmd @Equity.I [bank, issuer] [publicParty] equityInstrument Equity.Distribution
    with
      id = "CASHDIV"
      perUnitDistribution = [Instrument.qty 2.0 cashInstrument]
      effectiveDate = toDateUTC now
      newInstrument = equityInstrument2
  let
    eventCid : ContractId Event.I = coerceContractId cashDividendCid
    lifecyclableCid : ContractId Lifecyclable.I = coerceContractId cashDividendCid

  -- Create clock
  clockCid <- toInterfaceContractId <$> submitMulti [issuer] [] do createCmd DateClock with u = Unit $ toDateUTC now; id = "Date clock"; provider = issuer; observers = M.empty

  -- Lifecycle cash dividend
  (_, [effectCid]) <- submitMulti [issuer] [] do exerciseCmd lifecyclableCid Lifecyclable.Lifecycle with ruleName = "Dividend"; settler; observableCids = []; eventCid; clockCid

  -- Create settlement factory and rule to claim effects
  factoryCid <- submitMulti [investor] [] do createCmd BatchFactory with requestors = singleton investor

  settlementRuleCid <- submitMulti [bank, investor] [] do
    createCmd Rule
      with
        custodian = bank
        owner = investor
        claimers = singleton investor
        settler
        instrumentLabel = "AAPL"
        instructableCid = toInterfaceContractId factoryCid

  -- Claim effect
  result <- submitMulti [investor] [publicParty] do
    exerciseCmd settlementRuleCid SettlementRule.Claim with
      claimer = investor
      holdingCids = [investorEquityTransferableCid]
      effectCid

  let
    Some [investorEquityTransferableCid] = result.newInstrumentHoldingCids
    [issuerCashInstructionCid] = result.instructionCids

  -- Allocate instructions
  bankCashInstructionCid <- submitMulti [bank] [] do exerciseCmd issuerCashInstructionCid Instruction.Allocate with transferableCid = bankCashTransferableCid

  -- Approve instructions
  bankCashInstructionCid <- submitMulti [investor] [] do exerciseCmd bankCashInstructionCid Instruction.Approve with receiverAccount = investorAccount

  -- Settle container
  [investorCashTransferableCid] <- submitMulti [settler] [] do exerciseCmd result.containerCid Settleable.Settle

  -- Assert state
  Holding.verifyOwnerOfHolding [(investor, investorEquityTransferableCid), (investor, coerceContractId investorCashTransferableCid)]

  pure ()
