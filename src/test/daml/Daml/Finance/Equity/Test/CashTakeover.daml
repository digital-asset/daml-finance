-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Equity.Test.CashTakeover where

import DA.Date (toDateUTC)
import DA.Map qualified as M (empty, fromList)
import DA.Set (empty, singleton)
import Daml.Finance.Asset.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Asset.Test.Util.Account qualified as Account (createAccount, createFactory, credit)
import Daml.Finance.Asset.Test.Util.Holding qualified as Holding (verifyOwnerOfHolding)
import Daml.Finance.Asset.Test.Util.Instrument (originate)
import Daml.Finance.Asset.Test.Util.Instrument qualified as Instrument (submitExerciseInterfaceByKeyCmd)
import Daml.Finance.Equity.Test.Util (originateEquity)
import Daml.Finance.Interface.Asset.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Equity.Instrument qualified as Equity (I, Replacement(..))
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I)
import Daml.Finance.Interface.Lifecycle.Lifecyclable qualified as Lifecyclable (I, Lifecycle(..))
import Daml.Finance.Interface.Lifecycle.SettlementRule qualified as SettlementRule (Claim(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Settleable qualified as Settleable (Settle(..))
import Daml.Finance.Lifecycle.SettlementRule (Rule(..))
import Daml.Finance.RefData.Time.DateClock as Clock (DateClock(..), Unit(..))
import Daml.Finance.Settlement.Batch (BatchFactory(..))
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Script

-- Cash takeover lifecycling and settlement
run : Script ()
run = script do
  -- Create parties
  [cb, depository, bank, issuer, buyer, investor, settler, publicParty] <-
    createParties ["CentralBank", "CSD", "Bank", "Issuer", "Buyer", "Investor", "Settler", "PublicParty"]

  -- Account and holding factory
  let pp = [("PublicParty", singleton $ singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory bank pp
  holdingFactoryCid <- toInterfaceContractId <$> submit bank do
    createCmd Fungible.Factory with provider = bank; observers = M.fromList pp

  -- Create accounts
  [bankAccount, investorAccount] <- mapA (Account.createAccount [publicParty] accountFactoryCid holdingFactoryCid [] bank) [bank, investor]

  -- Distribute assets
  now <- getTime
  equityInstrument <- originateEquity depository issuer "AAPL" "0" pp now
  investorEquityTransferableCid <- Account.credit [publicParty] equityInstrument 1_000.0 investorAccount
  cashInstrument <- originate cb issuer "USD" pp now
  bankCashTransferableCid <- Account.credit [publicParty] cashInstrument 50_000.0 bankAccount

  -- Create takeover
  takeoverCid <- Instrument.submitExerciseInterfaceByKeyCmd @Equity.I [bank, issuer, buyer] [publicParty] equityInstrument Equity.Replacement with
      id = "TAKEOVER"
      offerer = buyer
      perUnitPayout = [Instrument.qty 50.0 cashInstrument]
      effectiveDate = toDateUTC now
  let
    eventCid : ContractId Event.I = coerceContractId takeoverCid
    lifecyclableCid : ContractId Lifecyclable.I = coerceContractId takeoverCid

  -- Create clock
  clockCid <- toInterfaceContractId <$> submitMulti [buyer] [] do createCmd DateClock with u = Clock.Unit $ toDateUTC now; id = "Date clock"; provider = buyer; observers = M.empty

  -- Lifecycle takeover
  (_, [effectCid]) <- submitMulti [buyer] [] do exerciseCmd lifecyclableCid Lifecyclable.Lifecycle with ruleName = "Takeover"; settler; eventCid; observableCids = []; clockCid

  -- Create settlement factory
  factoryCid <- submitMulti [investor] [] do createCmd BatchFactory with provider = investor; observers = empty

  -- Claim effect
  ruleCid <- submitMulti [bank, investor] [] do
    createCmd Rule
      with
        custodian = bank
        owner = investor
        claimers = singleton investor
        settler
        instrumentLabel = "AAPL"
        instructableCid = toInterfaceContractId factoryCid

  result <- submitMulti [investor] [publicParty] do
    exerciseCmd ruleCid SettlementRule.Claim with
      claimer = investor
      holdingCids = [investorEquityTransferableCid]
      effectCid

  let
    [bankCashInstructionCid] = result.instructionCids

  -- Allocate instructions
  bankCashInstructionCid <- submitMulti [bank] [] do exerciseCmd bankCashInstructionCid Instruction.Allocate with transferableCid = bankCashTransferableCid

  -- Approve instructions
  bankCashInstructionCid <- submitMulti [investor] [] do exerciseCmd bankCashInstructionCid Instruction.Approve with receiverAccount = investorAccount

  -- Settle container
  [investorCashTransferableCid] <- submitMulti [settler] [publicParty] do exerciseCmd result.containerCid Settleable.Settle

  -- Assert state
  Holding.verifyOwnerOfHolding [(investor, investorCashTransferableCid)]

  pure ()
