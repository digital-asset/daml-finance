-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Finance.Test.Util.Common where

import DA.Assert ((===))
import DA.Exception (throw)
import DA.List (head)
import Daml.Finance.Interface.Util.Index qualified as Index (HasIndexTable(..), getKey)
import Daml.Script

-- | Create parties
createParties : [Text] -> Script [Party]
createParties names = mapA createParty names where
  createParty name = allocatePartyWithHint name $ PartyIdHint name

-- | This exception is used in tests where we expect an exception but it doesn't throw and this gets
-- thrown instead. This allows for ensuring an exception was fired and if not, we can rethrow to
-- show that the expected behaviour was not observed.
exception TestFailureException
  with
    text : Text
  where
    message "TestFailureException(text=" <> text <> ")"

-- | Takes a 'Script a' that is expected to throw a 'AssertionFailed' exception, catches said
-- exception and then validates its message. If the exception message from the 'AssertFailed'
-- exception does not match the expected failure message, then the test is failed. If the
-- 'Script a' does not fail, a 'TestFailureException' is thrown which in turn is caught and
-- rethrown thusly failing the test.
validateAssertionFailure : Script a -> Text -> Script ()
validateAssertionFailure assertion expectedFailureMessage =
  try do
    assertion
    throw TestFailureException with
      text = "Expected test failure succeeded - expectedFailureMessage=" <> expectedFailureMessage
  catch
    (AssertionFailed msg) -> msg === expectedFailureMessage
    myTestException@(TestFailureException _) -> assertFail $ show myTestException

-- | Utility function for querying by key.
queryByKey :
  forall t i v k p. (Index.HasIndexTable i k, Template t, HasAgreement t, IsParties p,
  HasToInterface t i, HasInterfaceView i v, Eq k) =>
  p -> k -> Script (ContractId i, v)
queryByKey actors k = do
  (cid, t) <- head <$> queryFilter @t actors \t -> ((Index.getKey @i $ toInterface @i t) == k)
  pure (toInterfaceContractId @i cid, view $ toInterface @i t)
