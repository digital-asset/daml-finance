-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Test.Util.Holding where

import DA.Assert ((===))
import DA.Map (empty)
import Daml.Finance.Interface.Holding.Base qualified as Base (I, GetView(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey(..))
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, GetView(..))
import Daml.Finance.Interface.Util.SyntheticKey (KeyTable(..))
import Daml.Finance.Test.Util.Account qualified as Account (buildKeyTable)
import Daml.Script

-- | Verify that a party is the owner of a holding.
verifyOwnerOfHolding : (HasToInterface a Base.I, HasToInterface a Disclosure.I) =>
  [(Party, ContractId a)] -> Script [()]
verifyOwnerOfHolding l = forA l
  \(owner, holdingCid) -> do
    v <- submit owner do
      exerciseCmd (toInterfaceContractId @Base.I holdingCid) Base.GetView with viewer = owner
    v.account.owner === owner

-- | Verify that a party is the owner of a holding and that the holding has the expected amount.
verifyOwnerAndAmountOfHolding : (HasToInterface a Base.I, HasToInterface a Disclosure.I) =>
  [(Party, Decimal, ContractId a)] -> Script [()]
verifyOwnerAndAmountOfHolding l = forA l
  \(owner, amount, holdingCid) -> do
    v <- submit owner do
      exerciseCmd (toInterfaceContractId @Base.I holdingCid) Base.GetView with viewer = owner
    v.account.owner === owner
    v.amount === amount

-- | Verify that a holding has no observers.
verifyNoObservers : (HasToInterface a Disclosure.I) => [(Party, ContractId a)] -> Script [()]
verifyNoObservers l = forA l
  \(owner, holdingCid) -> do
    v <- submit owner do
      exerciseCmd (toInterfaceContractId @Disclosure.I holdingCid)
        Disclosure.GetView with viewer = owner
    v.observers === empty

-- | Build key table (from a holding). The table includes the holding's account.
buildKeyTable : (IsParties p) => p -> ContractId Base.I -> Script KeyTable
buildKeyTable actors cid = do
  Some account <- fmap (.account) <$> queryInterfaceContractId @Base.I actors cid
  Account.buildKeyTable actors account

-- | Build key table (from a transfer).
buildKeyTableForTransfer :
  (IsParties p) => p -> ContractId Base.I -> AccountKey -> Script KeyTable
buildKeyTableForTransfer actors holdingToBeTransferredCid receivingAccount = do
  idxs1 <- buildKeyTable actors holdingToBeTransferredCid
  idxs2 <- Account.buildKeyTable actors receivingAccount
  pure $ mconcat [idxs1, idxs2]
