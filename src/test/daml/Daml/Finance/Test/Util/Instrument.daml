-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Finance.Test.Util.Instrument where

import DA.Map qualified as M
import Daml.Finance.Instrument.Token.Instrument (Instrument(..))
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (I)
import Daml.Finance.Interface.Types.Common.Types (Id(..), InstrumentKey, Parties)
import Daml.Finance.Interface.Util.Index qualified as Index (IndexTable(..), getKey, insert)
import Daml.Finance.Test.Util.Common (queryByKey)
import Daml.Script

-- | Originate an `Instrument`.
originate : Party -> Party -> Text -> Text-> [(Text, Parties)] -> Time -> Script InstrumentKey
originate depository issuer label description observers timestamp = do
  let
    instrument = Instrument with
      depository; issuer; id = Id label; version = "0"; description
      observers = M.fromList observers; validAsOf = timestamp
  cid <- toInterfaceContractId @Instrument.I <$> submitMulti [depository, issuer] [] do
    createCmd instrument
  pure $ Index.getKey @Instrument.I $ toInterface @Instrument.I instrument

-- | Build index table (from an instrument).
buildIndexTable :
  forall t p. (HasAgreement t, Template t, HasToInterface t Instrument.I, IsParties p) =>
  p -> InstrumentKey -> Script Index.IndexTable
buildIndexTable actors instrument = do
  instrumentCid <- fst <$> queryByKey @t @Instrument.I actors instrument
  pure $ Index.insert instrument instrumentCid M.empty
