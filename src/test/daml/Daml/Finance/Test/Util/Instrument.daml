-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Finance.Test.Util.Instrument where

import DA.Action (foldlA)
import DA.List (sort)
import DA.Map qualified as M
import DA.Set (empty, singleton, toList)
import Daml.Finance.Claims.Lifecycle.Rule (Rule(..))
import Daml.Finance.Instrument.Token.Instrument (Instrument(..))
import Daml.Finance.Interface.Claims.Dynamic.Instrument qualified as DynamicInstrument (I, getHolidayCalendarKeys)
import Daml.Finance.Interface.Data.Reference.HolidayCalendar qualified as HolidayCalendar (I)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (I)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I, GetView(..))
import Daml.Finance.Interface.Lifecycle.Observable.NumericObservable qualified as NumericObservable (I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (I, Evolve(..))
import Daml.Finance.Interface.Types.Common.Types (Id(..), InstrumentKey, InstrumentQuantity, Parties)
import Daml.Finance.Interface.Util.SyntheticKey (IndexTable(..), getKey, insert)
import Daml.Finance.Test.Util.Common (queryAnyByKey)
import Daml.Finance.Test.Util.Time (createClockUpdateEvent)
import Daml.Script

-- | Originate an `Instrument`.
originate : Party -> Party -> Text -> Text-> [(Text, Parties)] -> Time -> Script InstrumentKey
originate depository issuer label description observers timestamp = do
  let
    instrument = Instrument with
      depository; issuer; id = Id label; version = "0"; description
      observers = M.fromList observers; validAsOf = timestamp
  cid <- toInterfaceContractId @Instrument.I <$> submitMulti [depository, issuer] [] do
    createCmd instrument
  pure $ getKey @Instrument.I $ toInterface @Instrument.I instrument

-- | Lifecycle the instrument as of this date. This is a general function that can be used for
-- different kinds of dynamic instruments.
lifecycleInstrument :
  forall t t2.
  ( Template t
  , HasAgreement t
  , HasToInterface t DynamicInstrument.I
  , HasToInterface t Instrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  ) => [Party] -> Date -> InstrumentKey -> Party -> [ContractId NumericObservable.I] ->
  Script (Optional InstrumentKey, [ContractId Effect.I])
lifecycleInstrument readAs today instrument issuer observableCids = do
  -- Create a clock update event
  clockEventCid <- createClockUpdateEvent (singleton issuer) today empty
  -- Create a lifecycle rule
  lifecycleRuleCid <- toInterfaceContractId @Lifecycle.I <$> submit issuer do
    createCmd Rule with
      providers = singleton issuer
      observers= M.empty
      lifecycler = issuer
      id = Id "LifecycleRule"
      description = "Rule to lifecycle an instrument"
  -- Build index table
  idx <- buildIndexTable @t @t2 [issuer] instrument
  -- Try to lifecycle the instrument
  (lifecycleCid, effectCids) <- submitMulti [issuer] readAs do
    fst <$> exerciseCmd lifecycleRuleCid Lifecycle.Evolve with
      eventCid = clockEventCid
      observableCids
      instrument
      idx
  pure (lifecycleCid, effectCids)

-- | Verify that there are no lifecycle effects of the dynamic instrument on this date.
verifyNoLifecycleEffects :
  forall t t2.
  ( Template t
  , HasAgreement t
  , HasToInterface t DynamicInstrument.I
  , HasToInterface t Instrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  ) => [Party] -> Date -> InstrumentKey -> Party -> [ContractId NumericObservable.I] -> Script ()
verifyNoLifecycleEffects readAs today instrument issuer observableCids = do
  (_, effectCids) <- lifecycleInstrument @t @t2 readAs today instrument issuer observableCids
  assertMsg ("There should be no lifecycle effects on " <> show today) (null effectCids)

-- | Verify the payments from a payment date of a dynamic instrument (excluding settlement).
lifecycleAndVerifyPaymentEffects :
  forall t t2.
  ( Template t
  , HasAgreement t
  , HasToInterface t DynamicInstrument.I
  , HasToInterface t Instrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  ) => [Party]  -> Date -> InstrumentKey -> Party -> [ContractId NumericObservable.I] ->
  [InstrumentQuantity] -> [InstrumentQuantity] -> Script (Optional InstrumentKey)
lifecycleAndVerifyPaymentEffects readAs today instrument issuer
  observableCids expectedConsumedQuantities expectedProducedQuantities = do
    (newInstrumentKey, [effectCid]) <-
      lifecycleInstrument @t @t2 readAs today instrument issuer observableCids
    -- Get the effect
    effectView <- submit issuer do
      exerciseCmd effectCid Effect.GetView with viewer = issuer
    -- Verify that the consumed/produced quantities match the expected ones
    assertMsg "The consumed quantities do not match the expected ones" $
      sort expectedConsumedQuantities == sort effectView.otherConsumed
    assertMsg "The produced quantities do not match the expected ones" $
      sort expectedProducedQuantities == sort effectView.otherProduced
    pure newInstrumentKey

-- | Build index table (from an instrument).
buildIndexTable :
  forall t t2 p.
  ( Template t
  , HasAgreement t
  , HasToInterface t Instrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  , IsParties p
  ) => p -> InstrumentKey -> Script IndexTable
buildIndexTable actors instrument = do
  (iCid, i) <- queryAnyByKey @t @Instrument.I actors instrument
  let idx = insert instrument iCid mempty
  -- adding holiday calendar
  case fromInterface @DynamicInstrument.I i of
    None -> pure idx
    Some dynamicInstrument -> foldlA
      (\idx h -> do
        iCid <- fst <$> queryAnyByKey @t2 @HolidayCalendar.I h.provider h
        pure $ insert h iCid idx
      )
      idx
      (toList $ DynamicInstrument.getHolidayCalendarKeys dynamicInstrument)
