-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Finance.Test.Util.Account where

import DA.Assert ((===))
import DA.Map qualified as M (empty, fromList)
import DA.Set qualified as S (empty, fromList, singleton)
import Daml.Finance.Account.Account qualified as Account (Factory(..), T)
import Daml.Finance.Interface.Account.Account qualified as Account (Controllers(..), Credit(..), Debit(..), I)
import Daml.Finance.Interface.Account.Factory qualified as Account (Create(..), F)
import Daml.Finance.Interface.Holding.Base qualified as Holding (GetView(..), I)
import Daml.Finance.Interface.Holding.Factory qualified as Holding (F)
import Daml.Finance.Interface.Types.Common.Types (Id(..), AccountKey(..), InstrumentKey, Parties)
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Interface.Util.Index qualified as Index (IndexTable(..), insert)
import Daml.Finance.Test.Util.Common (queryByKey)
import Daml.Script

-- | Options for transfer controllers.
data ControlledBy
  = Owner
    -- ^ Owner controls inbound and outbound transfers.
  | Custodian
    -- ^ Custodian controls inbound and outbound transfers.
  | OwnerAndCustodian
    -- ^ Owner and custodian jointly control inbound and outbound transfers.
  | OwnerWithAutoApproval
    -- ^ Owner controls outbound transfers, and inbound transfers are auto-approved.
  deriving (Eq, Show)

-- | Get account controllers depending on controlledBy.
toControllers : Party -> Party -> ControlledBy -> Account.Controllers
toControllers custodian owner controlledBy =
  case controlledBy of
    Owner -> Account.Controllers with
      outgoing = S.singleton owner; incoming = S.singleton owner
    Custodian -> Account.Controllers with
      outgoing = S.singleton custodian; incoming = S.singleton custodian
    OwnerAndCustodian -> Account.Controllers with
      outgoing = S.fromList [owner, custodian]; incoming = S.fromList [owner, custodian]
    OwnerWithAutoApproval -> Account.Controllers with
      outgoing = S.singleton owner; incoming = S.empty

-- | Create factory for `Account`.
createFactory : Party -> [(Text, Parties)] -> Script (ContractId Account.Factory)
createFactory provider observers = submit provider do
  createCmd Account.Factory with provider; observers = M.fromList observers

-- | Create `Account`.
createAccount : Text -> [Party] -> ContractId Account.F -> ContractId Holding.F ->
  [(Text, Parties)] -> ControlledBy -> Party -> Party -> Script AccountKey
createAccount description readAs factoryCid holdingFactoryCid
  observers controlledBy custodian owner = do
    let
      account = AccountKey with
        custodian; owner; id = Id $ show owner <> "@" <> show custodian <> "/" <> description
    submitMulti [custodian, owner] readAs do
      exerciseCmd factoryCid Account.Create with
        account; holdingFactoryCid; controllers = toControllers custodian owner controlledBy
        observers = M.fromList observers; description
    pure account

-- | Credit an `Account`.
credit : [Party] -> InstrumentKey -> Decimal -> AccountKey -> Script (ContractId Holding.I)
credit readAs instrument amount account = do
  accountCid <- fst <$> queryByKey @Account.T @Account.I [account.custodian, account.owner] account
  submitMulti [account.custodian, account.owner] readAs do
    exerciseCmd accountCid Account.Credit with quantity = qty amount instrument

-- | Debit an `Account`.
debit : [Party] -> Party -> ContractId Holding.I -> Script ()
debit readAs holder holdingCid = do
  v <- submit holder do exerciseCmd holdingCid Holding.GetView with viewer = holder
  v.account.owner === holder
  accountCid <- fst <$> queryByKey @Account.T @Account.I [v.account.custodian, holder] v.account
  submitMulti [v.account.custodian, holder] readAs do
    exerciseCmd accountCid Account.Debit with holdingCid

-- | Build index table (from an account).
buildIndexTable : IsParties p => p -> AccountKey -> Script Index.IndexTable
buildIndexTable actors account = do
  accountCid <- fst <$> queryByKey @Account.T @Account.I actors account
  pure $ Index.insert account accountCid M.empty
