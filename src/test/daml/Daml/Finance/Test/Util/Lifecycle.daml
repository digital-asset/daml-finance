-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Finance.Test.Util.Lifecycle where

import DA.Action (foldlA)
import DA.List (sort)
import DA.Map qualified as M (empty, fromList)
import DA.Set qualified as S (empty, fromList, singleton, toList)
import Daml.Finance.Claims.Lifecycle.Rule (Rule(..))
import Daml.Finance.Claims.Lifecycle.Rule qualified as Lifecycle (Rule(..))
import Daml.Finance.Interface.Claims.Dynamic.Instrument qualified as DynamicInstrument (I, getHolidayCalendarKeys)
import Daml.Finance.Interface.Data.Reference.HolidayCalendar qualified as HolidayCalendar (I)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as BaseInstrument (I)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (GetView(..), I)
import Daml.Finance.Interface.Lifecycle.Election qualified as Election (Apply(..), Exercisable, I)
import Daml.Finance.Interface.Lifecycle.Election.Factory qualified as Election (Create(..), F)
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I, getInstrumentKeys)
import Daml.Finance.Interface.Lifecycle.Observable.NumericObservable qualified as NumericObservable (I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (Evolve(..), I)
import Daml.Finance.Interface.Types.Common.Types (Id(..), InstrumentKey, InstrumentQuantity)
import Daml.Finance.Interface.Util.KeyTable (KeyTable, insert)
import Daml.Finance.Lifecycle.Election qualified as Election (Factory(..))
import Daml.Finance.Test.Util.Common (queryAnyByKey)
import Daml.Finance.Test.Util.Time (createClockUpdateEvent, dateToDateClockTime)
import Daml.Script

-- | Lifecycle the instrument as of this date. This is a general function that can be used for
-- different kinds of instruments.
lifecycleInstrument : forall t1 t2 t3.
  ( Template t1
  , HasAgreement t1
  , HasToInterface t1 BaseInstrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  , HasAgreement t3
  , HasTemplateTypeRep t3
  , HasToAnyTemplate t3
  , HasFromAnyTemplate t3
  , HasFromInterface t3 Event.I
  , HasToInterface t3 Event.I
  ) => [Party] -> Date -> InstrumentKey -> Party -> [ContractId NumericObservable.I] ->
  Script (Optional InstrumentKey, [ContractId Effect.I])
lifecycleInstrument readAs today instrument issuer observableCids = do
  -- Create a clock update event
  clockEventCid <- createClockUpdateEvent (S.singleton issuer) today S.empty

  -- Create a lifecycle rule
  lifecycleRuleCid <- toInterfaceContractId @Lifecycle.I <$> submit issuer do
    createCmd Rule with
      providers = S.singleton issuer
      observers= M.empty
      lifecycler = issuer
      id = Id "LifecycleRule"
      description = "Rule to lifecycle an instrument"

  -- Build key table
  keyTable <- buildKeyTableForLifecycleEvolve @t1 @t2 @t3 [issuer] clockEventCid instrument

  -- Try to lifecycle the instrument
  (lifecycleCid, effectCids) <- submitMulti [issuer] readAs do
    fst <$> exerciseCmd lifecycleRuleCid Lifecycle.Evolve with
      eventCid = clockEventCid
      observableCids
      instrument
      keyTable

  pure (lifecycleCid, effectCids)

-- | Verify that the consumed/produced quantities match the expected ones.
verifyConsumedAndProduced : [InstrumentQuantity] -> [InstrumentQuantity] -> ContractId Effect.I
  -> Party -> Script ()
verifyConsumedAndProduced expectedConsumed expectedProduced effectCid
  issuer = do
    -- Get the effect
    effectView <- submit issuer do
      exerciseCmd effectCid Effect.GetView with viewer = issuer

    -- Sort the instrument quantities for a more robust comparison
    let
      sortedConsumed = sort effectView.otherConsumed
      sortedProduced = sort effectView.otherProduced
      sortedExpectedConsumed = sort expectedConsumed
      sortedExpectedProduced = sort expectedProduced

    assertMsg ("The consumed quantities " <> show sortedConsumed <>
      " do not match the expected ones " <> show sortedExpectedConsumed) $
      sortedExpectedConsumed == sortedConsumed
    assertMsg ("The produced quantities " <> show sortedProduced <>
      " do not match the expected ones " <> show sortedExpectedProduced) $
      sortedExpectedProduced == sortedProduced

-- | Verify a that there are no lifecycle effects of the instrument on this date.
verifyNoLifecycleEffects : forall t1 t2 t3.
  ( Template t1
  , HasAgreement t1
  , HasToInterface t1 BaseInstrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  , HasAgreement t3
  , HasTemplateTypeRep t3
  , HasToAnyTemplate t3
  , HasFromAnyTemplate t3
  , HasFromInterface t3 Event.I
  , HasToInterface t3 Event.I
  ) => [Party] -> Date -> InstrumentKey -> Party -> [ContractId NumericObservable.I] ->
  Script (Optional InstrumentKey)
verifyNoLifecycleEffects readAs today instrument issuer observableCids = do
  (newInstrumentKey, effectCids) <- lifecycleInstrument @t1 @t2 @t3 readAs today instrument issuer
    observableCids
  assertMsg ("There should be no lifecycle effects on " <> show today) (null effectCids)
  pure newInstrumentKey

-- | Verify the payments from a payment date of an instrument (excluding settlement)
lifecycleAndVerifyPaymentEffects : forall t1 t2 t3.
  ( Template t1
  , HasAgreement t1
  , HasToInterface t1 BaseInstrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  , HasAgreement t3
  , HasTemplateTypeRep t3
  , HasToAnyTemplate t3
  , HasFromAnyTemplate t3
  , HasFromInterface t3 Event.I
  , HasToInterface t3 Event.I
  ) => [Party] -> Date -> InstrumentKey -> Party ->
  [ContractId NumericObservable.I] -> [InstrumentQuantity] -> [InstrumentQuantity] ->
  Script (Optional InstrumentKey)
lifecycleAndVerifyPaymentEffects readAs today instrument issuer
  observableCids expectedConsumed expectedProduced = do
    (newInstrumentKey, [effectCid]) <-
      lifecycleInstrument @t1 @t2 @t3 readAs today instrument issuer observableCids

    -- Verify that the consumed/produced quantities match the expected ones
    verifyConsumedAndProduced expectedConsumed expectedProduced effectCid issuer

    pure newInstrumentKey

-- | Create the Election and the lifecycle rule.
createElectionAndLifecycleRule : Date -> Decimal -> InstrumentKey -> Bool -> Party -> Party -> Text
  -> Script (ContractId Election.I, ContractId Election.Exercisable)
createElectionAndLifecycleRule today amount instrument electorIsOwner issuer elector electedTag = do
  -- Create election factory to allow holders to create elections
  electionFactoryCid <- submit issuer do
    toInterfaceContractId @Election.F <$> createCmd Election.Factory with
      provider = issuer
      observers = M.fromList [("Observers", S.fromList [elector, issuer])]

  -- Create a lifecycle rule
  lifecycleRuleCid <- toInterfaceContractId <$> submit issuer do
    createCmd Lifecycle.Rule with
      providers = S.singleton issuer
      observers = M.empty
      lifecycler = issuer
      id = Id "LifecycleRule"
      description = "Rule to lifecycle an Election based instrument"

  -- Create the Election
  let
    counterparty = issuer
    description = "election for a callable bond"
  electionCid <- submit elector do
    exerciseCmd electionFactoryCid Election.Create with
      actors = S.singleton elector
      id = Id "election id"
      description
      claim = electedTag
      electionTime = dateToDateClockTime today
      electorIsOwner
      elector
      counterparty
      instrument
      amount
      observers = M.fromList [("Holders", S.fromList [issuer, elector, counterparty])]
      provider = issuer

  pure (electionCid, lifecycleRuleCid)

-- | Apply an election and verify that the election effect matches the expected result.
applyElectionAndVerify : forall t1 t2.
  ( Template t1
  , HasAgreement t1
  , HasToInterface t1 BaseInstrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  )
  => InstrumentKey -> Party -> [Party] -> [ContractId NumericObservable.I] ->
  [InstrumentQuantity] -> [InstrumentQuantity] -> ContractId Election.I ->
  ContractId Election.Exercisable -> Script (Optional InstrumentKey, ContractId Effect.I)
applyElectionAndVerify instrument issuer readAs observableCids
  expectedConsumed expectedProduced electionCid
  lifecycleRuleCid = do
    -- Build key table
    keyTable <- buildKeyTableForElectionApply @t1 @t2 [issuer] instrument

    -- Apply election to generate new instrument version + effects
    (newInstrumentKey, [effectCid]) <- submitMulti [issuer] readAs do
       fst <$> exerciseCmd electionCid Election.Apply with
        observableCids
        exercisableCid = lifecycleRuleCid
        keyTable

    -- Verify that the consumed/produced quantities match the expected ones
    verifyConsumedAndProduced expectedConsumed expectedProduced effectCid issuer

    pure (newInstrumentKey, effectCid)

-- | Verify the payments of an instrument after an election (excluding settlement).
electAndVerifyPaymentEffects : forall t1 t2.
  ( Template t1
  , HasAgreement t1
  , HasToInterface t1 BaseInstrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  )
  => Date -> Decimal -> InstrumentKey -> Bool -> Party -> Party -> [Party]
  -> Text -> [ContractId NumericObservable.I] -> [InstrumentQuantity] -> [InstrumentQuantity]
  -> Script (Optional InstrumentKey, ContractId Effect.I)
electAndVerifyPaymentEffects today amount instrument electorIsOwner issuer elector readAs
  electedTag observableCids expectedConsumed expectedProduced = do
    -- Create the Election and the lifecycle rule
    (electionCid, lifecycleRuleCid) <- createElectionAndLifecycleRule today amount instrument
      electorIsOwner issuer elector electedTag

    applyElectionAndVerify @t1 @t2 instrument issuer readAs observableCids expectedConsumed
      expectedProduced electionCid lifecycleRuleCid

-- | Try to lifecycle an election and verify that this is not possible.
ensureElectionNotPossible : forall t1 t2.
  ( Template t1
  , HasAgreement t1
  , HasToInterface t1 BaseInstrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  ) => Date -> Decimal -> InstrumentKey -> Bool -> Party -> Party -> [Party]
  -> Text -> [ContractId NumericObservable.I] -> Script ()
ensureElectionNotPossible today amount instrument electorIsOwner issuer elector readAs
  electedTag observableCids = do
    -- Create the Election and the lifecycle rule
    (electionCid, lifecycleRuleCid) <- createElectionAndLifecycleRule today amount instrument
      electorIsOwner issuer elector electedTag

    -- Build key table
    keyTable <- buildKeyTableForElectionApply @t1 @t2 [issuer] instrument

    -- Try to apply the election and verify that this does not work
    submitMultiMustFail [issuer] readAs do
      exerciseCmd electionCid Election.Apply with
        observableCids
        exercisableCid = lifecycleRuleCid
        keyTable

-- | Builds key table for the Election.Apply choice.
buildKeyTableForElectionApply :
  forall t1 t2.
  ( Template t1
  , HasAgreement t1
  , HasToInterface t1 BaseInstrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  ) => [Party] -> InstrumentKey -> Script KeyTable
buildKeyTableForElectionApply actors instrument = do
  (iCid, i) <- queryAnyByKey @t1 @BaseInstrument.I actors instrument
  let keyTable = insert instrument iCid mempty
  -- adding key table for holiday calendars
  case fromInterface @DynamicInstrument.I i of
    None -> pure keyTable
    Some dynamicInstrument -> foldlA
      (\keyTable h -> do
        iCid <- fst <$> queryAnyByKey @t2 @HolidayCalendar.I h.provider h
        pure $ insert h iCid keyTable
      )
      keyTable
      (S.toList $ DynamicInstrument.getHolidayCalendarKeys dynamicInstrument)

-- | Builds key table for the Lifecycle.Evolve choice.
buildKeyTableForLifecycleEvolve : forall t1 t2 t3.
  ( Template t1
  , HasAgreement t1
  , HasToInterface t1 BaseInstrument.I
  , Template t2
  , HasAgreement t2
  , HasToInterface t2 HolidayCalendar.I
  , Template t3
  , HasAgreement t3
  , HasFromInterface t3 Event.I
  , HasToInterface t3 Event.I
  ) => [Party] -> ContractId Event.I -> InstrumentKey -> Script KeyTable
buildKeyTableForLifecycleEvolve actors eventCid instrument = do
  keyTable <- buildKeyTableForElectionApply @t1 @t2 actors instrument
  Some event <- fmap (toInterface @Event.I) <$> queryContractId actors
    (fromInterfaceContractId @t3 eventCid)
  keyTable <- foldlA
    (\keyTable instrumentKey -> do
      instrumentCid <- fst <$> queryAnyByKey @t1 @BaseInstrument.I actors instrumentKey
      pure $ insert instrumentKey instrumentCid keyTable
    )
    keyTable (Event.getInstrumentKeys $ toInterface @Event.I event)
  pure keyTable
