-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Asset.Test.MaliciousFungible where

import DA.Action (foldlA)
import DA.Map qualified as M (empty)
import DA.Set (singleton)
import Daml.Finance.Asset.Fungible as Fungible (Factory(..))
import Daml.Finance.Asset.Test.Common (TestParties(..), setupParties)
import Daml.Finance.Asset.Test.Util.Account qualified as Account (createAccount, createFactory)
import Daml.Finance.Interface.Asset.Fungible qualified as Fungible (HasImplementation, I, Merge(..), Split(..), SplitResult(..), View(..))
import Daml.Finance.Interface.Asset.Holding qualified as Holding (I, View(..))
import Daml.Finance.Interface.Asset.Instrument qualified as Instrument (K, GetView(..), I, Reference(..), View(..))
import Daml.Finance.Interface.Asset.Lockable qualified as Lockable (I, Lock, View(..))
import Daml.Finance.Interface.Asset.Transferable qualified as Transferable (I, View(..))
import Daml.Finance.Interface.Asset.Types (AccountKey(..), Id(..), InstrumentKey(..))
import Daml.Finance.Interface.Asset.Util (getLocker)
import Daml.Finance.Interface.Common.Disclosure qualified as Disclosure (I, View(..))
import Daml.Finance.Interface.Common.Types (Observers)
import Daml.Finance.Interface.Common.Util (flattenObservers)
import Daml.Script

run : Script ()
run = do
  -- Create parties
  TestParties{custodian; issuer; investor} <- setupParties

  -- Account and holding factory
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory custodian []
  holdingFactoryCid <- toInterfaceContractId  <$> submitMulti [custodian] [] do
    createCmd Fungible.Factory with provider = custodian; observers = M.empty

  -- Create account
  issuerAccount <- Account.createAccount [] accountFactoryCid holdingFactoryCid [] custodian issuer

  -- Originate bad instrument
  now <- getTime
  let id = Id with label = "MAL.INST"; version = "0"
  maliciousInstrumentCid <- coerceContractId <$> submitMulti [custodian, issuer] [] do
    createCmd MaliciousInstrument with depository = custodian; issuer; id; observers = M.empty; validAsOf = now
  instrumentView <- submitMulti [custodian, issuer] [] do exerciseCmd maliciousInstrumentCid Instrument.GetView with viewer = issuer
  let ref = Instrument.Reference with instrumentView; cid = maliciousInstrumentCid; observers = M.empty
  coerceContractId <$> submitMulti [custodian, issuer] [] do createCmd ref
  let maliciousInstrument = key ref

  -- Credit bad asset
  maliciousFungibleImplCid <- submitMulti [custodian, issuer] [] do
    createCmd MaliciousFungible
      with
        instrument = maliciousInstrument
        account = AccountKey with custodian; owner = issuer; id = "Issuer@Custodian"
        amount = 1_000.0
        lock = None
        observers = M.empty
  let maliciousFungibleCid : ContractId Fungible.I = coerceContractId maliciousFungibleImplCid

  -- Attempt to split fails
  submitMultiMustFail [issuer, investor] [] do exerciseCmd maliciousFungibleCid Fungible.Split with amounts = [1_000.1]
  submitMultiMustFail [issuer, investor] [] do exerciseCmd maliciousFungibleCid Fungible.Split with amounts = [1_000.0, 0.1]
  submitMultiMustFail [issuer, investor] [] do exerciseCmd maliciousFungibleCid Fungible.Split with amounts = [1_000.0]
  submitMultiMustFail [issuer, investor] [] do exerciseCmd maliciousFungibleCid Fungible.Split with amounts = [900.0]

  -- Split fungible - these quantites gets multipled by 10 which matches the total original amount
  Fungible.SplitResult [badFungibleCid1, badFungibleCid2] None <- submitMulti [issuer, investor] [] do exerciseCmd maliciousFungibleCid Fungible.Split with amounts = [50.0, 50.0]

  -- Merge fungibles fails as amount isn't preserved
  submitMultiMustFail [issuer, investor] [] do exerciseCmd badFungibleCid1 Fungible.Merge with fungibleCids = [badFungibleCid2]

  pure ()

instance Fungible.HasImplementation MaliciousFungible
template MaliciousFungible
  with
    instrument : Instrument.K
    account : AccountKey
    amount : Decimal
    lock : Optional Lockable.Lock
    observers : Observers
  where
    signatory account.custodian, account.owner, getLocker this
    observer flattenObservers observers

    implements Disclosure.I where
      view = Disclosure.View with disclosureControllers = singleton $ singleton account.owner; observers
      setObserversImpl = undefined
      archiveImpl = undefined

    implements Holding.I where
      asDisclosure = toInterface @Disclosure.I this
      view = Holding.View with instrument; account; amount

    implements Lockable.I where
      asHolding = toInterface @Holding.I this
      view = Lockable.View with lock = None
      acquireImpl = undefined
      releaseImpl = undefined

    implements Transferable.I where
      asLockable = toInterface @Lockable.I this
      view = Transferable.View ()
      transferImpl = undefined

    implements Fungible.I where
      asTransferable = toInterface @Transferable.I this
      view = Fungible.View with modifiers = singleton account.owner
      splitImpl Fungible.Split{amounts}  = do
        splitCids <- forA amounts $ \q -> toInterfaceContractId <$> create this with amount = q * 10.0
        pure $ Fungible.SplitResult with splitCids; rest = None
      mergeImpl Fungible.Merge{fungibleCids} = do
        let
          f qty cid = do
            Some (tokenCid, token) <- fetchFromInterface @MaliciousFungible cid
            archive tokenCid
            pure $ qty + token.amount
        tot <- foldlA f amount fungibleCids
        toInterfaceContractId <$> create this with amount = tot + 100.0

template MaliciousInstrument
  with
    depository : Party
    issuer : Party
    id : Id
    observers : Observers
    validAsOf : Time
  where
    signatory depository, issuer
    observer flattenObservers observers

    implements Disclosure.I where
      view = undefined
      setObserversImpl = undefined
      archiveImpl = undefined

    implements Instrument.I where
      asDisclosure = toInterface @Disclosure.I this
      view = Instrument.View with depository; issuer; id; validAsOf
      getKey = InstrumentKey with depository; issuer; id
