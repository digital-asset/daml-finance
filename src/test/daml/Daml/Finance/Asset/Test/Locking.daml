-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Asset.Test.Locking where

import DA.Map qualified as M (empty)
import DA.Set (singleton)
import Daml.Finance.Asset.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Asset.Test.Util.Account qualified as Account (createAccount, createFactory, credit, submitMustFailExerciseIByKeyCmd)
import Daml.Finance.Asset.Test.Util.Holding qualified as Holding (verifyOwnerOfHolding)
import Daml.Finance.Asset.Test.Util.Instrument (originate)
import Daml.Finance.Interface.Asset.Account qualified as Account (Debit(..), I)
import Daml.Finance.Interface.Asset.Fungible qualified as Fungible (I, Split(..))
import Daml.Finance.Interface.Asset.Lockable qualified as Lockable (Acquire(..), I, LockType(..), Release(..))
import Daml.Finance.Interface.Asset.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Script

-- Origination, issuance, and transfer of asset
run : Script ()
run = script do
  -- Create parties
  [custodian, issuer, investor, locker, locker2] <- createParties ["Custodian", "Issuer", "Investor", "Locker", "locker2"]

  -- Account and holding factory
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory custodian []
  holdingFactoryCid <- toInterfaceContractId <$> submitMulti [custodian] [] do
    createCmd Fungible.Factory with provider = custodian; observers = M.empty

  -- Create account
  [issuerAccount, investorAccount] <- mapA (Account.createAccount [] accountFactoryCid holdingFactoryCid [] custodian) [issuer, investor]

  -- Originate instrument
  instrument <- originate custodian issuer "ABC.DE" []

  -- Issue asset
  holdingCid <- Account.credit [] instrument 1_000.0 issuerAccount

  -- Lock asset with a one time lock
  lockableCid <- submitMulti [issuer, locker] [] do exerciseCmd (coerceContractId holdingCid : ContractId Lockable.I) Lockable.Acquire with newLocker = singleton locker; context = "Test Lock"; lockType = Lockable.Semaphore

  -- Same Locker attempts locks asset again
  submitMultiMustFail [issuer, locker] [] do exerciseCmd lockableCid Lockable.Acquire with newLocker = singleton locker; context = "Second attempt"; lockType = Lockable.Semaphore

  -- Another locker attempts to lock this asset
  submitMultiMustFail [issuer, locker2] [] do exerciseCmd lockableCid Lockable.Acquire with newLocker = singleton locker2; context = "Steal lock"; lockType = Lockable.Semaphore

  -- Cannot debit
  Account.submitMustFailExerciseIByKeyCmd @Account.I [custodian, issuer] [] issuerAccount (Account.Debit with holdingCid)

  -- Cannot transfer
  submitMultiMustFail [issuer, investor] [] do exerciseCmd (coerceContractId lockableCid : ContractId Transferable.I) Transferable.Transfer with newOwnerAccount = investorAccount

  -- Cannot split
  submitMultiMustFail [issuer, investor] [] do exerciseCmd (coerceContractId lockableCid : ContractId Fungible.I) Fungible.Split with amounts = [100.0]

  -- Unlock asset
  lockableCid <- submitMulti [locker] [] do exerciseCmd lockableCid Lockable.Release with context = "Test Lock"

  -- Lock asset with a reentrant lock
  lockableCid <- submitMulti [issuer, locker] [] do exerciseCmd lockableCid Lockable.Acquire with newLocker = singleton locker; context = "Lock 1"; lockType = Lockable.Reentrant

  -- Same Locker locks asset again for the same context
  submitMultiMustFail [issuer, locker] [] do exerciseCmd lockableCid Lockable.Acquire with newLocker = singleton locker; context = "Lock 1"; lockType = Lockable.Reentrant

  -- Lock asset with a reentrant lock for another context
  lockableCid <- submitMulti [issuer, locker] [] do exerciseCmd lockableCid Lockable.Acquire with newLocker = singleton locker; context = "Lock 2"; lockType = Lockable.Reentrant

  -- Another locker attempts to lock this asset
  submitMultiMustFail [issuer, locker2] [] do exerciseCmd lockableCid Lockable.Acquire with newLocker = singleton locker2; context = "Steal lock"; lockType = Lockable.Semaphore
  submitMultiMustFail [issuer, locker2] [] do exerciseCmd lockableCid Lockable.Acquire with newLocker = singleton locker2; context = "Steal lock"; lockType = Lockable.Reentrant

  -- Unlock one lock
  lockableCid <- submitMulti [locker] [] do exerciseCmd lockableCid Lockable.Release with context = "Lock 2"

  -- Transfer asset fails as asset is still locked
  submitMultiMustFail [issuer, investor] [] do exerciseCmd (coerceContractId lockableCid : ContractId Transferable.I) Transferable.Transfer with newOwnerAccount = investorAccount

  -- Unlock the final lock
  lockableCid <- submitMulti [locker] [] do exerciseCmd lockableCid Lockable.Release with context = "Lock 1"

  -- Transfer asset
  transferableCid <- submitMulti [issuer, investor] [] do exerciseCmd (coerceContractId lockableCid : ContractId Transferable.I) Transferable.Transfer with newOwnerAccount = investorAccount

  -- Assert state
  Holding.verifyOwnerOfHolding [(investor, transferableCid)]

  pure ()
