-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Account.Test.Controllers where

import DA.Map qualified as M (fromList, toList)
import DA.Set qualified as S (fromList, singleton)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Holding.Test.Common (TestInitialState(..), TestParties(..), setupInitialState, setupParties)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Test.Util.Account (ControlledBy(..))
import Daml.Finance.Test.Util.Holding qualified as Holding (buildKeyTableForTransfer)
import Daml.Script

-- | Verify that custodian can transfer (in its sole discretion).
custodianControlled : Script ()
custodianControlled = script do
  -- Create parties
  tp@TestParties{custodian; issuer; investor; publicParty} <- setupParties

  -- Initialize state with
  let pp = M.fromList [("PublicParty", S.singleton publicParty)]
  TestInitialState {issuerAccount; investorAccount; issuerHoldingCid} <-
    setupInitialState tp (Fungible.Factory with provider = custodian; observers = pp) [] Custodian

  -- Build key table
  keyTable <- Holding.buildKeyTableForTransfer [issuer, investor] issuerHoldingCid investorAccount

  -- Owners can't transfer.
  submitMultiMustFail [issuer, investor] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [issuer]; newOwnerAccount = investorAccount; keyTable

  -- Build key table
  keyTable <- Holding.buildKeyTableForTransfer [custodian] issuerHoldingCid investorAccount

  -- Custodian can transfer.
  submitMulti [custodian] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [custodian]; newOwnerAccount = investorAccount; keyTable

  pure ()

-- | Verify that owner and new owner can transfer jointly.
ownerControlled : Script ()
ownerControlled = script do
  -- Create parties
  tp@TestParties{custodian; issuer; investor; publicParty} <- setupParties

  -- Initialize state with `NonFungible.Factory`
  let pp = M.fromList [("PublicParty", S.singleton publicParty)]
  TestInitialState {issuerAccount; investorAccount; issuerHoldingCid} <-
    setupInitialState tp (Fungible.Factory with provider = custodian; observers = pp) [] Owner

  -- Build key table
  keyTable <- Holding.buildKeyTableForTransfer [custodian] issuerHoldingCid investorAccount

  -- Custodian can't transfer.
  submitMultiMustFail [custodian] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [custodian]; newOwnerAccount = investorAccount; keyTable

  -- Build key table
  keyTable <- Holding.buildKeyTableForTransfer [issuer, investor] issuerHoldingCid investorAccount

  -- Owners can transfer.
  submitMulti [issuer, investor] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [issuer, investor]; newOwnerAccount = investorAccount; keyTable

  pure ()

-- | Verify that owner, custodian, and new owner can transfer jointly.
ownerAndCustodianControlled : Script ()
ownerAndCustodianControlled = script do
  -- Create parties
  tp@TestParties{custodian; issuer; investor; publicParty} <- setupParties

  -- Initialize state with `NonFungible.Factory`
  let pp = M.fromList [("PublicParty", S.singleton publicParty)]
  TestInitialState {issuerAccount; investorAccount; issuerHoldingCid} <-
    setupInitialState tp (Fungible.Factory with provider = custodian; observers = pp) []
      OwnerAndCustodian

  -- Build key table
  keyTable <- Holding.buildKeyTableForTransfer [issuer, investor] issuerHoldingCid investorAccount

  -- Owners can't transfer.
  submitMultiMustFail [issuer, investor] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [issuer, investor]; newOwnerAccount = investorAccount; keyTable

  -- Build key table
  keyTable <- Holding.buildKeyTableForTransfer [custodian] issuerHoldingCid investorAccount

  -- Custodian can't transfer.
  submitMultiMustFail [custodian] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [custodian]; newOwnerAccount = investorAccount; keyTable

  -- Build key table
  keyTable <- Holding.buildKeyTableForTransfer [custodian, issuer, investor] issuerHoldingCid
    investorAccount

  -- Owners and Custodian can transfer.
  submitMulti [custodian, issuer, investor] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [custodian, issuer, investor]; newOwnerAccount = investorAccount; keyTable

  pure ()

-- | Verify that owner can transfer (in its sole discretion).
ownerControlledWithAutoApproval : Script ()
ownerControlledWithAutoApproval = script do
  -- Create parties
  tp@TestParties{custodian; issuer; investor; publicParty} <- setupParties

  -- Initialize state with `NonFungible.Factory`
  let pp = M.fromList [("PublicParty", S.singleton publicParty)]
  TestInitialState {issuerAccount; investorAccount; issuerHoldingCid} <-
    setupInitialState tp (Fungible.Factory with provider = custodian; observers = pp) (M.toList pp)
      OwnerWithAutoApproval

  -- Build key table
  keyTable <- Holding.buildKeyTableForTransfer [custodian] issuerHoldingCid investorAccount

  -- Custodian can't transfer.
  submitMultiMustFail [custodian] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [custodian]; newOwnerAccount = investorAccount; keyTable

  -- Build key table
  keyTable <- Holding.buildKeyTableForTransfer [issuer, publicParty] issuerHoldingCid investorAccount

  -- Owner can transfer.
  submitMulti [issuer] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [issuer]; newOwnerAccount = investorAccount; keyTable

  pure ()
