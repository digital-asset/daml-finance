-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Account.Test.Controllers where

import DA.Map qualified as M (fromList, toList)
import DA.Set qualified as S (fromList, singleton)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Holding.Test.Common (TestInitialState(..), TestParties(..), setupInitialState, setupParties)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Test.Util.Account (ControlledBy(..))
import Daml.Finance.Test.Util.Account qualified as Account (buildIndexTable)
import Daml.Finance.Test.Util.Holding qualified as Holding (buildIndexTable)
import Daml.Script

-- | Verify that custodian can transfer (in its sole discretion).
custodianControlled : Script ()
custodianControlled = script do
  -- Create parties
  tp@TestParties{custodian; issuer; investor; publicParty} <- setupParties

  -- Initialize state with
  let pp = M.fromList [("PublicParty", S.singleton publicParty)]
  TestInitialState {issuerAccount; investorAccount; issuerHoldingCid} <-
    setupInitialState tp (Fungible.Factory with provider = custodian; observers = pp) [] Custodian

  -- Build index table
  idxs1 <- Holding.buildIndexTable [issuer, investor] issuerHoldingCid
  idxs2 <- Account.buildIndexTable [issuer, investor] investorAccount
  let idx = idxs1 <> idxs2

  -- Owners can't transfer.
  submitMultiMustFail [issuer, investor] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [issuer]; newOwnerAccount = investorAccount; idx

  -- Build index table
  idxs1 <- Holding.buildIndexTable [issuer, investor] issuerHoldingCid
  idxs2 <- Account.buildIndexTable [issuer, investor] investorAccount
  let idx = idxs1 <> idxs2

  -- Custodian can transfer.
  submitMulti [custodian] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [custodian]; newOwnerAccount = investorAccount; idx

  pure ()

-- | Verify that owner and new owner can transfer jointly.
ownerControlled : Script ()
ownerControlled = script do
  -- Create parties
  tp@TestParties{custodian; issuer; investor; publicParty} <- setupParties

  -- Initialize state with `NonFungible.Factory`
  let pp = M.fromList [("PublicParty", S.singleton publicParty)]
  TestInitialState {issuerAccount; investorAccount; issuerHoldingCid} <-
    setupInitialState tp (Fungible.Factory with provider = custodian; observers = pp) [] Owner

  -- Build index table
  idxs1 <- Holding.buildIndexTable [custodian] issuerHoldingCid
  idxs2 <- Account.buildIndexTable [custodian] investorAccount
  let idx = idxs1 <> idxs2

  -- Custodian can't transfer.
  submitMultiMustFail [custodian] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [custodian]; newOwnerAccount = investorAccount; idx = idxs1 <> idxs2

  -- Build index table
  idxs1 <- Holding.buildIndexTable [issuer, investor] issuerHoldingCid
  idxs2 <- Account.buildIndexTable [issuer, investor] investorAccount
  let idx = idxs1 <> idxs2

  -- Owners can transfer.
  submitMulti [issuer, investor] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [issuer, investor]; newOwnerAccount = investorAccount; idx

  pure ()

-- | Verify that owner, custodian, and new owner can transfer jointly.
ownerAndCustodianControlled : Script ()
ownerAndCustodianControlled = script do
  -- Create parties
  tp@TestParties{custodian; issuer; investor; publicParty} <- setupParties

  -- Initialize state with `NonFungible.Factory`
  let pp = M.fromList [("PublicParty", S.singleton publicParty)]
  TestInitialState {issuerAccount; investorAccount; issuerHoldingCid} <-
    setupInitialState tp (Fungible.Factory with provider = custodian; observers = pp) []
      OwnerAndCustodian

  -- Build index table
  idxs1 <- Holding.buildIndexTable [issuer, investor] issuerHoldingCid
  idxs2 <- Account.buildIndexTable [issuer, investor] investorAccount
  let idx = idxs1 <> idxs2

  -- Owners can't transfer.
  submitMultiMustFail [issuer, investor] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [issuer, investor]; newOwnerAccount = investorAccount; idx

  -- Build index table
  idxs1 <- Holding.buildIndexTable [custodian] issuerHoldingCid
  idxs2 <- Account.buildIndexTable [custodian] investorAccount
  let idx = idxs1 <> idxs2

  -- Custodian can't transfer.
  submitMultiMustFail [custodian] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [custodian]; newOwnerAccount = investorAccount; idx

  -- Build index table
  idxs1 <- Holding.buildIndexTable [custodian, issuer, investor] issuerHoldingCid
  idxs2 <- Account.buildIndexTable [custodian, issuer, investor] investorAccount
  let idx = idxs1 <> idxs2

  -- Owners and Custodian can transfer.
  submitMulti [custodian, issuer, investor] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [custodian, issuer, investor]; newOwnerAccount = investorAccount; idx

  pure ()

-- | Verify that owner can transfer (in its sole discretion).
ownerControlledWithAutoApproval : Script ()
ownerControlledWithAutoApproval = script do
  -- Create parties
  tp@TestParties{custodian; issuer; investor; publicParty} <- setupParties

  -- Initialize state with `NonFungible.Factory`
  let pp = M.fromList [("PublicParty", S.singleton publicParty)]
  TestInitialState {issuerAccount; investorAccount; issuerHoldingCid} <-
    setupInitialState tp (Fungible.Factory with provider = custodian; observers = pp) (M.toList pp)
      OwnerWithAutoApproval

  -- Build index table
  idxs1 <- Holding.buildIndexTable [custodian] issuerHoldingCid
  idxs2 <- Account.buildIndexTable [custodian] investorAccount
  let idx = idxs1 <> idxs2

  -- Custodian can't transfer.
  submitMultiMustFail [custodian] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [custodian]; newOwnerAccount = investorAccount; idx

  -- Build index table
  idxs1 <- Holding.buildIndexTable [issuer] issuerHoldingCid
  idxs2 <- Account.buildIndexTable [issuer, publicParty] investorAccount
  let idx = idxs1 <> idxs2

  -- Owner can transfer.
  submitMulti [issuer] [publicParty] do
    exerciseCmd (coerceInterfaceContractId @Transferable.I issuerHoldingCid)
      Transferable.Transfer with
        actors = S.fromList [issuer]; newOwnerAccount = investorAccount; idx

  pure ()
