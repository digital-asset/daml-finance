module Daml.Finance.Settlement.Test.Hierarchy where

import DA.Assert ((===))
import Daml.Finance.Interface.Instrument.Base.Instrument (qty)
import Daml.Finance.Interface.Settlement.Types (Step(..))
import Daml.Finance.Interface.Types.Common (Id(..), InstrumentKey(..))
import Daml.Finance.Settlement.Hierarchy
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Script

--           a
--         /   \
--        b     c
--      /   \    \
--     d    e     f
testHierarchyPaths : Script ()
testHierarchyPaths = do

  [a,b,c,d,e,f,h] <- createParties ["a","b","c","d","e","f","h"]

  let hierarchy = Hierarchy with
        rootCustodian = a
        pathsToRootCustodian =
          [ [d, b]
          , [e, b]
          , [f, c]
          ]

  locateParty a hierarchy === Some [a, a]
  locateParty b hierarchy === Some [b, a]
  locateParty c hierarchy === Some [c, a]
  locateParty d hierarchy === Some [d, b, a]
  locateParty e hierarchy === Some [e, b, a]
  locateParty f hierarchy === Some [f, c, a]
  locateParty h hierarchy === None

  route hierarchy d a === Some [(d,b), (b,a)]
  route hierarchy d b === Some [(d,b)]
  route hierarchy b f === Some [(b,c), (c,f)]
  route hierarchy a d === Some [(a,b), (b,d)]
  route hierarchy d h === None

  pure ()

-- | Get route between two parties, if it exists.
route : Hierarchy -> Party -> Party -> Optional [(Party, Party)]
route h from to = do
  fromPath <- locateParty from h
  toPath <- locateParty to h
  getRoute fromPath toPath

-- | Create a step from sender to receiver for a dummy instrument.
createStep : Party -> Party -> Step
createStep sender receiver =
  let quantity = qty 1.0 $ InstrumentKey with depository = sender; issuer = receiver; id = Id "dummy"; version = "0"
  in Step with sender; receiver; quantity
