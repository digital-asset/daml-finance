-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Test.Util where

import DA.Action (foldlA)
import DA.Set qualified as S (fromList)
import Daml.Finance.Account.Account qualified as Account (T)
import Daml.Finance.Interface.Account.Account qualified as Account (I)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Cancel(..), I, Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), I)
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..))
import Daml.Finance.Interface.Types.Common.Types (Id(..))
import Daml.Finance.Interface.Util.SyntheticKey (IndexTable(..), insert)
import Daml.Finance.Settlement.Instruction qualified as Instruction (T)
import Daml.Finance.Test.Util.Common (queryAnyByKey)
import Daml.Finance.Util.Common (mapWithIndex)
import Daml.Script

-- | Utility functions for allocating an instruction.
allocateAny : [Party] -> ContractId Instruction.I -> Allocation ->
  Script (ContractId Instruction.I, Optional (ContractId Holding.I))
allocateAny actors instructionCid allocation = fst <$>
  allocateAnyHelper submitMulti actors instructionCid allocation

-- | Utility functions for allocating an instruction which must fail.
allocateAnyMustFail : [Party] -> ContractId Instruction.I -> Allocation -> Script ()
allocateAnyMustFail = allocateAnyHelper submitMultiMustFail

-- | HIDE
allocateAnyHelper :
  ([Party] -> [Party] -> Commands ((ContractId Instruction.I, Optional (ContractId Holding.I)),
  IndexTable) -> Script a) -> [Party] -> ContractId Instruction.I -> Allocation -> Script a
allocateAnyHelper submit' actors instructionCid allocation = do
  r <- queryInterfaceContractId @Instruction.I actors instructionCid
  idxsOld <- case r of
    Some instruction -> buildIndexTableForAllocation actors instruction.allocation
    None -> pure mempty
  idxsNew <- buildIndexTableForAllocation actors allocation
  submit' actors [] do
    exerciseCmd instructionCid Instruction.Allocate with
      actors = S.fromList actors; allocation; idx = mconcat [idxsNew, idxsOld]

-- | Build index table for allocating an instruction.
buildIndexTableForAllocation : [Party] -> Allocation -> Script IndexTable
buildIndexTableForAllocation actors allocation =
  case allocation of
    Pledge holdingCid -> do
      Some holding <- queryInterfaceContractId @Holding.I actors holdingCid
      accountCid <- fst <$> queryAnyByKey @Account.T @Account.I actors holding.account
      pure $ insert holding.account accountCid mempty
    PassThroughFrom (accountKey, fromInstructionKey) -> do
      accountCid <- fst <$> queryAnyByKey @Account.T @Account.I actors accountKey
      instructionCid <- fst <$> queryAnyByKey @Instruction.T @Instruction.I actors
        fromInstructionKey
      pure $ insert accountKey accountCid . insert fromInstructionKey instructionCid $ mempty
    _ -> pure mempty

-- | Utility functions for approving an instruction.
approveAny : [Party] -> ContractId Instruction.I -> Approval -> Script (ContractId Instruction.I)
approveAny actors instructionCid approval = fst <$>
  approveAnyHelper submitMulti actors instructionCid approval

-- | Utility functions for approving an instruction which must fail.
approveAnyMustFail : [Party] -> ContractId Instruction.I -> Approval -> Script ()
approveAnyMustFail = approveAnyHelper submitMultiMustFail

-- | HIDE
approveAnyHelper :
  ([Party] -> [Party] -> Commands (ContractId Instruction.I, IndexTable) -> Script a) ->
  [Party] -> ContractId Instruction.I -> Approval -> Script a
approveAnyHelper submit' actors instructionCid approval = do
  Some instruction <- queryInterfaceContractId @Instruction.I actors instructionCid
  oldIdxs <- buildIndexTableForApproval actors instruction.approval
  newIdxs <- buildIndexTableForApproval actors approval
  let idx = mconcat [newIdxs, oldIdxs]
  submit' actors [] do
    exerciseCmd instructionCid Instruction.Approve with actors = S.fromList actors; approval; idx

-- | Build index table for approving an instruction.
buildIndexTableForApproval : [Party] -> Approval -> Script IndexTable
buildIndexTableForApproval actors approval =
  case approval of
    TakeDelivery accountKey -> do
      accountCid <- fst <$> queryAnyByKey @Account.T @Account.I actors accountKey
      pure $ insert accountKey accountCid mempty
    PassThroughTo (accountKey, toInstructionKey) -> do
      accountCid <- fst <$> queryAnyByKey @Account.T @Account.I actors accountKey
      instructionCid <- fst <$> queryAnyByKey @Instruction.T @Instruction.I actors toInstructionKey
      pure $ insert accountKey accountCid . insert toInstructionKey instructionCid $ mempty
    _ ->
      pure mempty

-- | Utility functions for settling a batch.
settleAny : [Party] -> [Party] -> ContractId Batch.I -> Script [ContractId Holding.I]
settleAny = settleAnyHelper submitMulti

-- | Utility functions for settling a batch which must fail.
settleAnyMustFail : [Party] -> [Party] -> ContractId Batch.I -> Script ()
settleAnyMustFail = settleAnyHelper submitMultiMustFail

-- | HIDE
settleAnyHelper : ([Party] -> [Party] -> Commands [ContractId Holding.I] -> Script b) ->
  [Party] -> [Party] -> ContractId Batch.I -> Script b
settleAnyHelper submitF actors observers batchCid = do
  -- Build index table
  idx <- buildIndexTableForBatchSettlement actors batchCid
  -- Settle
  submitF actors observers do
    fst <$> exerciseCmd batchCid Batch.Settle with actors = S.fromList actors; idx

-- | Build index table for settling a batch.
buildIndexTableForBatchSettlement : [Party] -> ContractId Batch.I -> Script IndexTable
buildIndexTableForBatchSettlement actors batchCid = do
  r <- queryInterfaceContractId actors batchCid
  case r of
    Some batch -> do
      let
        buildKey instructionId = InstructionKey with
          requestors = batch.requestors; batchId = batch.id; id = instructionId
        n = length batch.routedSteps - 1
        instructionKeys = map (buildKey. Id . show) [0..n]
      foldlA
        (\idx instructionKey -> do
          (instructionCid, instruction) <-
            queryAnyByKey @Instruction.T @Instruction.I actors instructionKey
          let
            v = view instruction
            idxs1 = insert instructionKey instructionCid idx
          idxs2 <- buildIndexTableForAllocation actors v.allocation
          idxs3 <- buildIndexTableForApproval actors v.approval
          pure $ mconcat [idxs3, idxs2, idxs1]
        )
       mempty $ instructionKeys
    None -> abort "couldn't find any instructions for the batch"

-- | Utility functions for cancelling a batch.
cancelAny : [Party] -> [Party] -> ContractId Batch.I -> Script [ContractId Holding.I]
cancelAny = cancelAnyHelper submitMulti

-- | Utility functions for cancelling a batch which must fail.
cancelAnyMustFail : [Party] -> [Party] -> ContractId Batch.I -> Script ()
cancelAnyMustFail = cancelAnyHelper submitMultiMustFail

-- | HIDE
cancelAnyHelper : ([Party] -> [Party] -> Commands [ContractId Holding.I] -> Script b) ->
  [Party] -> [Party] -> ContractId Batch.I -> Script b
cancelAnyHelper submitF actors observers batchCid = do
  idx <- buildIndexTableForBatchCancelling actors batchCid
  submitF actors observers do
    fst <$> exerciseCmd batchCid Batch.Cancel with actors = S.fromList actors; idx

-- | Build index table for cancelling a batch.
buildIndexTableForBatchCancelling : [Party] -> ContractId Batch.I -> Script IndexTable
buildIndexTableForBatchCancelling actors batchCid = do
  Some batch <- queryInterfaceContractId @Batch.I actors batchCid
  foldlA
    (\idx (routedStep, id) -> do
      let instructionKey = InstructionKey with requestors = batch.requestors; batchId = batch.id; id
      instructionCid <- fst <$> queryAnyByKey @Instruction.T @Instruction.I actors instructionKey
      pure $ insert instructionKey instructionCid idx
    ) mempty $ mapWithIndex (\e idx -> (e, Id (show idx))) batch.routedSteps
