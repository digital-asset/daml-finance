-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Test.Util where

import DA.Action (foldlA)
import DA.Set qualified as S (fromList)
import Daml.Finance.Account.Account qualified as Account (T)
import Daml.Finance.Interface.Account.Account qualified as Account (I)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Cancel(..), I, Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), I)
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..))
import Daml.Finance.Interface.Types.Common.Types (Id(..))
import Daml.Finance.Interface.Util.KeyTable (KeyTable(..), insert)
import Daml.Finance.Settlement.Instruction qualified as Instruction (T)
import Daml.Finance.Test.Util.Common (queryAnyByKey)
import Daml.Finance.Util.Common (mapWithIndex)
import Daml.Script

-- | Utility function for allocating an instruction.
allocateAny : [Party] -> ContractId Instruction.I -> Allocation ->
  Script (ContractId Instruction.I, Optional (ContractId Holding.I))
allocateAny actors instructionCid allocation = fst <$>
  allocateAnyHelper submitMulti actors instructionCid allocation

-- | Utility function for allocating an instruction which must fail.
allocateAnyMustFail : [Party] -> ContractId Instruction.I -> Allocation -> Script ()
allocateAnyMustFail = allocateAnyHelper submitMultiMustFail

-- | HIDE
allocateAnyHelper :
  ([Party] -> [Party] -> Commands ((ContractId Instruction.I, Optional (ContractId Holding.I)),
  KeyTable) -> Script a) -> [Party] -> ContractId Instruction.I -> Allocation -> Script a
allocateAnyHelper submit' actors instructionCid allocation = do
  r <- queryInterfaceContractId @Instruction.I actors instructionCid
  idxsOld <- case r of
    Some instruction -> buildKeyTableForAllocation actors instruction.allocation
    None -> pure mempty
  idxsNew <- buildKeyTableForAllocation actors allocation
  submit' actors [] do
    exerciseCmd instructionCid Instruction.Allocate with
      actors = S.fromList actors; allocation; keyTable = mconcat [idxsNew, idxsOld]

-- | Build key table for allocating an instruction.
buildKeyTableForAllocation : [Party] -> Allocation -> Script KeyTable
buildKeyTableForAllocation actors allocation =
  case allocation of
    Pledge holdingCid -> do
      Some holding <- queryInterfaceContractId @Holding.I actors holdingCid
      accountCid <- fst <$> queryAnyByKey @Account.T @Account.I actors holding.account
      pure $ insert holding.account accountCid mempty
    PassThroughFrom (accountKey, fromInstructionKey) -> do
      accountCid <- fst <$> queryAnyByKey @Account.T @Account.I actors accountKey
      instructionCid <- fst <$> queryAnyByKey @Instruction.T @Instruction.I actors
        fromInstructionKey
      pure $ insert accountKey accountCid . insert fromInstructionKey instructionCid $ mempty
    _ -> pure mempty

-- | Utility functions for approving an instruction.
approveAny : [Party] -> ContractId Instruction.I -> Approval -> Script (ContractId Instruction.I)
approveAny actors instructionCid approval = fst <$>
  approveAnyHelper submitMulti actors instructionCid approval

-- | Utility functions for approving an instruction which must fail.
approveAnyMustFail : [Party] -> ContractId Instruction.I -> Approval -> Script ()
approveAnyMustFail = approveAnyHelper submitMultiMustFail

-- | HIDE
approveAnyHelper :
  ([Party] -> [Party] -> Commands (ContractId Instruction.I, KeyTable) -> Script a) ->
  [Party] -> ContractId Instruction.I -> Approval -> Script a
approveAnyHelper submit' actors instructionCid approval = do
  Some instruction <- queryInterfaceContractId @Instruction.I actors instructionCid
  oldIdxs <- buildKeyTableForApproval actors instruction.approval
  newIdxs <- buildKeyTableForApproval actors approval
  let keyTable = mconcat [newIdxs, oldIdxs]
  submit' actors [] do
    exerciseCmd instructionCid Instruction.Approve with
      actors = S.fromList actors; approval; keyTable

-- | Build key table for approving an instruction.
buildKeyTableForApproval : [Party] -> Approval -> Script KeyTable
buildKeyTableForApproval actors approval =
  case approval of
    TakeDelivery accountKey -> do
      accountCid <- fst <$> queryAnyByKey @Account.T @Account.I actors accountKey
      pure $ insert accountKey accountCid mempty
    PassThroughTo (accountKey, toInstructionKey) -> do
      accountCid <- fst <$> queryAnyByKey @Account.T @Account.I actors accountKey
      instructionCid <- fst <$> queryAnyByKey @Instruction.T @Instruction.I actors toInstructionKey
      pure $ insert accountKey accountCid . insert toInstructionKey instructionCid $ mempty
    _ ->
      pure mempty

-- | Utility functions for settling a batch.
settleAny : [Party] -> [Party] -> ContractId Batch.I -> Script [ContractId Holding.I]
settleAny = settleAnyHelper submitMulti

-- | Utility functions for settling a batch which must fail.
settleAnyMustFail : [Party] -> [Party] -> ContractId Batch.I -> Script ()
settleAnyMustFail = settleAnyHelper submitMultiMustFail

-- | HIDE
settleAnyHelper : ([Party] -> [Party] -> Commands [ContractId Holding.I] -> Script b) ->
  [Party] -> [Party] -> ContractId Batch.I -> Script b
settleAnyHelper submitF actors observers batchCid = do
  -- Build key table
  keyTable <- buildKeyTableForBatchSettlement actors batchCid
  -- Settle
  submitF actors observers do
    fst <$> exerciseCmd batchCid Batch.Settle with actors = S.fromList actors; keyTable

-- | Build key table for settling a batch.
buildKeyTableForBatchSettlement : [Party] -> ContractId Batch.I -> Script KeyTable
buildKeyTableForBatchSettlement actors batchCid = do
  r <- queryInterfaceContractId actors batchCid
  case r of
    Some batch -> do
      let
        buildKey instructionId = InstructionKey with
          requestors = batch.requestors; batchId = batch.id; id = instructionId
        n = length batch.routedSteps - 1
        instructionKeys = map (buildKey. Id . show) [0..n]
      foldlA
        (\keyTable instructionKey -> do
          (instructionCid, instruction) <-
            queryAnyByKey @Instruction.T @Instruction.I actors instructionKey
          let
            v = view instruction
            idxs1 = insert instructionKey instructionCid keyTable
          idxs2 <- buildKeyTableForAllocation actors v.allocation
          idxs3 <- buildKeyTableForApproval actors v.approval
          pure $ mconcat [idxs3, idxs2, idxs1]
        )
       mempty $ instructionKeys
    None -> abort "couldn't find any instructions for the batch"

-- | Utility functions for cancelling a batch.
cancelAny : [Party] -> [Party] -> ContractId Batch.I -> Script [ContractId Holding.I]
cancelAny = cancelAnyHelper submitMulti

-- | Utility functions for cancelling a batch which must fail.
cancelAnyMustFail : [Party] -> [Party] -> ContractId Batch.I -> Script ()
cancelAnyMustFail = cancelAnyHelper submitMultiMustFail

-- | HIDE
cancelAnyHelper : ([Party] -> [Party] -> Commands [ContractId Holding.I] -> Script b) ->
  [Party] -> [Party] -> ContractId Batch.I -> Script b
cancelAnyHelper submitF actors observers batchCid = do
  keyTable <- buildKeyTableForBatchCancelling actors batchCid
  submitF actors observers do
    fst <$> exerciseCmd batchCid Batch.Cancel with actors = S.fromList actors; keyTable

-- | Build key table for cancelling a batch.
buildKeyTableForBatchCancelling : [Party] -> ContractId Batch.I -> Script KeyTable
buildKeyTableForBatchCancelling actors batchCid = do
  Some batch <- queryInterfaceContractId @Batch.I actors batchCid
  foldlA
    (\keyTable (routedStep, id) -> do
      let instructionKey = InstructionKey with requestors = batch.requestors; batchId = batch.id; id
      instructionCid <- fst <$> queryAnyByKey @Instruction.T @Instruction.I actors instructionKey
      pure $ insert instructionKey instructionCid keyTable
    ) mempty $ mapWithIndex (\e keyTable -> (e, Id (show keyTable))) batch.routedSteps
