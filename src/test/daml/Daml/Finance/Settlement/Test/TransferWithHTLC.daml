-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Test.TransferWithHTLC where

import DA.Map qualified as Map (fromList)
import DA.Optional (isSome)
import DA.Set qualified as Set (fromList, singleton)
import DA.Text (sha256)
import DA.Time (addRelTime, hours)
import Daml.Finance.Holding.Factory qualified as Holding (Factory(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Cancel(..), Settle(..))
import Daml.Finance.Interface.Settlement.Factory qualified as SettlementFactory (I, Instruct(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), RoutedStep(..))
import Daml.Finance.Interface.Types.Common.Types (HoldingStandard(..), Id(..))
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Interface.Util.Lockable qualified as Lockable (I)
import Daml.Finance.Settlement.Factory qualified as Settlement (FactoryWithHTLC(..))
import Daml.Finance.Settlement.HTLC (HTLC(..))
import Daml.Finance.Settlement.HTLC qualified as HTLC (HTLCState(..), Lock(..), Reveal(..))
import Daml.Finance.Test.Util.Account qualified as Account (ControlledBy(..), createAccount, createFactory, credit)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Holding qualified as Holding (verifyNoObservers, verifyOwnerOfHolding)
import Daml.Finance.Test.Util.HoldingFactory (createHoldingFactory)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (originate)
import Daml.Script

-- | Parties involved in the test script.
data TestParties = TestParties
  with
    bank : Party
      -- ^ Acts as custodian in the respective holdings and provider of the holding factories.
      --   Acts as issuer and repository of the security instrument. 
    cb : Party
      -- ^ Depository and issuer of the cash instrument.
    sender : Party
      -- ^ Sends units of security to receiver.
    receiver : Party
      -- ^ Receives units of security from sender.
    cashSender : Party
      -- ^ Sends units of cash to receiver.
    cashReceiver : Party
      -- ^ Receives units of cash from sender.
    settler : Party
      -- ^ Executes the settlement of the batch.

-- Transfer of cash between two parties (sender -> receiver) facilitated by an intermediary (bank)
-- using HTLC module.
-- +------------------------------------------+
-- | Accounts                                 |
-- +------------------+-----------------------+
-- | structure:       | used for:             |
-- +------------------+-----------------------+
-- |      Bank        |                       |
-- |      /  \        | securities            |
-- | Sender  Receiver |                       |
-- +------------------+-----------------------+
run : Bool -> Script ()
run isHappyPath = script do
  -- Create parties
  TestParties{..} <- setupParties
  let
    observers = Set.fromList [sender, receiver]
    observersWithContext = [("Observers", observers)]

  -- 0. SETUP

  -- Create account factory
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory bank mempty

  -- Create holding factory
  holdingFactory <- createHoldingFactory
    Holding.Factory with
      provider = bank
      id = Id "Holding Factory"
      observers = Map.fromList observersWithContext

  -- Create accounts
  [senderAccount, receiverAccount] <- mapA (Account.createAccount "Security Account" []
    accountFactoryCid holdingFactory [] Account.Owner bank) [sender, receiver]

  -- Distribute asset
  now <- getTime
  cashInstrument <- Instrument.originate cb cb "USD" Transferable "United States Dollar" [] now
  securityInstrument <- Instrument.originate bank bank "SECURITY" Transferable "A Security" [] now

  securityCid <- Account.credit [] securityInstrument 1000.0 senderAccount

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId @SettlementFactory.I <$>
    submit bank do createCmd Settlement.FactoryWithHTLC with provider = bank; observers


  -- Settlement step
  let
    routedSteps =
      [ RoutedStep with sender; receiver; custodian = bank; quantity = qty 1_000.0 securityInstrument
      ]

  let batchId = Id "transfer abc"

  (batchCid, [securityInstructionCid]) <- submit bank do
    exerciseCmd settlementFactoryCid SettlementFactory.Instruct with
      instructor = bank
      consenters = mempty
      settlers = Set.singleton bank
      id = batchId
      description = "transfer of 1000 units of security conditional on 200000 units of cash"
      contextId = None
      routedSteps
      settlementTime = None


  let
    secret = "dfgrhtdnni46rhf"
    expiry = addRelTime now $ hours 12
    hash = sha256 secret

  htlcCid <- submit bank do
    createCmd HTLC with
      batchId
      instructor = bank
      consenters = mempty
      settlers = Set.singleton bank -- do we validate this against the batch?
      observers = Set.fromList [sender, receiver, cashSender, cashReceiver, settler]
      expiry
      hash
      state = HTLC.Open


  -- Allocate instruction and lock the holding
  (securityInstructionCid, _) <- submit sender do
    exerciseCmd securityInstructionCid Instruction.Allocate with
      actors = Set.singleton sender; allocation = Pledge securityCid

  Some securityInstruction <- queryInterfaceContractId sender securityInstructionCid

  let Pledge holdingCid = securityInstruction.allocation
  Some lockable <- queryInterfaceContractId sender (toInterfaceContractId @Lockable.I holdingCid)
  assertMsg "holding is locked" $ isSome lockable.lock


  -- Approve instruction
  securityInstructionCid <- submit receiver do
    exerciseCmd securityInstructionCid Instruction.Approve with
      actors = Set.singleton receiver; approval = TakeDelivery receiverAccount


  -- Lock Batch and Instructions (such that they can't be backed out of)
  htlcCid <- submit bank do
    exerciseCmd htlcCid HTLC.Lock

  -- Receiver can't unapprove (as locked)
  submitMustFail receiver do
    exerciseCmd securityInstructionCid Instruction.Approve with
      actors = Set.singleton receiver; approval = Unapproved

  -- Sender can no longer unallocate (as locked)
  submitMustFail sender do
    exerciseCmd securityInstructionCid Instruction.Allocate with
      actors = Set.singleton sender; allocation = Unallocated

  -- Settler can't settle (as locked)
  submitMustFail receiver do
    exerciseCmd batchCid Batch.Settle with actors = Set.singleton receiver



  if isHappyPath
    then do
      -- HAPPY PATH


      submit cashSender do
        exerciseCmd htlcCid HTLC.Reveal with actor = cashSender; secret

      [securityHoldingCid] <- submit bank do
        exerciseCmd batchCid Batch.Settle with actors = Set.singleton bank

      -- Assert state
      let ts = [(receiver, securityHoldingCid)]
      Holding.verifyOwnerOfHolding ts
      Holding.verifyNoObservers ts
      pure ()
    else do
      -- FAILURE PATH

      -- cannot cancel before expiry
      submitMultiMustFail [bank, sender, receiver] [] do
        exerciseCmd batchCid Batch.Cancel with actors = Set.fromList [bank, sender, receiver]

      -- wait for expiry
      setTime $ addRelTime expiry $ hours 1

      [securityHoldingCid] <- submitMulti [bank, sender, receiver] [] do
        exerciseCmd batchCid Batch.Cancel with actors = Set.fromList [bank, sender, receiver]

      -- Assert state
      let ts = [(sender, securityHoldingCid)]
      Holding.verifyOwnerOfHolding ts
      Holding.verifyNoObservers ts
      pure ()

runHappyPath : Script ()
runHappyPath = run True

runFailurePath : Script ()
runFailurePath = run False

setupParties : Script TestParties
setupParties = do
  [cb, bank, sender, receiver, cashSender, cashReceiver, settler] <-
    createParties ["CentralBank", "Bank", "Sender", "Receiver", "CashSender", "CashReceiver", "Settler"]
  pure TestParties with cb; bank; sender; receiver; cashSender; cashReceiver; settler
