-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Test.Intermediated where

import DA.Map qualified as M (fromList)
import DA.Set (empty, singleton)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..), T)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Factory qualified as Factory (Instruct(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), I)
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), Step(..))
import Daml.Finance.Interface.Types.Common (Id(..))
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I, RemoveObservers(..))
import Daml.Finance.Settlement.Factory (Factory(..))
import Daml.Finance.Test.Util.Account qualified as Account (createAccount, createFactory, credit, submitExerciseInterfaceByKeyCmd)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Holding qualified as Holding (verifyOwnerOfHolding)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (originate)
import Daml.Script

data TestParties = TestParties
  with
    bank1 : Party
      -- ^ Custodian of Alice's cash holdings.
    bank2 : Party
      -- ^ Custodian of Bob's cash holdings.
    cb : Party
      -- ^ The Central Bank is the depository and the issuer of the cash instrument. It also acts as custodian for the cash holdings of Bank1 and Bank2.
    csd : Party
      -- ^ The Central Bank is the depository of the equity instrument. It also acts as custodian for the equity holdings of Custodian1 and Custodian2.
    custodian1 : Party
      -- ^ Custodian of Alice's equity holdings.
    custodian2 : Party
      -- ^ Custodian of Bob's equity holdings.
    issuer : Party
      -- ^ Issuer of the equity instrument.
    alice : Party
      -- ^ Sends money to Bob.
    bob : Party
      -- ^ Sends shares to Alice.
    agent : Party
      -- ^ Party that requests and executes the settlement of the transaction between Alice and Bob.
    delegatee : Party
      -- ^ Party that is granted the right to allocate Alice's holdings on her behalf.
    publicParty : Party
      -- ^ The public party. Every party can readAs the public party.

-- | Cross-custodial payment with delegation
run1 : Script ()
run1 = run True

-- | Cross-custodial payment without delegation
run2 : Script ()
run2 = run False

-- | Cross-custodial payment
-- Dvp of $ 200'000 vs 1'250 shares.
--
-- Cash account structure:
--        CB
--       /  \
--     B1    B2
--     /      \
--    A        B
--
-- Equity (security) account structure:
--    A        B
--     \      /
--     C2    C1
--       \  /
--       CSD
--
-- Assumptions:
-- 1. The cash settles via intermediary banks B1 and B2, and the Central Bank (CB), i.e., A -> B1 -> CB -> B2 -> B.
-- 2. The security settles via intermediary custodians C1 and C2, and the Central Security Depository (CSD), i.e., A <- C1 <- CSD -> C2 <- B.
-- 3. The cash with CB as custodian is settled off ledger, all other cash and securities are settled on ledger.
-- 4. The CSD does not have to act, rather a direct transfer of a holding (with CSD as custodian) happens from C1 to C2.
-- 5. Intermediary banks/custodians allocate and approve instructions they have with Alice/Bob by a direct credit and debit of Alice's/Bob's accounts, respectively.
-- 6. Alice and Bob allocate and approve their instructions by pledging holdings and taking delivery to their accounts, respectively.

run : Bool -> Script ()
run useDelegatee = script do
  TestParties{..} <- setupParties

  -- Account and holding factory
  let fp = [("FactoryProvider", singleton $ singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory publicParty []
  holdingFactoryCid <- toInterfaceContractId <$> submitMulti [publicParty] [] do
    createCmd Fungible.Factory with provider = publicParty; observers = M.fromList fp

  -- Create accounts
  let createAccounts description custodian = mapA (Account.createAccount description [publicParty] accountFactoryCid holdingFactoryCid [] custodian)
  -- cash
  [aliceCashAccount] <- createAccounts "Cash Account" bank1 [alice]
  [bobCashAccount] <- createAccounts "Cash Account" bank2 [bob]
  [bank1CashAccount, bank2CashAccount] <- createAccounts "Cash Account" cb [bank1, bank2]
  -- asset
  [custodian1DepoAccount, custodian2DepoAccount] <- createAccounts "Securities Account" csd [custodian1, custodian2]
  [aliceDepoAccount] <- createAccounts "Securities Account" custodian2 [alice]
  [custodian1OwnDepoAccount, bobDepoAccount] <- createAccounts "Securities Account" custodian1 [custodian1, bob]

  -- Distribute
  -- cash
  now <- getTime
  cashInstrument <- Instrument.originate cb cb "USD" "United States Doller" [] now
  [aliceCashCid] <- mapA (Account.credit [publicParty] cashInstrument 200_000.0) [aliceCashAccount]

  -- assets
  assetInstrument <- Instrument.originate csd issuer "SHARE" "Stock" [] now
  [bobAssetCid, custodian1AssetCid] <- mapA (Account.credit [publicParty] assetInstrument 1_250.0) [bobDepoAccount, custodian1DepoAccount]

  -- Instruct settlement
  let
    cashQuantity = Instrument.qty 200_000.0 cashInstrument
    assetQuantity = Instrument.qty 1_250.0 assetInstrument
    steps =
      [ -- Payment
        Step with sender = alice; receiver = bank1; quantity = cashQuantity
      , Step with sender = bank1; receiver = bank2; quantity = cashQuantity
      , Step with sender = bank2; receiver = bob; quantity = cashQuantity
        -- Delivery
      , Step with sender = bob; receiver = custodian1; quantity = assetQuantity
      , Step with sender = custodian1; receiver = custodian2; quantity = assetQuantity
      , Step with sender = custodian2; receiver = alice; quantity = assetQuantity
      ]
  -- Create settlement factory
  settlementFactoryCid <- submitMulti [agent] [] do createCmd Factory with provider = agent; observers = empty

  -- Instruct settlement
  (batchCid, [aliceInstructionCid, bank1InstructionCid, bank2InstructionCid, bobInstructionCid, custodian1InstructionCid, custodian2InstructionCid]) <-
    submitMulti [agent] [] do exerciseCmd settlementFactoryCid Factory.Instruct with instructors = singleton agent; settler = agent; id = Id "SHARE 200000.0@160.0USD DVP"; description = "Crosspayment"; steps

  -- Allocate instructions
  aliceInstructionCid <-
    if useDelegatee then
      do
        -- delegate
        delegationCid <- submitMulti [alice] [] do createCmd AllocationDelegation with delegator = alice; delegatee
        -- disclose
        -- TODO: use explicit disclosure (once available)
        let observerContext = ("delegation123", singleton delegatee)
        aliceCashCid : ContractId Transferable.I <- coerceContractId <$> submitMulti [alice] [] do exerciseCmd (coerceContractId aliceCashCid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton alice; observersToAdd = observerContext
        aliceInstructionCid : ContractId Instruction.I <- coerceContractId <$> submitMulti [alice] [] do exerciseCmd (coerceContractId aliceInstructionCid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton alice; observersToAdd = observerContext
        Account.submitExerciseInterfaceByKeyCmd @Disclosure.I [alice] [] aliceCashAccount Disclosure.AddObservers with disclosers = singleton alice; observersToAdd = observerContext
        -- allocate (on behalf of alice)
        instructionCid <- submitMulti [delegatee] [] do exerciseCmd delegationCid OnBehalfAllocation with id = observerContext._1; instructionCid = aliceInstructionCid; transferableCid = aliceCashCid
        -- undisclose
        Account.submitExerciseInterfaceByKeyCmd @Disclosure.I [delegatee] [] aliceCashAccount Disclosure.RemoveObservers with observersToRemove = observerContext
        pure instructionCid
    else
      submitMulti [alice] [] do exerciseCmd aliceInstructionCid Instruction.Allocate with allocation = PLEDGE aliceCashCid
  bank1InstructionCid <- submitMulti [bank1] [] do exerciseCmd bank1InstructionCid Instruction.Allocate with allocation = SETTLE_OFFLEDGER
  bank2InstructionCid <- submitMulti [bank2] [] do exerciseCmd bank2InstructionCid Instruction.Allocate with allocation = CREDIT_RECEIVER
  bobInstructionCid <- submitMulti [bob] [] do exerciseCmd bobInstructionCid Instruction.Allocate with allocation = PLEDGE bobAssetCid
  custodian1InstructionCid <- submitMulti [custodian1] [] do exerciseCmd custodian1InstructionCid Instruction.Allocate with allocation = PLEDGE custodian1AssetCid
  custodian2InstructionCid <- submitMulti [custodian2] [] do exerciseCmd custodian2InstructionCid Instruction.Allocate with allocation = CREDIT_RECEIVER

  -- Approve instructions
  aliceInstructionCid <- submitMulti [bank1] [] do exerciseCmd aliceInstructionCid Instruction.Approve with approval = DEBIT_SENDER
  bank1InstructionCid <- submitMulti [bank2] [] do exerciseCmd bank1InstructionCid Instruction.Approve with approval = SETTLE_OFFLEDGER_ACKNOWLEDGE
  bank2InstructionCid <- submitMulti [bob] [] do exerciseCmd bank2InstructionCid Instruction.Approve with approval = TAKE_DELIVERY bobCashAccount
  bobInstructionCid <- submitMulti [custodian1] [] do exerciseCmd bobInstructionCid Instruction.Approve with approval = DEBIT_SENDER
  custodian1InstructionCid <- submitMulti [custodian2] [] do exerciseCmd custodian1InstructionCid Instruction.Approve with approval = TAKE_DELIVERY custodian2DepoAccount
  custodian2InstructionCid <- submitMulti [alice] [] do exerciseCmd custodian2InstructionCid Instruction.Approve with approval = TAKE_DELIVERY aliceDepoAccount

  -- Settle batch
  [bobCashCid, custodian2AssetCid, aliceAssetCid] <- submitMulti [agent] [publicParty] do exerciseCmd batchCid Batch.Settle

  -- Assert state
  Holding.verifyOwnerOfHolding [(bob, bobCashCid), (custodian2, custodian2AssetCid), (alice, aliceAssetCid)]

  pure ()

setupParties : Script TestParties
setupParties = do
  [cb, csd, bank1, bank2, custodian2, custodian1, issuer, alice, bob, agent, delegatee, publicParty] <-
    createParties ["CentralBank", "CSD", "Bank1", "Bank2", "custodian2", "custodian1", "Issuer", "Alice", "Bob", "Agent", "Delegatee", "PublicParty"]
  pure TestParties with cb; csd; bank1; bank2; custodian2; custodian1; issuer; alice; bob; agent; delegatee; publicParty

-- | Grants the `delegatee` the right to allocate holdings on behalf of the `delegator`
template AllocationDelegation
  with
    delegator : Party
    delegatee : Party
  where
    signatory delegator
    observer delegatee

    choice OnBehalfAllocation : ContractId Instruction.I
      with
        transferableCid : ContractId Transferable.I
          -- ^ The transferable to allocate.
        instructionCid : ContractId Instruction.I
          -- ^ The instruction that needs allocation.
        id : Text
          -- ^ Identifier of the observation context on the transferable, allowing the delegatee to undisclose themselves from a transferable.
      controller delegatee
      do
        Some cid : Optional (ContractId Fungible.T) <- fmap coerceContractId <$> exercise (coerceContractId transferableCid : ContractId Disclosure.I) Disclosure.RemoveObservers with observersToRemove = (id, singleton delegatee)
        fungible <- fetch cid
        exercise instructionCid Instruction.Allocate with allocation = PLEDGE $ coerceContractId cid
