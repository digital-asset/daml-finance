-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Test.Transfer where

import DA.Assert ((===))
import DA.List (head)
import DA.Map qualified as M (fromList)
import DA.Optional (fromSome, isNone, isSome)
import DA.Set qualified as S (empty, fromList, singleton)
import Daml.Finance.Account.Account qualified as Account (T)
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Interface.Account.Account qualified as Account (I, getKey)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I, Split(..))
import Daml.Finance.Interface.Settlement.Factory qualified as Settlement (F, Instruct(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (I, getKey, toKey)
import Daml.Finance.Interface.Settlement.RouteProvider qualified as RouteProvider (Discover(..), I)
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), Step(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey(..), Id(..))
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Settlement.Factory (Factory(..))
import Daml.Finance.Settlement.Instruction qualified as Instruction (T)
import Daml.Finance.Settlement.RouteProvider.SingleCustodian (SingleCustodian(..))
import Daml.Finance.Settlement.Test.Util (allocateAny, approveAny, settleAny)
import Daml.Finance.Test.Util.Account qualified as Account (ControlledBy(..), createAccount, createFactory, credit)
import Daml.Finance.Test.Util.Common (createParties)
import Daml.Finance.Test.Util.Holding qualified as Holding (verifyNoObservers, verifyOwnerOfHolding)
import Daml.Finance.Test.Util.Instrument qualified as Instrument (originate)
import Daml.Script

-- | Parties involved in the test script.
data TestParties = TestParties
  with
    bank : Party
      -- ^ Acts as custodian in the respective holdings and provider of the holding factories.
    cb : Party
      -- ^ Depository and issuer of the cash instrument.
    sender : Party
      -- ^ Sends units of cash to receiver.
    receiver : Party
      -- ^ Receives units of cash from sender.
    ccp : Party
      -- ^ Central counterparty. Passes through cash from the sender to the receiver.
    settler : Party
      -- ^ Executes the settlement of the batch.
    publicParty : Party
      -- ^ The public party. Every party can readAs the public party.

-- Transfer of cash between two parties (sender -> receiver) facilitated by an intermediary (bank).
-- +------------------------------------------+
-- | Accounts                                 |
-- +------------------+-----------------------+
-- | structure:       | used for:             |
-- +------------------+-----------------------+
-- |      Bank        |                       |
-- |      /  \        | commercial bank money |
-- | Sender  Receiver |                       |
-- +------------------+-----------------------+
run : Script ()
run = script do
  TestParties{..} <- setupParties

  -- Account and holding factory
  let pp = [("PublicParty", S.singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory bank pp
  holdingFactoryCid <- toInterfaceContractId <$> submit bank do
    createCmd Fungible.Factory with provider = bank; observers = M.fromList pp

  -- Create accounts
  [senderAccount, receiverAccount] <- mapA (Account.createAccount "Cash Account" []
    accountFactoryCid holdingFactoryCid [] Account.Owner bank) [sender, receiver]

  -- Distribute asset
  now <- getTime
  cashInstrument <- Instrument.originate cb cb "USD" "United States Dollar" [] now
  holdingCid <- Account.credit [] cashInstrument 200_000.0 senderAccount

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId @Settlement.F <$>
    submit bank do createCmd Factory with provider = bank; observers = S.empty

  -- Settlement step
  let step = Step with sender; receiver; quantity = qty 200_000.0 cashInstrument

  -- Discover settlement route for the step
  routeProviderCid <- toInterfaceContractId @RouteProvider.I <$> submit bank do
    createCmd SingleCustodian with provider = bank; observers = S.empty; custodian = bank
  routedSteps <- submit bank do
    exerciseCmd routeProviderCid RouteProvider.Discover with
      discoverors = S.singleton bank; contextId = None; steps = [step]

  -- Instruct transfer
  (batchCid, [instructionCid]) <- submit bank do
    exerciseCmd settlementFactoryCid Settlement.Instruct with
      instructors = S.singleton bank; settlers = S.singleton bank; id = Id "transfer 1"
      description = "transfer of USD 200000.0 payment"; contextId = None; routedSteps
      settlementTime = None

  -- Allocate instruction
  (instructionCid, _) <- allocateAny [sender] instructionCid $ Pledge holdingCid

  -- Holding is locked
  Some cashInstruction <- queryInterfaceContractId sender instructionCid
  let Pledge holdingCid = cashInstruction.allocation
  Some holding <- queryInterfaceContractId sender holdingCid
  assertMsg "holding is locked" $ isSome holding.lock

  -- Can't split the holding (as it is locked)
  submitMustFail sender do
    exerciseCmd (fromInterfaceContractId @Fungible.I holdingCid) Fungible.Split with
      amounts = [1.0, 2.0]

  -- Cancel allocation
  (instructionCid, Some holdingCid) <- allocateAny [sender] instructionCid $ Unallocated

  -- Holding is not locked
  Some holding <- queryInterfaceContractId sender holdingCid
  assertMsg "holding is not locked" $ isNone holding.lock

  -- Allocate instruction
  (instructionCid, _) <- allocateAny [sender] instructionCid $ Pledge holdingCid

  -- Approve instruction
  instructionCid <- approveAny [receiver] instructionCid $ TakeDelivery receiverAccount

  -- Settle batch
  [cashHoldingCid] <- settleAny [bank] [publicParty] batchCid

  -- Assert state
  let ts = [(receiver, cashHoldingCid)]
  Holding.verifyOwnerOfHolding ts
  Holding.verifyNoObservers ts

  pure ()

-- Multiple transfers can be processed in any order. To achieve this, each transfer process
-- discloses/undiscloses accounts/holdings under different contexts to not affect each other. In
-- this test, the same accounts and parties are used for 3 cash transfers (sender -> receiver
-- facilitated by an intermediary bank).
-- +------------------------------------------+
-- | Accounts                                 |
-- +------------------+-----------------------+
-- | structure:       | used for:             |
-- +------------------+-----------------------+
-- |      Bank        |                       |
-- |      /  \        | commercial bank money |
-- | Sender  Receiver |                       |
-- +------------------+-----------------------+
run2 : Script ()
run2 = script do
  TestParties{..} <- setupParties

  -- Account and holding factory
  let pp = [("PublicParty", S.singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory bank pp
  holdingFactoryCid <- toInterfaceContractId <$> submit bank do
    createCmd Fungible.Factory with provider = bank; observers = M.fromList pp

  -- Create accounts
  [senderAccount, receiverAccount] <- mapA (Account.createAccount "Cash Account" []
    accountFactoryCid holdingFactoryCid [] Account.Owner bank) [sender, receiver]

  -- Distribute asset
  now <- getTime
  cashInstrument <- Instrument.originate cb cb "USD" "United States Dollar" [] now
  holdingCid1 <- Account.credit [] cashInstrument 100_000.0 senderAccount
  holdingCid2 <- Account.credit [] cashInstrument 200_000.0 senderAccount
  holdingCid3 <- Account.credit [] cashInstrument 300_000.0 senderAccount

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId @Settlement.F <$>
    submit bank do createCmd Factory with provider = bank; observers = S.empty

  -- Settlement steps (to be settled independently)
  let
    id1 = Id "transfer 1"
    id2 = Id "transfer 2"
    id3 = Id "transfer 3"
    first = Step with sender; receiver; quantity = qty 100_000.0 cashInstrument
    second = Step with sender; receiver; quantity = qty 200_000.0 cashInstrument
    third = Step with sender; receiver; quantity = qty 300_000.0 cashInstrument

  -- Discover settlement routes
  routeProviderCid <- toInterfaceContractId @RouteProvider.I <$> submit bank do
    createCmd SingleCustodian with provider = bank; observers = S.empty; custodian = bank
  routedSteps1 <- submit bank do
    exerciseCmd routeProviderCid RouteProvider.Discover with
      discoverors = S.singleton bank; contextId = None; steps = [first]
  routedSteps2 <- submit bank do
    exerciseCmd routeProviderCid RouteProvider.Discover with
      discoverors = S.singleton bank; contextId = None; steps = [second]
  routedSteps3 <- submit bank do
    exerciseCmd routeProviderCid RouteProvider.Discover with
      discoverors = S.singleton bank; contextId = None; steps = [third]

  -- Instruct settlement for transfer 1
  (batchCid1, [instructionCid1]) <- submit bank do
    exerciseCmd settlementFactoryCid Settlement.Instruct with
      instructors = S.singleton bank; settlers = S.singleton bank; id = id1
      description = "transfer of USD 100000.0 payment"; contextId = None; routedSteps = routedSteps1
      settlementTime = None

  -- Instruct settlement for transfer 2
  (batchCid2, [instructionCid2]) <- submit bank do
    exerciseCmd settlementFactoryCid Settlement.Instruct with
      instructors = S.singleton bank; settlers = S.singleton bank; id = id2
      description = "transfer of USD 200000.0 payment"; contextId = None; routedSteps = routedSteps2
      settlementTime = None

  -- Instruct settlement for transfer 3
  (batchCid3, [instructionCid3]) <- submit bank do
    exerciseCmd settlementFactoryCid Settlement.Instruct with
      instructors = S.singleton bank
      settlers = S.singleton bank; id = id3; description = "transfer of USD 300000.0 payment"
      contextId = None; routedSteps = routedSteps3; settlementTime = None

  let
    verifyAccountDisclosureContexts :  AccountKey -> [ContractId Instruction.I] -> Script ()
    verifyAccountDisclosureContexts account instructionCids = do
      current <- (.observers) . snd . head <$> queryFilter @Account.T account.owner
        (\a -> Account.getKey (toInterface @Account.I a) == account)
      expected <- M.fromList <$> mapA
        (\instructionCid -> do
          Some instruction <- queryContractId account.owner
            (fromInterfaceContractId @Instruction.T instructionCid)
          pure ( show $ Instruction.getKey $ toInterface @Instruction.I instruction
               , S.singleton bank
               )
        )
        instructionCids
      current === expected

  -- check account observers
  verifyAccountDisclosureContexts senderAccount []
  verifyAccountDisclosureContexts receiverAccount []

  -- Allocate instruction (in any order)
  -- first
  (instructionCid1, _) <- allocateAny [sender] instructionCid1 $ Pledge holdingCid1
  verifyAccountDisclosureContexts senderAccount [instructionCid1]
  (instructionCid1, Some holdingCid1) <- allocateAny [sender] instructionCid1 $ Unallocated
  verifyAccountDisclosureContexts senderAccount []
  (instructionCid1, _) <- allocateAny [sender] instructionCid1 $ Pledge holdingCid1
  verifyAccountDisclosureContexts senderAccount [instructionCid1]
  -- second
  (instructionCid2, _) <- allocateAny [sender] instructionCid2 $ Pledge holdingCid2
  verifyAccountDisclosureContexts senderAccount [instructionCid1, instructionCid2]
  -- third
  (instructionCid3, _) <- allocateAny [sender] instructionCid3 $ Pledge holdingCid3
  verifyAccountDisclosureContexts senderAccount [instructionCid1, instructionCid2, instructionCid3]

  -- Approve instruction (in any order)
  -- third
  instructionCid3 <- approveAny [receiver] instructionCid3 $ TakeDelivery receiverAccount
  verifyAccountDisclosureContexts receiverAccount [instructionCid3]
  -- first
  instructionCid1 <- approveAny [receiver] instructionCid1 $ TakeDelivery receiverAccount
  verifyAccountDisclosureContexts receiverAccount [instructionCid1, instructionCid3]
  -- second
  instructionCid2 <- approveAny [receiver] instructionCid2 $ TakeDelivery receiverAccount
  verifyAccountDisclosureContexts receiverAccount
    [instructionCid1, instructionCid2, instructionCid3]

  -- Settle transfers (in any order)
  -- second
  [cashHoldingCid2] <- settleAny [bank] [publicParty] batchCid2
  verifyAccountDisclosureContexts senderAccount [instructionCid1, instructionCid3]
  verifyAccountDisclosureContexts receiverAccount [instructionCid1, instructionCid3]
  -- first
  [cashHoldingCid1] <- settleAny [bank] [publicParty] batchCid1
  verifyAccountDisclosureContexts senderAccount [instructionCid3]
  verifyAccountDisclosureContexts receiverAccount [instructionCid3]
  -- third
  [cashHoldingCid3] <- settleAny [bank] [publicParty] batchCid3

  verifyAccountDisclosureContexts senderAccount []
  verifyAccountDisclosureContexts receiverAccount []

  -- Assert state
  let ts = [(receiver, cashHoldingCid1), (receiver, cashHoldingCid2), (receiver, cashHoldingCid3)]
  Holding.verifyOwnerOfHolding ts
  Holding.verifyNoObservers ts

  pure ()

-- Transfer of cash between two parties (sender -> receiver) which can be executed by either party.
-- +------------------------------------------+
-- | Accounts                                 |
-- +------------------+-----------------------+
-- | structure:       | used for:             |
-- +------------------+-----------------------+
-- |      Bank        |                       |
-- |      /  \        | commercial bank money |
-- | Sender  Receiver |                       |
-- +------------------+-----------------------+
run3 : Script ()
run3 = script do
  TestParties{..} <- setupParties

  -- Account and holding factory
  let pp = [("PublicParty", S.singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory bank pp
  holdingFactoryCid <- toInterfaceContractId <$> submit bank do
    createCmd Fungible.Factory with provider = bank; observers = M.fromList pp

  -- Create accounts
  [senderAccount, receiverAccount] <- mapA (Account.createAccount "Cash Account" []
    accountFactoryCid holdingFactoryCid [] Account.Owner bank) [sender, receiver]

  -- Distribute asset
  now <- getTime
  cashInstrument <- Instrument.originate cb cb "USD" "United States Dollar" [] now
  holdingCid <- Account.credit [] cashInstrument 200_000.0 senderAccount

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId @Settlement.F <$> submit bank do
    createCmd Factory with provider = bank; observers = S.singleton publicParty

  -- Discover settlement
  let step = Step with sender; receiver; quantity = qty 200_000.0 cashInstrument
  routeProviderCid <- toInterfaceContractId @RouteProvider.I <$> submit bank do
    createCmd SingleCustodian with provider = bank; observers = S.empty; custodian = bank
  routedSteps <- submit bank do
    exerciseCmd routeProviderCid RouteProvider.Discover with
      discoverors = S.singleton bank; contextId = None; steps = [step]

  -- Instruct transfer
  (batchCid, [instructionCid]) <- submit bank do
    exerciseCmd settlementFactoryCid Settlement.Instruct with
      instructors = S.singleton bank
      settlers = S.fromList [sender, receiver]
      id = Id "transfer 1"
      description = "transfer of USD 200000.0 payment"
      contextId = None
      routedSteps
      settlementTime = None

  -- Allocate instruction
  (instructionCid, _) <- allocateAny [sender] instructionCid $ Pledge holdingCid

  -- Approve instruction
  instructionCid <- approveAny [receiver] instructionCid $ TakeDelivery receiverAccount

  -- Settle batch
  -- either sender, receiver or both can settle
  [cashHoldingCid] <- settleAny [sender] [publicParty] batchCid

  -- Assert state
  let ts = [(receiver, cashHoldingCid)]
  Holding.verifyOwnerOfHolding ts
  Holding.verifyNoObservers ts

  pure ()

-- Transfer of 2 cash holdings in a batch between the same parties and accounts.
-- +------------------------------------------+
-- | Accounts                                 |
-- +------------------+-----------------------+
-- | structure:       | used for:             |
-- +------------------+-----------------------+
-- |      Bank        |                       |
-- |      /  \        | commercial bank money |
-- | Sender  Receiver |                       |
-- +------------------+-----------------------+
run4 : Script ()
run4 = script do
  TestParties{..} <- setupParties

  -- Account and holding factory
  let pp = [("PublicParty", S.singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory bank pp
  holdingFactoryCid <- toInterfaceContractId <$> submit bank do
    createCmd Fungible.Factory with provider = bank; observers = M.fromList pp

  -- Create accounts
  [senderAccount, receiverAccount] <- mapA (Account.createAccount "Cash Account" []
    accountFactoryCid holdingFactoryCid [] Account.Owner bank) [sender, receiver]

  -- Distribute asset
  now <- getTime
  cashInstrument1 <- Instrument.originate cb cb "USD" "United States Dollar" [] now
  holdingCid1 <- Account.credit [] cashInstrument1 200_000.0 senderAccount
  holdingCid2 <- Account.credit [] cashInstrument1 100_000.0 senderAccount

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId @Settlement.F <$> submit bank do
    createCmd Factory with provider = bank; observers = S.singleton publicParty

  -- Settlement steps
  let
    step1 = Step with sender; receiver; quantity = qty 200_000.0 cashInstrument1
    step2 = Step with sender; receiver; quantity = qty 100_000.0 cashInstrument1

  -- Discover settlement routes
  routeProviderCid <- toInterfaceContractId @RouteProvider.I <$> submit bank do
    createCmd SingleCustodian with provider = bank; observers = S.empty; custodian = bank
  routedSteps <- submit bank do
    exerciseCmd routeProviderCid RouteProvider.Discover with
      discoverors = S.singleton bank; contextId = None; steps = [step1, step2]

  -- Instruct transfer
  (batchCid, [instructionCid1, instructionCid2]) <-
    submit bank do
      exerciseCmd settlementFactoryCid Settlement.Instruct with
        instructors = S.singleton bank
        settlers = S.fromList [sender, receiver]
        id = Id "transfer 1"
        description = "transfer of USD 200000.0 and CHF 100000.0 payment"
        contextId = None
        routedSteps
        settlementTime = None

  -- Allocate instruction
  (instructionCid1, _) <- allocateAny [sender] instructionCid1 $ Pledge holdingCid1
  (instructionCid2, _) <- allocateAny [sender] instructionCid2 $ Pledge holdingCid2

  -- Approve instruction
  instructionCid1 <- approveAny [receiver] instructionCid1 $ TakeDelivery receiverAccount
  instructionCid2 <- approveAny [receiver] instructionCid2 $ TakeDelivery receiverAccount

  -- Settle batch
  -- either sender, receiver or both can settle
  [cashHoldingCid1, cashHoldingCid2] <- settleAny [sender] [publicParty] batchCid

  -- Assert state
  let ts = [(receiver, cashHoldingCid1), (receiver, cashHoldingCid2)]
  Holding.verifyOwnerOfHolding ts
  Holding.verifyNoObservers ts

  pure ()

-- Transfer using passthrough (of commercial bank money from Sender to Receiver via CCP).
-- +---------------------------------------------------+
-- | Accounts                                          |
-- +---------------------------+-----------------------+
-- | structure:                | used for:             |
-- +---------------------------+-----------------------+
-- |           Bank            |                       |
-- |      /     |    \         | commercial bank money |
-- | Sender -> CCP -> Receiver |                       |
-- +---------------------------+-----------------------+
run5 : Script ()
run5 = script do
  TestParties{..} <- setupParties

  -- Account and holding factory
  let pp = [("PublicParty", S.singleton publicParty)]
  accountFactoryCid <- toInterfaceContractId <$> Account.createFactory bank pp
  holdingFactoryCid <- toInterfaceContractId <$> submit bank do
    createCmd Fungible.Factory with provider = bank; observers = M.fromList pp

  -- Create accounts
  [senderAccount, ccpAccount, receiverAccount] <- mapA (Account.createAccount "Cash Account" []
    accountFactoryCid holdingFactoryCid [] Account.Owner bank) [sender, ccp, receiver]

  -- Distribute asset
  now <- getTime
  cashInstrument <- Instrument.originate cb cb "USD" "United States Dollar" [] now
  holdingCid <- Account.credit [] cashInstrument 200_000.0 senderAccount

  -- Create settlement factory
  settlementFactoryCid <- toInterfaceContractId @Settlement.F <$>
    submit bank do createCmd Factory with provider = bank; observers = S.empty

  -- Settlement steps
  let
    step1 = Step with sender; receiver = ccp; quantity = qty 200_000.0 cashInstrument
    step2 = Step with sender = ccp; receiver; quantity = qty 200_000.0 cashInstrument

  -- Discover settlement routes
  routeProviderCid <- toInterfaceContractId @RouteProvider.I <$> submit bank do
    createCmd SingleCustodian with provider = bank; observers = S.empty; custodian = bank
  routedSteps <- submit bank do
    exerciseCmd routeProviderCid RouteProvider.Discover with
      discoverors = S.singleton bank
      contextId = None
      steps = [step2, step1] -- order does not matter

  -- Instruct transfer
  (batchCid, [instructionCid1, instructionCid2]) <-
    submit bank do
      exerciseCmd settlementFactoryCid Settlement.Instruct with
        instructors = S.singleton bank
        settlers = S.singleton settler
        id = Id "transfer 1"
        description = "transfer of USD 200000.0 payment"
        contextId = None
        routedSteps
        settlementTime = None

  --
  [instruction1, instruction2] <- fmap (Instruction.toKey . fromSome) <$>
    mapA (queryInterfaceContractId @Instruction.I ccp) [instructionCid1, instructionCid2]

  -- Approve instruction
  instructionCid1 <- approveAny [receiver] instructionCid1 $ TakeDelivery receiverAccount

  -- Approve with passthrough
  instructionCid2 <- approveAny [ccp] instructionCid2 $ PassThroughTo (ccpAccount, instruction1)

  -- Allocate with passthrough
  (instructionCid1, _) <- allocateAny [ccp] instructionCid1 $
    PassThroughFrom (ccpAccount, instruction2)

  -- Allocate instruction
  (instructionCid2, _) <- allocateAny [sender] instructionCid2 $ Pledge holdingCid

  -- Settle batch
  [cashHoldingCid] <- settleAny [settler] [publicParty] batchCid

  -- Assert state
  let ts = [(receiver, cashHoldingCid)]
  Holding.verifyOwnerOfHolding ts
  Holding.verifyNoObservers ts

  pure ()

setupParties : Script TestParties
setupParties = do
  [cb, bank, sender, receiver, ccp, settler, publicParty] <-
    createParties ["CentralBank", "Bank", "Sender", "Receiver", "CCP", "Settler", "PublicParty"]
  pure TestParties with cb; bank; sender; receiver; ccp; settler; publicParty
