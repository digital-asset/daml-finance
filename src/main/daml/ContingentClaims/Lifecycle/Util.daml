-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | This module defines a set of utility functions to extract information from claim trees.
module ContingentClaims.Lifecycle.Util (
    expiry
  , fixings
  , isZero
  , payoffs
  , pruneZeros
  , pruneZeros'
) where

import ContingentClaims.Core.Internal.AcquisitionTime (AcquisitionTime(..), afterOrAtToday, extend)
import ContingentClaims.Core.Internal.Claim (Claim(..), ClaimF(..), Inequality(..))
import ContingentClaims.Core.Observation (Observation, ObservationF(..))
import DA.Bifunctor (first)
import DA.Foldable (all, fold, maximum)
import Daml.Control.Recursion (Corecursive(..), Recursive(..), cata)
import Prelude hiding (all, sequence, sum, mapA)

-- | Return the fixing dates of a claim. This does not discriminate between optional dates which
-- *may* result from a condition, and outright fixings. It also does not correctly account for
-- malformed trees, where subtrees are orphaned due to impossible `When` statements, e.g.,
-- `When (t > 1) ((When t < 1) _)`.
fixings : Claim t x a o -> [t]
fixings = cata fixings'

-- | Algebra for `fixings`.
fixings' : ClaimF t x a o [t] -> [t]
fixings' (WhenF (TimeGte t) ts) = t :: ts
fixings' claim = fold claim

-- | Return the time after which the claim is worthless, i.e., value = 0, if such a time exists.
-- Also known as 'maturity' or 'horizon' in the Eber/Jones paper.
expiry : Ord t => Claim t x a o -> Optional t
expiry c = case fixings c of
  [] -> None
  ts -> Some . maximum $ ts

-- | Return a list of possible scale-factor/payoff pairs.
-- This does not discriminate between conditional and outright payoffs.
payoffs : (Eq t, Eq x, Eq o, Multiplicative x) => Claim t x a o -> [(Observation t x o, a)]
payoffs = fmap (first ($ munit)) . cata payoffs'

-- | Algebra for `payoffs`. This also applies 'multiplication by one' identity,
payoffs' : (Eq t, Eq x, Eq o, Multiplicative x) =>
  ClaimF t x a o [(Observation t x o -> Observation t x o, a)] ->
  [(Observation t x o -> Observation t x o, a)]
payoffs' ZeroF = []
payoffs' (OneF a) = [(identity, a)]
payoffs' (ScaleF k fs) = first multK <$> fs where
  multK f x | x == munit = f k -- prune unit
  multK f x = f (x * k)
payoffs' other = fold other

-- | Prunes sub-trees which are `Zero`.
pruneZeros : Claim t x a o -> Claim t x a o
pruneZeros = cata pruneZeros'

-- | HIDE
-- Algebra for `pruneZeros`. N.b. the `Or` case : we only reduce the case when all elements are
-- `Zero`. It's incorrect to remove a single `Or` (as this would remove a choice for 'inaction' from
-- the bearer - think option lapse). However, we don't handle the case for `Or > 1`, as this can be
-- unintuitive (although semantically correct); this may change in the future, so don't rely on this
-- behaviour.
pruneZeros' : ClaimF t x a o (Claim t x a o) -> Claim t x a o
pruneZeros' (ScaleF _ Zero) = Zero
pruneZeros' (GiveF Zero) = Zero
pruneZeros' (AndF c c' cs) = case filter (not . isZero) (c :: c' :: cs) of
  [] -> Zero
  [c] -> c
  c :: c' :: cs -> And c c' cs
pruneZeros' (WhenF _ Zero) = Zero
pruneZeros' (CondF _ Zero Zero) = Zero
pruneZeros' ors@OrF{} | isZero `all` ors = Zero
pruneZeros' (UntilF _ Zero) = Zero
pruneZeros' (AnytimeF _ (_, Zero)) = Zero
pruneZeros' other = embed other

-- | Checks if a claim is the `Zero` claim.
-- This avoids requiring the equality type constraint on `a`.
isZero Zero = True
isZero _ = False

-- How do we handle the actual acquisition time of Until nodes?
-- We would need to introduce a negation
-- for now we can write a propagate minimal acquisition time function
acquire' : (Ord t, Eq a)
  => (AcquisitionTime t x o, Claim t x a o)
    -- ^ Input claim in functor form and its acquisition time.
  -> ClaimF t x a o (AcquisitionTime t x o, Claim t x a o)
-- acquire' _ _ (s, When (TimeLte t) c) =
--   pure $ WhenF (TimeLte t) if t < s then Left c else Right (s, c)
acquire' (s, c@(When (Lte _) _)) = (s, ) <$> project c
acquire' (s, c@(When obs _)) = (extend obs s, ) <$> project c
acquire' (s, other) = (s, ) <$> project other

-- I need to access the current node's acquisition time in the cata function --> how to do that?
-- Do I need to write a custom hylo function or something along those lines?
verify : ClaimF t x a o (AcquisitionTime t x o, Claim t x a o) -> Bool
verify _ = True

isWellDefined : (Ord t) => AcquisitionTime t x o -> Observation t x o -> Bool
isWellDefined t obs = cata alg obs
  where
    alg = \case
      ConstF _ -> True
      ObserveF _ -> True
      ObserveAtF _ t' -> afterOrAtToday t' t
      AddF (x, x') -> x && x'
      NegF x -> x
      MulF (x, x') -> x && x'
      DivF (x, x') -> x && x'

-- we need to define a new recursive type (t, Claim) (, ClaimF) as the corresponding functor

