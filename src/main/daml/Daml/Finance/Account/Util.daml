-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Account.Util where

import DA.Set qualified as S (isSubsetOf, member)
import Daml.Finance.Holding.Util (reapplyLocks, releaseAll)
import Daml.Finance.Interface.Account.Account qualified as Account (Credit(..), CreditAndDebit(..), Debit(..), I, exerciseInterfaceByKey)
import Daml.Finance.Interface.Account.Util (getOwner)
import Daml.Finance.Interface.Holding.Base (getLockers)
import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Types.Common (AccountKey(..))

-- | Default implementation of `creditAndDebit` from the `Account` interface.
creditAndDebitImpl : AccountKey -> Account.CreditAndDebit -> Update (ContractId Base.I)
creditAndDebitImpl account Account.CreditAndDebit{baseCid; actors} = do
  base <- fetch baseCid
  let vH = view base
  assertMsg "custodians must be the same" $ vH.account.custodian == account.custodian
  assertMsg "actors must contain lockers" $ S.isSubsetOf (getLockers base) actors
  assertMsg "actors must contain the owner (of the provided holding)" $
    S.member (getOwner base) actors
  -- Release all locks
  holdingCid <- toInterfaceContractId @Base.I <$>
    optional (pure baseCid) (releaseAll baseCid) vH.lock
  -- Debit holding
  Account.exerciseInterfaceByKey @Account.I vH.account vH.account.owner Account.Debit with
    holdingCid
  -- Credit holding
  newBaseCid <- Account.exerciseInterfaceByKey @Account.I account account.owner Account.Credit with
    quantity = Instrument.qty vH.amount vH.instrument
  -- Consistency check
  newBase <- fetch newBaseCid
  assertMsg "credited and debited holding types must match" $
    interfaceTypeRep newBase == interfaceTypeRep base
  -- Reapply locks
  optional (pure newBaseCid) (reapplyLocks newBaseCid) vH.lock
