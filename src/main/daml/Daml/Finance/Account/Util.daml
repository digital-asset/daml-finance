-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Account.Util
  ( creditAndDebitImpl
  ) where

import DA.Action (foldlA)
import DA.Set qualified as S (isSubsetOf, member, toList)
import Daml.Finance.Interface.Account.Account qualified as Account (Credit(..), CreditAndDebit(..), Debit(..), I, exerciseInterfaceByKey)
import Daml.Finance.Interface.Account.Util (getOwner)
import Daml.Finance.Interface.Holding.Base (getLockers)
import Daml.Finance.Interface.Holding.Base qualified as Base (Acquire(..), I, Lock, Release(..))
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Types.Common (AccountKey(..))

-- | Default implementation of `creditAndDebit` from the `Account` interface.
creditAndDebitImpl : AccountKey -> Account.CreditAndDebit -> Update (ContractId Base.I)
creditAndDebitImpl account Account.CreditAndDebit{baseCid; actors} = do
  base <- fetch baseCid
  let vH = view base
  assertMsg "custodians must be the same" $ vH.account.custodian == account.custodian
  assertMsg "actors must contain lockers" $ S.isSubsetOf (getLockers base) actors
  assertMsg "actors must contain the owner (of the provided holding)" $
    S.member (getOwner base) actors
  -- Release all locks
  holdingCid <- toInterfaceContractId @Base.I <$>
    optional (pure baseCid) (releaseAll baseCid) vH.lock
  -- Debit holding
  Account.exerciseInterfaceByKey @Account.I vH.account vH.account.owner Account.Debit with
    holdingCid
  -- Credit holding
  newBaseCid <- Account.exerciseInterfaceByKey @Account.I account account.owner Account.Credit with
    quantity = Instrument.qty vH.amount vH.instrument
  -- Consistency check
  newBase <- fetch newBaseCid
  assertMsg "credited and debited holding types must match" $
    interfaceTypeRep newBase == interfaceTypeRep base
  -- Reapply locks
  optional (pure newBaseCid) (reapplyLocks newBaseCid) vH.lock

-- | HIDE Utility function to reapply holding locks.
reapplyLocks :  ContractId Base.I -> Base.Lock -> Update (ContractId Base.I)
reapplyLocks cid lock = foldlA (\acc context -> exercise acc Base.Acquire with
  newLockers = lock.lockers; context; lockType = lock.lockType) cid (S.toList lock.context)

-- | HIDE Utility function to unlock all holding locks.
releaseAll : ContractId Base.I -> Base.Lock -> Update (ContractId Base.I)
releaseAll cid lock =
  foldlA (\acc context -> exercise acc Base.Release with context) cid (S.toList lock.context)
