-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Account.Account where

import DA.Map qualified as M (empty)
import DA.Optional (fromSome, isNone, isSome)
import DA.Set qualified as S (empty, fromList, null, singleton)
import Daml.Finance.Interface.Account.Account qualified as Account (Controllers(..), Credit(..), Debit(..), Freeze(..), Frozen, GetCid(..), I, R, View(..), createReference, disclosureUpdateReference)
import Daml.Finance.Interface.Account.Factory qualified as AccountFactory (Create(..), F, Remove(..), View(..))
import Daml.Finance.Interface.Holding.Factory qualified as HoldingFactory (Create(..), F, Remove(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey(..), Id, PartiesMap)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I, RemoveObservers(..), View(..), flattenObservers)
import Daml.Finance.Util.Disclosure (addObserversImpl, removeObserversImpl, setObserversImpl)

-- | Type synonym for `Account`.
type T = Account

-- | A relationship between a custodian and an asset owner. It is referenced by holdings.
template Account
  with
    custodian : Party
      -- ^ The account provider.
    owner : Party
      -- ^ The account owner.
    controllers : Account.Controllers
      -- ^ Controllers of transfers and freezes.
    id : Id
      -- ^ Identifier of the account.
    description : Text
      -- ^ Description of the account.
    holdingFactoryCid : ContractId HoldingFactory.F
      -- ^ Associated holding factory.
    frozen : Optional Account.Frozen
      -- ^ Frozen account (if any).
    observers : PartiesMap
      -- ^ Observers.
  where
    let
      account = AccountKey with custodian; owner; id
      mustNotBeFrozen = assertMsg @Update "account must not be frozen" $ isNone frozen
      contextFrozen = "Frozen"
      unfreezers = optional S.empty (.unfreezers) frozen

    signatory custodian, owner, unfreezers
    observer Disclosure.flattenObservers observers

    -- Outgoing controllers must be non-empty, and unfreezers must be non-empty if set.
    ensure (not . S.null $ controllers.outgoing) && not (isSome frozen && S.null unfreezers)

    interface instance Account.I for Account where
      view = Account.View with
        custodian; id; owner; holdingFactoryCid; description; controllers; frozen
      getKey = account
      credit Account.Credit{quantity} = do
        mustNotBeFrozen
        exercise holdingFactoryCid HoldingFactory.Create with
          instrument = quantity.unit
          account
          amount = quantity.amount
          observers = M.empty
      debit Account.Debit{holdingCid} = do
        mustNotBeFrozen
        vHolding <- view <$> fetch holdingCid
        assertMsg "accounts must match" $ vHolding.account == account
        exercise holdingFactoryCid HoldingFactory.Remove with
          actors = S.fromList [account.custodian, account.owner]; holdingCid
      freeze Account.Freeze{frozen} = do
        mustNotBeFrozen
        newCid <- toInterfaceContractId @Disclosure.I <$> create this with frozen = Some frozen
        -- adding freezers as observers to Account.R
        coerceInterfaceContractId @Account.I <$> exercise newCid Disclosure.AddObservers with
          disclosers = S.fromList (signatory this) <> frozen.unfreezers
          observersToAdd = (frozen.context, frozen.unfreezers)
      unfreeze = do
        assertMsg @Update "account must be frozen" $ isSome frozen
        let frozen = fromSome this.frozen

        newCid <- toInterfaceContractId <$> create this with frozen = None
        -- removing freezers as observers to Account.R
        optional newCid coerceContractId <$>
          exercise (toInterfaceContractId @Disclosure.I newCid)
            Disclosure.RemoveObservers with
              disclosers = S.fromList (signatory this) <> frozen.unfreezers
              observersToRemove = (frozen.context, frozen.unfreezers)

    interface instance Disclosure.I for Account where
      view = Disclosure.View with disclosureControllers = S.fromList [custodian, owner]; observers
      setObservers = setObserversImpl this $ Some (Account.disclosureUpdateReference account)
      addObservers = addObserversImpl this $ Some (Account.disclosureUpdateReference account)
      removeObservers = removeObserversImpl this $ Some (Account.disclosureUpdateReference account)

-- | Template used to create accounts.
template Factory
  with
    provider : Party
      -- ^ The factory's provider.
    observers : PartiesMap
      -- ^ The factory's observers.
  where
    signatory provider
    observer Disclosure.flattenObservers observers

    interface instance AccountFactory.F for Factory where
      view = AccountFactory.View with provider
      create' AccountFactory.Create {account; holdingFactoryCid; controllers; observers;
        description} = do
          cid <- toInterfaceContractId <$> create Account with
            custodian = account.custodian; owner = account.owner; controllers; id = account.id
            description; holdingFactoryCid; frozen = None; observers
          Account.createReference account.custodian cid
          pure cid
      remove AccountFactory.Remove{account} = do
        (refCid, ref) <- fetchByKey @Account.R account
        accountCid <- exercise refCid Account.GetCid with viewer = account.custodian
        archive $ fromInterfaceContractId @Account accountCid
        archive refCid

    interface instance Disclosure.I for Factory where
      view = Disclosure.View with disclosureControllers = S.singleton provider; observers
      setObservers = setObserversImpl @Factory @Disclosure.I this None
      addObservers = addObserversImpl @Factory @Disclosure.I this None
      removeObservers = removeObserversImpl @Factory @Disclosure.I this None
