-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Common.Date.DayCount
  ( DayCountConventionEnum(..)
  , calcDcf
  , calcDcf30E360
  , calcPeriodDcf
  , calcPeriodDcfActActIsda
  , calcPeriodDcfActActIsma
  ) where

import DA.Date
import Daml.Finance.Common.Date.RollConvention (next, Period(..), PeriodEnum(..), previous)
import Daml.Finance.Common.Date.Schedule (Frequency, SchedulePeriod, StubPeriodTypeEnum(..))

-- | An enum type to specify a day count convention used to calculate day count fractions.
-- For a detailed definition of each convention, we refer to the "Method of Interest Computation Indicator" definitions in the context of the ISO-20022 standard. Where useful, we provide disambiguation comments.
data DayCountConventionEnum
  = Act360
  -- ^ Actual 360.
  | Act365_Fixed
  -- ^ Actual 365 fixed.
  | ActAct_ISDA
  -- ^ Actual Actual ISDA
  | ActAct_ISMA
  -- ^ Actual Actual ISMA
  | Basis_30360
  -- ^ 30/360 (also, 30/360 ISDA or A001 or American Basic rule)
  | Basis_30360_ICMA
  -- ^ 30/360 ICMA (also, A011 or Basic Rule). This corresponds to "30E/360" of the 2006 ISDA definitions.
  | Basis_30E360
  -- ^ 30E/360 (also, A007 or Eurobond basis). This corresponds to "30E360 (ISDA)" of the 2006 ISDA definitions.
  | Basis_30E3360
  -- ^ 30E3/360 (also, A013 or Eurobond basis model 3).
  deriving (Eq, Show)

-- | Calculates the day count fraction given the correponding convention.
-- Currently 30E360 is not supported as we do not want to expose the maturity date of the product as an additional parameter.
calcDcf : DayCountConventionEnum -> Date -> Date -> Decimal
calcDcf _ f t | f > t = error "fromDate is greater than toDate"
calcDcf Act360 f t = calcDcfAct360 f t
calcDcf Act365_Fixed f t = calcDcfAct365Fixed f t
calcDcf ActAct_ISDA f t = error "This calculation requires the knowledge of the stub period. Please, call `calcPeriodDcf` instead."
calcDcf ActAct_ISMA f t = error "This calculation requires the knowledge of the stub period. Please, call `calcPeriodDcf` instead."
calcDcf Basis_30360 f t = calcDcf30360 f t
calcDcf Basis_30360_ICMA f t = calcDcf30360Icma f t
calcDcf Basis_30E3360 f t = calcDcf30E360 False f t -- this corresponds to 30E/360 without the maturity date adjustment
calcDcf Basis_30E360 f t = error "This calculation requires the knowledge of the maturity date of the product. Please, use `calcDcf30E360` instead."

-- | Calculate day count fraction for a schedule period
calcPeriodDcf : DayCountConventionEnum -> SchedulePeriod -> Date -> Frequency -> Decimal
calcPeriodDcf Act360 p maturityDate frequency = calcDcf Act360 p.adjustedStartDate p.adjustedEndDate
calcPeriodDcf Act365_Fixed p maturityDate frequency = calcDcf Act365_Fixed p.adjustedStartDate p.adjustedEndDate
calcPeriodDcf ActAct_ISDA p maturityDate frequency = calcPeriodDcfActActIsda p maturityDate
calcPeriodDcf ActAct_ISMA p maturityDate frequency = calcPeriodDcfActActIsma p maturityDate frequency
calcPeriodDcf Basis_30360 p maturityDate frequency = calcDcf Basis_30360 p.adjustedStartDate p.adjustedEndDate
calcPeriodDcf Basis_30360_ICMA p maturityDate frequency = calcDcf Basis_30360_ICMA p.adjustedStartDate p.adjustedEndDate
calcPeriodDcf Basis_30E3360 p maturityDate frequency = calcDcf Basis_30E3360 p.adjustedStartDate p.adjustedEndDate
calcPeriodDcf Basis_30E360 p maturityDate frequency = calcDcf Basis_30E360 p.adjustedStartDate p.adjustedEndDate

-- | Calculate Actual Actual day count fraction according to the ISDA method
calcPeriodDcfActActIsda : SchedulePeriod -> Date -> Decimal
calcPeriodDcfActActIsda p maturityDate =
  let
    (y1, m1, d1) = toGregorian p.adjustedStartDate
    (y2, m2, d2) = toGregorian p.adjustedEndDate
  in
    -- DCF calculation depends on whether coupon period spans over year-end (more than one calendar year involved?)
    case y2 - y1 of
      0 -> intToDecimal nDaysY1 / intToDecimal nTotDaysY1
            where
              nDaysY1 = subDate p.adjustedEndDate p.adjustedStartDate
              nTotDaysY1 = if isLeapYear y1 && maturityDate >= getDateEndOfFebruary y1 then 366 else 365
      1 -> intToDecimal nDaysY1 / intToDecimal nTotDaysY1 + intToDecimal nDaysY2 / intToDecimal nTotDaysY2
            where
              dateYearEnd = fromGregorian (y1, Dec, 31)
              nDaysY1 = subDate dateYearEnd p.adjustedStartDate + 1
              nDaysY2 = subDate p.adjustedEndDate dateYearEnd - 1
              nTotDaysY1 = if isLeapYear y1 then 366 else 365
              nTotDaysY2 = if isLeapYear y2 && maturityDate >= getDateEndOfFebruary y2 then 366 else 365
      _ -> error "The coupon end date must be in the same or in the following calendar year"

-- | Calculate Actual Actual day count fraction according to the ISMA method
calcPeriodDcfActActIsma : SchedulePeriod -> Date -> Frequency -> Decimal
calcPeriodDcfActActIsma p maturityDate frequency =
  let
    nDays = subDate p.adjustedEndDate p.adjustedStartDate
    nPeriodsPerYear = if frequency.period == M then 12.0 / intToDecimal frequency.periodMultiplier else error "only monthly period currently supported"
    period = Period with
      period = frequency.period
      periodMultiplier = frequency.periodMultiplier
  in
    -- DCF calculation depends on the type of period (regular or stub)
    case p.stubType of
      None -> (intToDecimal nDays) / (intToDecimal nDays * nPeriodsPerYear)
      Some SHORT_INITIAL -> (intToDecimal nDays) / (intToDecimal (subDate p.adjustedEndDate notionalStartDate) * nPeriodsPerYear)
        where
          notionalStartDate = previous p.adjustedEndDate period frequency.rollConvention
      Some LONG_INITIAL -> (intToDecimal nDaysP1) / (intToDecimal nDaysP1 * nPeriodsPerYear) + (intToDecimal nDaysP2) / (intToDecimal (subDate notionalPaymentDate notionalStartDate) * nPeriodsPerYear)
        where
          notionalPaymentDate = previous p.adjustedEndDate period frequency.rollConvention
          notionalStartDate = previous notionalPaymentDate period frequency.rollConvention
          nDaysP1 = subDate p.adjustedEndDate notionalPaymentDate
          nDaysP2 = subDate notionalPaymentDate p.adjustedStartDate
      Some SHORT_FINAL -> (intToDecimal nDays) / (intToDecimal (subDate notionalMaturityDate p.adjustedStartDate) * nPeriodsPerYear)
        where
          notionalMaturityDate = next p.adjustedStartDate period frequency.rollConvention
      Some LONG_FINAL -> (intToDecimal nDaysP1) / (intToDecimal nDaysP1 * nPeriodsPerYear) + (intToDecimal nDaysP2)/ (intToDecimal (subDate notionalMaturityDate notionalPaymentDate) * nPeriodsPerYear)
        where
          notionalPaymentDate = next p.adjustedStartDate period frequency.rollConvention
          notionalMaturityDate = next notionalPaymentDate period frequency.rollConvention
          nDaysP1 = subDate notionalPaymentDate p.adjustedStartDate
          nDaysP2 = subDate p.adjustedEndDate notionalPaymentDate

-- | HIDE
-- | Calculate Actual 360 day count fraction.
calcDcfAct360 : Date -> Date -> Decimal
calcDcfAct360 fromDate toDate =
  (/ 360.0) . intToDecimal $ subDate toDate fromDate

-- | HIDE
-- | Calculate Actual 365 (Fixed) day count fraction.
calcDcfAct365Fixed : Date -> Date -> Decimal
calcDcfAct365Fixed fromDate toDate =
  (/ 365.0) . intToDecimal $ subDate toDate fromDate

-- | HIDE
-- | Calculate 30/360 day count fraction. This is also known as the '30/360 (ISDA)' or 'Bond Basis' day count convention.
calcDcf30360 : Date -> Date -> Decimal
calcDcf30360 fromDate toDate =
  let
    d1Adj = if d1 == 31 then 30 else d1
    d2Adj = if d2 == 31 && d1 > 29 then 30 else d2
  in
    calc30360Formula (y1, m1, d1Adj) (y2, m2, d2Adj)
  where
    (y1, m1, d1) = toGregorian fromDate
    (y2, m2, d2) = toGregorian toDate

-- | HIDE
-- | Calculate 30/360 ICMA day count fraction.
calcDcf30360Icma : Date -> Date -> Decimal
calcDcf30360Icma fromDate toDate =
  let
    adjust d = if d == 31 then 30 else d
  in
    calc30360Formula (y1, m1, adjust d1) (y2, m2, adjust d2)
  where
    (y1, m1, d1) = toGregorian fromDate
    (y2, m2, d2) = toGregorian toDate

-- | Calculate 30E/360 day count fraction.
calcDcf30E360 : Bool -> Date -> Date -> Decimal
calcDcf30E360 _ fromDate toDate | fromDate > toDate =
  error "fromDate is greater than toDate"
calcDcf30E360 toDateIsMaturityDate fromDate toDate =
  let
    d1Adj = if d1 == monthDayCount y1 m1 then 30 else d1
    d2Adj = if d2 == 31 || not toDateIsMaturityDate && isEndOfFebruary (y2, m2, d2) then 30 else d2
  in
    calc30360Formula (y1, m1, d1Adj) (y2, m2, d2Adj)
  where
    (y1, m1, d1) = toGregorian fromDate
    (y2, m2, d2) = toGregorian toDate

-- | HIDE
calc30360Formula : (Int, Month, Int) -> (Int, Month, Int) -> Decimal
calc30360Formula (y1, m1, d1) (y2, m2, d2) =
  (/ 360.0) . intToDecimal $ 360 * (y2-y1) + 30 * (fromMonth m2 - fromMonth m1) + (d2-d1)

-- | HIDE
isEndOfFebruary : (Int, Month, Int) -> Bool
isEndOfFebruary (y, m, d) =
  m == Feb && d == monthDayCount y m

-- | HIDE
getDateEndOfFebruary : Int -> Date
getDateEndOfFebruary y =
  fromGregorian (y, Feb, monthDayCount y Feb)
