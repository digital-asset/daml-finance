-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Holding.Account where

import DA.Map qualified as M (empty)
import DA.Set qualified as S (fromList, isSubsetOf, member, singleton)
import Daml.Finance.Holding.Util (reapplyLocks, releaseAll)
import Daml.Finance.Interface.Holding.Account qualified as Account (Credit(..), Debit(..), GetCid(..), HasImplementation, I, R, Transfer(..), View(..), createReference, disclosureUpdateReference, exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Holding.Factory.Account qualified as AccountFactory (Create(..), F, HasImplementation, Remove(..), View(..))
import Daml.Finance.Interface.Holding.Factory.Holding qualified as HoldingFactory (Create(..), F, Remove(..))
import Daml.Finance.Interface.Holding.Lockable (getLocker)
import Daml.Finance.Interface.Holding.Lockable qualified as Lockable (I)
import Daml.Finance.Interface.Holding.Util (getOwner)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Types.Common (Id, AccountKey(..), PartiesMap, Transferors(..))
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, SetObservers(..), View(..), flattenObservers)

-- | Type synonym for `Account`.
type T = Account

instance Account.HasImplementation T
-- | A relationship between a custodian and an asset owner. It is referenced by holdings.
template Account
  with
    custodian : Party
      -- ^ The account provider.
    owner : Party
      -- ^ The account owner.
    id : Id
      -- ^ Identifier of the account.
    description : Text
      -- ^ Description of the account.
    holdingFactoryCid : ContractId HoldingFactory.F
      -- ^ Associated holding factory.
    observers : PartiesMap
      -- ^ Observers.
  where
    signatory custodian, owner
    observer Disclosure.flattenObservers observers

    let
      account = AccountKey with custodian; owner; id
      transferors = Transferors with instructors = S.singleton owner; approvers = S.singleton owner

    interface instance Account.I for Account where
      asDisclosure = toInterface @Disclosure.I this
      view = Account.View with custodian; id; owner; holdingFactoryCid; description; transferors
      getKey = account
      credit Account.Credit{quantity} =
        exercise holdingFactoryCid HoldingFactory.Create with
          instrument = quantity.unit
          account
          amount = quantity.amount
          observers = M.empty
      debit Account.Debit{holdingCid} = do
        vHolding <- view <$> fetch holdingCid
        assertMsg "accounts must match" $ vHolding.account == account
        exercise holdingFactoryCid HoldingFactory.Remove with actors = S.fromList [account.custodian, account.owner]; holdingCid
      transfer Account.Transfer{transferableCid; actors} = do
        let lockableCid = toInterfaceContractId @Lockable.I transferableCid
        lockable <- fetch lockableCid
        let
          vH = view $ toInterface @Base.I lockable
          vL = view $ toInterface @Lockable.I lockable
        assertMsg "custodians must be the same" $ vH.account.custodian == custodian
        assertMsg "actors must contain lockers" $ S.isSubsetOf (getLocker lockable) actors
        assertMsg "actors must contain the owner (of the provided transferable)" $ S.member (getOwner lockable) actors
        -- Release all locks
        transferableCid <- toInterfaceContractId @Base.I <$> optional (pure lockableCid) (releaseAll lockableCid) vL.lock
        -- Debit holding
        Account.exerciseInterfaceByKey @Account.I vH.account vH.account.owner Account.Debit with holdingCid = transferableCid
        -- Credit holding
        newLockableCid <- coerceContractId <$> Account.exerciseInterfaceByKey @Account.I account owner Account.Credit with quantity = Instrument.qty vH.amount vH.instrument
        -- Consistency check
        newLockble <- fetch newLockableCid
        assertMsg "credited and debited holding types must match" $ interfaceTypeRep newLockble == interfaceTypeRep lockable
        -- reapply locks
        coerceContractId <$> optional (pure newLockableCid) (reapplyLocks newLockableCid) vL.lock

    interface instance Disclosure.I for Account where
      view = Disclosure.View with disclosureControllers = S.fromList [owner, custodian]; observers
      setObservers Disclosure.SetObservers{newObservers} = do
        cid <- create this with observers = newObservers
        Account.disclosureUpdateReference newObservers account (toInterfaceContractId @Account.I cid)
      archive' self = archive (coerceContractId self : ContractId Account)

instance AccountFactory.HasImplementation Factory
-- | Template used to create accounts.
template Factory
  with
    provider : Party
      -- ^ The factory's provider.
    observers : PartiesMap
      -- ^ The factory's observers.
  where
    signatory provider
    observer Disclosure.flattenObservers observers

    interface instance AccountFactory.F for Factory where
      asDisclosure = toInterface @Disclosure.I this
      view = AccountFactory.View with provider
      create' AccountFactory.Create{account; holdingFactoryCid; observers; description} = do
        cid <- toInterfaceContractId <$> create Account with custodian = account.custodian; owner = account.owner; id = account.id; holdingFactoryCid; observers; description
        Account.createReference account.custodian cid
        pure cid
      remove AccountFactory.Remove{account} = do
        (refCid, ref) <- fetchByKey @Account.R account
        accountCid <- exercise refCid Account.GetCid with viewer = account.custodian
        archive $ fromInterfaceContractId @Account accountCid
        archive refCid

    interface instance Disclosure.I for Factory where
      view = Disclosure.View with disclosureControllers = S.singleton provider; observers
      setObservers Disclosure.SetObservers{newObservers} = toInterfaceContractId <$> create this with observers = newObservers
      archive' self = archive (coerceContractId self : ContractId Account)
