-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Finance.Holding.NonTransferable where

import DA.Set (delete, insert, null, singleton)
import Daml.Finance.Interface.Holding.Base qualified as Base (I, View(..))
import Daml.Finance.Interface.Holding.Factory.Holding qualified as HoldingFactory (Create(..), F, HasImplementation(..), Remove(..), View(..))
import Daml.Finance.Interface.Holding.Lockable qualified as Lockable (Acquire(..), I, Lock(..), LockType(..), Release(..), View(..))
import Daml.Finance.Interface.Holding.Lockable qualified as NonTransferable (HasImplementation)
import Daml.Finance.Interface.Holding.Util (getLocker)
import Daml.Finance.Interface.Types.Common (AccountKey(..), InstrumentKey(..), PartiesMap)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, SetObservers(..), View(..), flattenObservers)
import Prelude hiding (null)

-- | Type synonym for `Factory`.
type F = Factory

-- | Type synonym for `NonTransferable`.
type T = NonTransferable

instance NonTransferable.HasImplementation T
-- | Implementation of a non-transferable holding.
-- `NonTransferable` implements the interface `Lockable.I` (which requires `Base.I`, and
-- `Disclosure.I` to be implemented as well).
template NonTransferable
  with
    instrument : InstrumentKey
      -- ^ The instrument of which units are held.
    account : AccountKey
      -- ^ The account at which the holding is held. Defines the holding's owner and custodian.
    amount : Decimal
      -- ^ Number of units.
    lock : Optional Lockable.Lock
      -- ^ An optional lock of a holding.
    observers : PartiesMap
      -- ^ Observers.
  where
    signatory account.custodian, account.owner, getLocker this
    observer Disclosure.flattenObservers observers

    ensure amount > 0.0

    interface instance Disclosure.I for NonTransferable where
      view = Disclosure.View with disclosureControllers = singleton account.owner; observers
      setObservers Disclosure.SetObservers{newObservers} = toInterfaceContractId <$> create this with observers = newObservers
      archive' self = archive $ fromInterfaceContractId @NonTransferable self

    interface instance Base.I for NonTransferable where
      asDisclosure = toInterface @Disclosure.I this
      view = Base.View with
        instrument
        account = AccountKey with custodian = account.custodian; owner = account.owner; id = account.id
        amount

    interface instance Lockable.I for NonTransferable where
      asHolding = toInterface @Base.I this
      view = Lockable.View with lock
      acquire = acquireImpl @NonTransferable (toInterface @Lockable.I this)
      release = releaseImpl @NonTransferable (toInterface @Lockable.I this)

-- | Implementation of acquire.
acquireImpl : forall t. (HasCreate t, DA.Internal.Record.HasField "lock" t (Optional Lockable.Lock), HasFromInterface t Lockable.I, HasToInterface t Lockable.I) => Lockable.I -> Lockable.Acquire -> Update (ContractId Lockable.I)
acquireImpl lockable Lockable.Acquire{newLocker; context; lockType} =
  do
    let v = view lockable
    newLock <- case (v.lock, lockType) of
      (Some existingLock, Lockable.Reentrant) -> pure existingLock with context = context `insert` existingLock.context
      (None, _) -> pure Lockable.Lock with locker = newLocker; context = singleton context; lockType
      _ -> abort "Contract is already locked."
    let Some this = fromInterface @t lockable
    toInterfaceContractId <$> create this with lock = Some newLock

-- | Implementation of release.
releaseImpl : forall t. (HasCreate t, DA.Internal.Record.HasField "lock" t (Optional Lockable.Lock), HasFromInterface t Lockable.I, HasToInterface t Lockable.I) => Lockable.I -> Lockable.Release -> Update (ContractId Lockable.I)
releaseImpl lockable Lockable.Release{context} = do
    let
      v = view lockable
      f currentLock = do
        let newContext = context `delete` currentLock.context
        case (currentLock.lockType, null newContext) of
          (Lockable.Reentrant, False) -> Some currentLock with context = newContext
          _ -> None
      releasedLock = v.lock >>= f
    let Some this = fromInterface @t lockable
    toInterfaceContractId <$> create this with lock = releasedLock

instance HoldingFactory.HasImplementation Factory
-- | Implementation of the corresponding Holding Factory.
template Factory
  with
    provider : Party
      -- ^ The factory's provider.
    observers : PartiesMap
      -- ^ The factory's observers.
  where
    signatory provider
    observer Disclosure.flattenObservers observers

    interface instance HoldingFactory.F for Factory
      where
        asDisclosure = toInterface @Disclosure.I this
        view = HoldingFactory.View with provider
        create' HoldingFactory.Create{instrument; account; amount; observers} =
          toInterfaceContractId <$> create NonTransferable with instrument; account; amount; observers; lock = None
        remove HoldingFactory.Remove{actors; holdingCid} = archive $ fromInterfaceContractId @NonTransferable holdingCid

    interface instance Disclosure.I for Factory where
      view = Disclosure.View with disclosureControllers = singleton provider; observers
      setObservers Disclosure.SetObservers{newObservers} = toInterfaceContractId <$> create this with observers = newObservers
      archive' self = archive (coerceContractId self : ContractId NonTransferable)
