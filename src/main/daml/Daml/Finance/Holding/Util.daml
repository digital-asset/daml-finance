-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Holding.Util
  ( acquireImpl
  , reapplyLocks
  , releaseImpl
  , transferImpl
  ) where

import DA.Assert ((===))
import DA.Set (delete, insert, null, singleton, toList)
import Daml.Finance.Interface.Holding.Account qualified as Account (Credit(..), I, R, exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Lockable qualified as Lockable (Acquire(..), I, Lock(..), LockType(..), Release(..), asHolding)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..), asLockable)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey)
import Prelude hiding (null)

-- | Utility function to reapply holding locks.
reapplyLocks : Lockable.Lock -> ContractId Lockable.I -> Update (ContractId Lockable.I)
reapplyLocks lock cid =
  let
    apply accM context = do
      cid <- accM
      exercise cid Lockable.Acquire with newLocker = lock.locker; context; lockType = lock.lockType
  in
    foldl apply (pure cid) (toList lock.context)

-- | Implementation of transfer for the Transferable interface.
transferImpl : Transferable.I -> Transferable.Transfer -> Update (ContractId Transferable.I)
transferImpl transferable Transferable.Transfer{newOwnerAccount} = do
  --
  let
    l = Transferable.asLockable transferable
    vL = view l
    vH = view $ Lockable.asHolding l
  -- Account sanity checks
  newAccount <- fetchInterfaceByKey @Account.R newOwnerAccount
  let vA = view newAccount
  vA.owner === newOwnerAccount.owner
  vA.custodian === vH.accountKey.custodian
  -- Create new holding via Credit
  newHoldingCid <- coerceContractId <$> Account.exerciseInterfaceByKey @Account.I newOwnerAccount newOwnerAccount.owner Account.Credit
    with
      quantity = Instrument.qty vH.amount vH.instrumentKey
  -- Holding sanity check. This prevents a holding from changing type during a `Transfer` (from e.g., `NonFungible` to `Fungible`)
  newHolding <- fetch newHoldingCid
  assertMsg "Sent holding type does not correspond to receiving account holding type" $ interfaceTypeRep newHolding == interfaceTypeRep transferable
  -- Reapply holding locks
  coerceContractId <$> case vL.lock of
    Some lock -> reapplyLocks lock newHoldingCid
    None -> pure newHoldingCid

-- | Default implementation of `acquire` from the Lockable interface.
acquireImpl : forall t. (HasCreate t, DA.Internal.Record.HasField "lock" t (Optional Lockable.Lock), HasFromInterface t Lockable.I, HasToInterface t Lockable.I) => t -> Lockable.I -> Lockable.Acquire -> Update (ContractId Lockable.I)
acquireImpl _ lockable Lockable.Acquire{newLocker; context; lockType} = do
    let v = view lockable
    newLock <- case (v.lock, lockType) of
      (Some existingLock, Lockable.Reentrant) -> pure existingLock with context = context `insert` existingLock.context
      (None, _) -> pure Lockable.Lock with locker = newLocker; context = singleton context; lockType
      _ -> abort "Contract is already locked."
    let Some this = fromInterface @t lockable
    toInterfaceContractId <$> create this with lock = Some newLock

-- | Default implementation of release from the Lockable interface.
releaseImpl : forall t. (HasCreate t, DA.Internal.Record.HasField "lock" t (Optional Lockable.Lock), HasFromInterface t Lockable.I, HasToInterface t Lockable.I) => t -> Lockable.I -> Lockable.Release -> Update (ContractId Lockable.I)
releaseImpl _ lockable Lockable.Release{context} = do
    let
      v = view lockable
      f currentLock = do
        let newContext = context `delete` currentLock.context
        case (currentLock.lockType, null newContext) of
          (Lockable.Reentrant, False) -> Some currentLock with context = newContext
          _ -> None
      releasedLock = v.lock >>= f
    let Some this = fromInterface @t lockable
    toInterfaceContractId <$> create this with lock = releasedLock
