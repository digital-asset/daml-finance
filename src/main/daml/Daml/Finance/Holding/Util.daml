-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Holding.Util
  ( acquireImpl
  , reapplyLocks
  , releaseAll
  , releaseImpl
  , transferImpl
  ) where

import DA.Action (foldlA)
import DA.Set qualified as S (delete, fromList, insert, isSubsetOf, null, singleton, toList)
import Daml.Finance.Interface.Holding.Account qualified as Account (Transfer(..), I, R, exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Lockable (getLocker)
import Daml.Finance.Interface.Holding.Lockable qualified as Lockable (Acquire(..), I, Lock(..), LockType(..), Release(..))
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (fetchAccount)
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey)
import Prelude hiding (null)

-- | Utility function to reapply holding locks.
reapplyLocks :  ContractId Lockable.I -> Lockable.Lock -> Update (ContractId Lockable.I)
reapplyLocks cid lock = foldlA (\acc context -> exercise acc Lockable.Acquire with newLocker = lock.locker; context; lockType = lock.lockType) cid (S.toList lock.context)

-- | Utility function to unlock all holding locks.
releaseAll : ContractId Lockable.I -> Lockable.Lock -> Update (ContractId Lockable.I)
releaseAll cid lock = foldlA (\acc context -> exercise acc Lockable.Release with context) cid (S.toList lock.context)

-- | Implementation of transfer for the Transferable interface.
transferImpl : forall t. (HasToInterface t Transferable.I) => ContractId t -> Transferable.Transfer -> Update (ContractId Transferable.I)
transferImpl self Transferable.Transfer{newOwnerAccount; transferors} = do
  let transferableCid = toInterfaceContractId @Transferable.I self
  transferable <- fetch transferableCid
  vAccount <- view <$> fetchAccount transferable
  vNewAccount <- view <$> fetchInterfaceByKey @Account.R newOwnerAccount
  assertMsg "transferors must contain all transfer initiators of the sender account" $ S.isSubsetOf vAccount.transferInitiators transferors
  assertMsg "transferors must contain all transfer approvers of the account" $ S.isSubsetOf vNewAccount.transferApprovers transferors
  let lockers = getLocker transferable
  -- transfer (with authorization from custodian, owner, and transferApprovers of new account)
  coerceContractId <$> Account.exerciseInterfaceByKey @Account.I newOwnerAccount vAccount.custodian
    Account.Transfer with transferableCid; actors = lockers <> S.fromList [vAccount.custodian, vAccount.owner]

-- | Default implementation of `acquire` from the Lockable interface.
acquireImpl : forall t. (HasCreate t, DA.Internal.Record.HasField "lock" t (Optional Lockable.Lock), HasFromInterface t Lockable.I, HasToInterface t Lockable.I) => t -> Lockable.I -> Lockable.Acquire -> Update (ContractId Lockable.I)
acquireImpl _ lockable Lockable.Acquire{newLocker; context; lockType} = do
    let v = view lockable
    newLock <- case (v.lock, lockType) of
      (Some existingLock, Lockable.Reentrant) -> pure existingLock with context = context `S.insert` existingLock.context
      (None, _) -> pure Lockable.Lock with locker = newLocker; context = S.singleton context; lockType
      _ -> abort "Contract is already locked."
    let Some this = fromInterface @t lockable
    toInterfaceContractId <$> create this with lock = Some newLock

-- | Default implementation of release from the Lockable interface.
releaseImpl : forall t. (HasCreate t, DA.Internal.Record.HasField "lock" t (Optional Lockable.Lock), HasFromInterface t Lockable.I, HasToInterface t Lockable.I) => t -> Lockable.I -> Lockable.Release -> Update (ContractId Lockable.I)
releaseImpl _ lockable Lockable.Release{context} = do
    let
      v = view lockable
      f currentLock = do
        let newContext = context `S.delete` currentLock.context
        case (currentLock.lockType, S.null newContext) of
          (Lockable.Reentrant, False) -> Some currentLock with context = newContext
          _ -> None
      releasedLock = v.lock >>= f
    let Some this = fromInterface @t lockable
    toInterfaceContractId <$> create this with lock = releasedLock
