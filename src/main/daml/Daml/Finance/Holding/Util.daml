-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Holding.Util where

import DA.Action (foldlA)
import DA.Assert ((===))
import DA.Set qualified as S (delete, fromList, insert, intersection, isSubsetOf, notMember, null, singleton, toList)
import Daml.Finance.Interface.Account.Account qualified as Account (Credit(..), Debit(..), I)
import Daml.Finance.Interface.Holding.Base qualified as Base (Acquire(..), I, Lock(..), LockType(..), Release(..), getLockers)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Interface.Util.SyntheticKey (IndexTable, create, exercise, fetch, fetchByKey, withIndexTable)
import Prelude hiding (archive, create, exercise, exerciseByKey, fetch, fetchByKey, fetchFromInterface, lookup, lookupByKey)

-- | Default implementation of transfer for the Transferable interface.
transferImpl : Transferable.I -> ContractId Transferable.I -> Transferable.Transfer ->
  Update (ContractId Transferable.I, IndexTable)
transferImpl this self Transferable.Transfer{actors; newOwnerAccount; idx} = withIndexTable idx do
  let
    baseCid = toInterfaceContractId @Base.I self
    base = toInterface @Base.I this
    vBase = view base
    lockers = Base.getLockers base
  (accountCid, vAccount) <- fmap view <$> fetchByKey @Account.I @Account.I vBase.account
  (newAccountCid, vNewAccount) <- fmap view <$> fetchByKey @Account.I @Account.I newOwnerAccount
  -- Verify
  assertMsg "actors must contain all transfer outgoing of the sender account" $
    vAccount.controllers.outgoing `S.isSubsetOf` actors
  assertMsg "actors must contain all transfer incoming of the receiving account" $
    vNewAccount.controllers.incoming `S.isSubsetOf` actors
  assertMsg "actors must contain all lockers" $ lockers `S.isSubsetOf` actors
  assertMsg "custodians must be the same" $ vBase.account.custodian == vAccount.custodian
  -- Release all locks
  let
    releaseAll cid lock =
      foldlA (\acc context -> exercise acc Base.Release with context) cid (S.toList lock.context)
  baseCid <- toInterfaceContractId @Base.I <$>
    optional (pure baseCid) (releaseAll baseCid) vBase.lock
  -- Debit
  exercise accountCid Account.Debit with holdingCid = baseCid
  -- Credit
  newBaseCid <- exercise newAccountCid
    Account.Credit with quantity = qty vBase.amount vBase.instrument
  -- Consistency check
  newBase <- fetch newBaseCid
  assertMsg "credited and debited holding types must match" $
    interfaceTypeRep newBase == interfaceTypeRep base
  -- Reapply locks
  let
    reapplyLocks cid lock = foldlA (\acc context -> exercise acc Base.Acquire with
      newLockers = lock.lockers; context; lockType = lock.lockType) cid (S.toList lock.context)
  coerceInterfaceContractId <$> optional (pure newBaseCid) (reapplyLocks newBaseCid) vBase.lock

-- | Default implementation of `acquire` from the Base interface.
acquireImpl :
  ( HasCreate t
  , HasField "lock" t (Optional Base.Lock)
  , HasFromInterface t Base.I
  , HasToInterface t Base.I
  , HasSignatory t
  ) => t -> Base.Acquire -> Update (ContractId Base.I)
acquireImpl holding Base.Acquire{newLockers; context; lockType} = do
  newLock <- case holding.lock of
    None -> pure Base.Lock with lockers = newLockers; context = S.singleton context; lockType
    Some existingLock -> do
      case lockType of
        Base.Reentrant -> do
          assertMsg "New lockers must match the existing lockers"
            $ existingLock.lockers == newLockers
          assertMsg "New lock type must match the existing lock type"
            $ existingLock.lockType == lockType
          assertMsg "Contract must not be already locked for the provided context."
            $ S.notMember context existingLock.context
          pure existingLock with
            context = context `S.insert` existingLock.context
        Base.Semaphore ->
          abort "A Semaphore lock can not be locked multiple times."
  let newHolding = holding with lock = Some newLock
  S.fromList (signatory newHolding) `S.intersection` newLockers === newLockers
  toInterfaceContractId <$> create newHolding

-- | Default implementation of release from the Base interface.
releaseImpl :
  ( HasCreate t
  , HasField "lock" t (Optional Base.Lock)
  , HasFromInterface t Base.I
  , HasToInterface t Base.I
  ) => t -> Base.Release -> Update (ContractId Base.I)
releaseImpl holding Base.Release{context} = do
  let
    f currentLock = do
      let newContext = context `S.delete` currentLock.context
      case (currentLock.lockType, S.null newContext) of
        (Base.Reentrant, False) -> Some currentLock with context = newContext
        _ -> None
    releasedLock = holding.lock >>= f
  toInterfaceContractId <$> create holding with lock = releasedLock
