-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Holding.Util
  ( acquireImpl
  , reapplyLocks
  , releaseAll
  , releaseImpl
  , transferImpl
  ) where

import DA.Action (foldlA)
import DA.Set qualified as S (delete, insert, isSubsetOf, null, singleton, toList)
import Daml.Finance.Interface.Account.Account qualified as Account (CreditAndDebit(..), I, R, exerciseInterfaceByKey)
import Daml.Finance.Interface.Account.Util (fetchAccount)
import Daml.Finance.Interface.Holding.Base (getLockers)
import Daml.Finance.Interface.Holding.Base qualified as Base (Acquire(..), I, Lock(..), LockType(..), Release(..))
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey)
import Prelude hiding (null)

-- | Utility function to reapply holding locks.
reapplyLocks :  ContractId Base.I -> Base.Lock -> Update (ContractId Base.I)
reapplyLocks cid lock = foldlA (\acc context -> exercise acc Base.Acquire with
  newLockers = lock.lockers; context; lockType = lock.lockType) cid (S.toList lock.context)

-- | Utility function to unlock all holding locks.
releaseAll : ContractId Base.I -> Base.Lock -> Update (ContractId Base.I)
releaseAll cid lock =
  foldlA (\acc context -> exercise acc Base.Release with context) cid (S.toList lock.context)

-- | Implementation of transfer for the Transferable interface.
transferImpl : ContractId Transferable.I -> Transferable.Transfer -> Update
  (ContractId Transferable.I)
transferImpl self Transferable.Transfer{actors; newOwnerAccount} = do
  transferable <- fetch self
  vAccount <- view <$> fetchAccount transferable
  vNewAccount <- view <$> fetchInterfaceByKey @Account.R @Account.I newOwnerAccount
  let lockers = getLockers transferable
  assertMsg "actors must contain all transfer instructors of the sender account" $
    S.isSubsetOf vAccount.controllers.instructors actors
  assertMsg "actors must contain all transfer approvers of the receiving account" $
    S.isSubsetOf vNewAccount.controllers.approvers actors
  assertMsg "actors must contain all lockers" $ S.isSubsetOf lockers actors
  coerceContractId <$> Account.exerciseInterfaceByKey @Account.I newOwnerAccount vAccount.custodian
    Account.CreditAndDebit with
      actors = lockers <> S.singleton vAccount.owner; baseCid = toInterfaceContractId @Base.I self

-- | Default implementation of `acquire` from the Base interface.
acquireImpl :
  ( HasCreate t
  , DA.Internal.Record.HasField "lock" t (Optional Base.Lock)
  , HasFromInterface t Base.I, HasToInterface t Base.I
  ) => t -> Base.Acquire -> Update (ContractId Base.I)
acquireImpl base Base.Acquire{newLockers; context; lockType} = do
  newLock <- case (base.lock, lockType) of
    (Some existingLock, Base.Reentrant) -> pure existingLock with
      context = context `S.insert` existingLock.context
    (None, _) -> pure Base.Lock with lockers = newLockers; context = S.singleton context; lockType
    _ -> abort "Contract is already locked."
  toInterfaceContractId <$> create base with lock = Some newLock

-- | Default implementation of release from the Base interface.
releaseImpl :
  ( HasCreate t
  , DA.Internal.Record.HasField "lock" t (Optional Base.Lock)
  , HasFromInterface t Base.I
  , HasToInterface t Base.I
  ) => t -> Base.Release -> Update (ContractId Base.I)
releaseImpl base Base.Release{context} = do
  let
    f currentLock = do
      let newContext = context `S.delete` currentLock.context
      case (currentLock.lockType, S.null newContext) of
        (Base.Reentrant, False) -> Some currentLock with context = newContext
        _ -> None
    releasedLock = base.lock >>= f
  toInterfaceContractId <$> create base with lock = releasedLock
