-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Holding.Util where

import DA.Action (foldlA)
import DA.Assert ((===))
import DA.Foldable qualified as F (all)
import DA.Optional (whenSome)
import DA.Set qualified as S (delete, fromList, insert, intersection, isSubsetOf, notMember, null, singleton, toList)
import DA.Traversable qualified as T (mapA)
import Daml.Finance.Interface.Account.Account qualified as Account (Credit(..), Debit(..), I, R, exerciseInterfaceByKey)
import Daml.Finance.Interface.Account.Util (fetchAccount)
import Daml.Finance.Interface.Holding.Base qualified as Base (Acquire(..), I, Lock(..), LockType(..), Release(..), getLockers)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I, Merge(..), Split(..), SplitResult(..))
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (getAmount, getInstrument)
import Daml.Finance.Interface.Types.Common.Types (InstrumentKey(..))
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey, verify, qty)
import Prelude hiding (null)

-- | Default implementation of split for the Fungible interface.
splitImpl :
  ( HasCreate t
  , HasField "amount" t Decimal
  , HasToInterface t Fungible.I
  , HasFromInterface t Fungible.I
  ) => t -> Fungible.Split -> Update Fungible.SplitResult
splitImpl this Fungible.Split{amounts} = do
  splitCids <- forA amounts $
    \a -> toInterfaceContractId @Fungible.I <$> create this with amount = a
  restAmount <- getSplitRestAmount amounts this.amount
  rest <- T.mapA (\r -> toInterfaceContractId <$> create this with amount = r) restAmount
  pure $ Fungible.SplitResult with splitCids; rest

-- | Default implementation of merge for the Fungible interface.
mergeImpl :
  ( HasCreate t
  , HasField "amount" t Decimal
  , HasField "instrument" t InstrumentKey
  , HasToInterface t Fungible.I
  , HasFromInterface t Fungible.I
  ) => t -> Fungible.Merge -> Update (ContractId Fungible.I)
mergeImpl this Fungible.Merge{fungibleCids} = do
  let
    f a cid = do
      Some (fungibleCid, fungible) <- fetchFromInterface @Fungible.I cid
      archive fungibleCid
      assertMsg "instrument must match" $ this.instrument == getInstrument fungible
      pure $ a + getAmount fungible
  tot <- foldlA f this.amount fungibleCids
  toInterfaceContractId <$> create this with amount = tot

-- | Default implementation of transfer for the Transferable interface.
transferImpl : Transferable.I -> ContractId Transferable.I -> Transferable.Transfer
  -> Update (ContractId Transferable.I)
transferImpl this self Transferable.Transfer{actors; newOwnerAccount} = do
  let
    baseCid = toInterfaceContractId @Base.I self
    base = toInterface @Base.I this
  account <- fetchAccount base
  let
    vBase = view base
    vAccount = view account
    lockers = Base.getLockers base
  vNewAccount <- view <$> fetchInterfaceByKey @Account.R @Account.I newOwnerAccount
  -- Verify
  assertMsg "actors must contain all transfer outgoing of the sender account" $
    vAccount.controllers.outgoing `S.isSubsetOf` actors
  assertMsg "actors must contain all transfer incoming of the receiving account" $
    vNewAccount.controllers.incoming `S.isSubsetOf` actors
  assertMsg "actors must contain all lockers" $ lockers `S.isSubsetOf` actors
  assertMsg "custodians must be the same" $ vBase.account.custodian == vAccount.custodian
  -- Release all locks
  let
    releaseAll cid lock =
      foldlA (\acc context -> exercise acc Base.Release with context) cid (S.toList lock.context)
  baseCid <- toInterfaceContractId @Base.I <$>
    optional (pure baseCid) (releaseAll baseCid) vBase.lock
  -- Debit
  Account.exerciseInterfaceByKey @Account.I vBase.account vBase.account.custodian
    Account.Debit with holdingCid = baseCid
  -- Credit
  newBaseCid <- Account.exerciseInterfaceByKey @Account.I newOwnerAccount newOwnerAccount.custodian
    Account.Credit with quantity = qty vBase.amount vBase.instrument
  -- Consistency check
  newBase <- fetch newBaseCid
  assertMsg "credited and debited holding types must match" $
    interfaceTypeRep newBase == interfaceTypeRep base
  -- Reapply locks
  let
    reapplyLocks cid lock = foldlA (\acc context -> exercise acc Base.Acquire with
      newLockers = lock.lockers; context; lockType = lock.lockType) cid (S.toList lock.context)
  coerceInterfaceContractId <$> optional (pure newBaseCid) (reapplyLocks newBaseCid) vBase.lock

-- | Default implementation of `acquire` from the Base interface.
acquireImpl :
  ( HasCreate t
  , HasField "lock" t (Optional Base.Lock)
  , HasFromInterface t Base.I
  , HasToInterface t Base.I
  , HasSignatory t
  ) => t -> Base.Acquire -> Update (ContractId Base.I)
acquireImpl holding Base.Acquire{newLockers; context; lockType} = do
  whenSome holding.lock \lock -> do
    lock.lockers === newLockers
    lock.lockType === lockType
    assertMsg "Contract must be locked." $ lock.lockType == Base.Reentrant
    assertMsg "Contract must not be locked for this context." $ S.notMember context lock.context
  newLock <- case (holding.lock, lockType) of
    (Some existingLock, Base.Reentrant) -> pure existingLock with
      context = context `S.insert` existingLock.context
    (None, _) -> pure Base.Lock with lockers = newLockers; context = S.singleton context; lockType
    _ -> abort "Contract is already locked."
  let newHolding = holding with lock = Some newLock
  S.fromList (signatory newHolding) `S.intersection` newLockers === newLockers
  toInterfaceContractId <$> create newHolding

-- | Default implementation of release from the Base interface.
releaseImpl :
  ( HasCreate t
  , HasField "lock" t (Optional Base.Lock)
  , HasFromInterface t Base.I
  , HasToInterface t Base.I
  ) => t -> Base.Release -> Update (ContractId Base.I)
releaseImpl holding Base.Release{context} = do
  let
    f currentLock = do
      let newContext = context `S.delete` currentLock.context
      case (currentLock.lockType, S.null newContext) of
        (Base.Reentrant, False) -> Some currentLock with context = newContext
        _ -> None
    releasedLock = holding.lock >>= f
  toInterfaceContractId <$> create holding with lock = releasedLock

-- | Gets the rest amount of a split (if any) and verifies that split amounts are strictly positive
-- and don't exceed the current amount.
getSplitRestAmount : CanAssert m => [Decimal] -> Decimal -> m (Optional Decimal)
getSplitRestAmount amounts currentAmount = do
  let splitAmountSum = sum amounts
  verify (splitAmountSum <= currentAmount && F.all (> 0.0) amounts && amounts /= []) $ "Fungible::"
    <> "verifySplit - Amounts must be non-empty, strictly positive, and not exceed current amount. "
    <> "amounts=" <> show amounts
    <> ", splitAmountSum=" <> show splitAmountSum
    <> ", currentAmount=" <> show currentAmount
  let rest = currentAmount - splitAmountSum
  pure $ if rest == 0.0 then None else Some rest
