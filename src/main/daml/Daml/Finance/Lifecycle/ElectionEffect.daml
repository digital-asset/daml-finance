-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Lifecycle.ElectionEffect where

import DA.Assert ((===))
import Daml.Finance.Interface.Holding.Util (getAmount, getInstrument)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (K, Q, qty, scale)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (Calculate(..), CalculationResult(..), HasImplementation, I, SetProvider(..), View(..))
import Daml.Finance.Interface.Types.Common (Id, Parties, PartiesMap)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (flattenObservers)

-- | Type synonym for `ElectionEffect`.
type T = ElectionEffect

instance Effect.HasImplementation T

-- | A contract encoding the consequences of an election for one unit of the target instrument.
-- It needs to be claimed with a holding of the right amount and is consumed after claiming.
template ElectionEffect
  with
    providers : Parties
      -- ^ The effect provider.
    custodian : Party
      -- ^ The custodian of the holding put forward for election.
    owner : Party
      -- ^ The owner of the holding put forward for election.
    id : Id
      -- ^ The effect's identifier.
    description : Text
      -- ^ The effect's description.
    targetInstrument : Instrument.K
      -- ^ The target instrument.
    producedInstrument : Optional Instrument.K
      -- ^ The produced instrument, when it exists.
    amount : Decimal
      -- ^ The elected amount.
    otherConsumed : [Instrument.Q]
      -- ^ Consumed quantities (not including the target instrument).
    otherProduced : [Instrument.Q]
      -- ^ Produced quantities (not including the produced instrument).
    settlementDate : Date
      -- ^ The effect's settlement date.
    observers : PartiesMap
      -- ^ Observers.
  where
    signatory providers
    observer Disclosure.flattenObservers observers

    interface instance Effect.I for ElectionEffect where
      view = Effect.View with providers; id; description; targetInstrument; producedInstrument; otherConsumed; otherProduced; settlementDate

      calculate Effect.Calculate{actor; holdingCid} self = do
        holding <- fetch holdingCid
        getInstrument holding === targetInstrument
        getAmount holding === amount
        assertMsg "Election effects can only be calculated by the elector or their counterparty" $ actor == owner || actor == custodian
        debug otherConsumed
        debug otherProduced

        -- TODO
        -- 1. Merge otherConsumed and otherProduced to otherPending (write new function mergeConsumedAndProduced)
        -- 2. Net otherPending (call existing function net pending, which disregards Tags - there are no tags anyway)
        --    It is unclear if we can link from this interface to Lifecycle implementation
        --    -> duplicate the function and put it here for now.
        -- 3. split up nettedPending again (call existing function splitPending) -> (otherNetConsumed, otherNetProduced)
        --    -> duplicate the function and put it here for now.
        -- 4. replace otherConsumed and otherProduced below (by otherNetConsumed, otherNetProduced)
        -- 5. verify impact in tests, especially CallableBond should have one payment of 1001000 instead of two payments.
        -- 6. make it configurable (new flag: enableNetting)

        archive $ fromInterfaceContractId @ElectionEffect self
        let scaleAll = fmap $ Instrument.scale $ getAmount holding
        pure Effect.CalculationResult
          with
          consumed = scaleAll $ Instrument.qty 1.0 targetInstrument :: otherConsumed
          produced = scaleAll $ case producedInstrument of
            Some pi -> Instrument.qty 1.0 pi :: otherProduced
            None -> otherProduced

      setProvider Effect.SetProvider{newProviders} = toInterfaceContractId <$> create this with providers = newProviders
