-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Lifecycle.Effect where

import DA.Assert ((===))
import Daml.Finance.Interface.Holding.Util (getAmount, getInstrument)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (K, Q, scale, qty)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (Calculate(..), CalculationResult(..), HasImplementation, I, SetProvider(..), View(..))
import Daml.Finance.Interface.Types.Common (Id, Parties)

-- | Type synonym for `Effect`.
type T = Effect

instance Effect.HasImplementation T

-- | A contract encoding the consequences of a lifecycle event for one unit of the target
-- instrument.
template Effect
  with
    providers : Parties
      -- ^ The effect provider.
    id : Id
      -- ^ The effect's identifier.
    description : Text
      -- ^ The effect's description.
    targetInstrument : Instrument.K
      -- ^ The target instrument.
    producedInstrument : Optional Instrument.K
      -- ^ The produced instrument, when it exists.
    otherConsumed : [Instrument.Q]
      -- ^ Consumed quantities (in addition to the target instrument).
    otherProduced : [Instrument.Q]
      -- ^ Produced quantities (in additon to the produced instrument).
    settlementDate : Date
      -- ^ The effect's settlement date.
    observers : Parties
      -- ^ Observers.
  where
    signatory providers
    observer observers

    interface instance Effect.I for Effect where
      view = Effect.View with
        providers; id; description; targetInstrument; producedInstrument; otherConsumed
        otherProduced; settlementDate

      calculate Effect.Calculate{holdingCid} _ = do
        holding <- fetch holdingCid
        getInstrument holding === targetInstrument
        let scaleAll = fmap . Instrument.scale $ getAmount holding
        pure Effect.CalculationResult with
          consumed = scaleAll $ Instrument.qty 1.0 targetInstrument :: otherConsumed
          produced = scaleAll $ case producedInstrument of
            Some pi -> Instrument.qty 1.0 pi :: otherProduced
            None -> otherProduced

      setProvider Effect.SetProvider{newProviders} = toInterfaceContractId <$> create this with
        providers = newProviders
