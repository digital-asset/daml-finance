-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Factory where

import DA.List (groupOn, head)
import DA.Map qualified as M (Map, fromList, lookup)
import DA.Optional (fromSomeNote)
import DA.Set (empty)
import Daml.Finance.Interface.Settlement.Factory qualified as Factory (I, Instruct(..), View(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common (Id(..), Parties)
import Daml.Finance.Settlement.Batch (Batch(..))
import Daml.Finance.Settlement.Hierarchy (Hierarchy(..), unfoldStep)
import Daml.Finance.Settlement.Instruction (Instruction(..))
import Daml.Finance.Util.Common (mapWithIndex)

-- | Factory template that implements the `Factory` interface.
-- It is used to create a set of settlement `Instruction`\s, and a `Batch` to atomically settle them.
template Factory
  with
    provider : Party
      -- ^ Party providing the facility to create settlement instructions.
    observers : Parties
      -- ^ Observers.
  where
    signatory provider
    observer observers

    interface instance Factory.I for Factory where
      view = Factory.View with provider; observers
      instruct Factory.Instruct{instructors; settlers; id; description; contextId; steps} = do
        let
          createInstruction step index =
            Instruction with requestors = instructors; signed = empty; settlers; step; allocation = Unallocated; approval = Unapproved; batchId = id; id = Id (show index); observers = M.fromList [(show id, settlers)]
          instructions = mapWithIndex createInstruction steps
          instructionIds = map (.id) instructions
        instructionCids <- mapA (fmap toInterfaceContractId . create) instructions
        batchCid <- toInterfaceContractId <$> create Batch with requestors = instructors; settlers; id; description; contextId; stepsWithInstructionId = zip steps instructionIds
        pure (batchCid, instructionCids)

-- | Factory template that implements the `Factory` interface.
-- It is used to create a set of settlement `Instruction`\s, and a `Batch` to atomically settle them.
-- For each instrument to settle as part of the batch, a hierarchy of intermediaries is specified in `paths`.
-- This hierarchy is used to generate the settlement instructions.
template FactoryWithIntermediaries
  with
    provider : Party
      -- ^ Party providing the facility to create settlement instructions.
    observers : Parties
      -- ^ Observers.
    paths : M.Map Text Hierarchy
      -- ^ Hierarchical paths used to settle holding transfers. A path is specified for each instrument label.
  where
    signatory provider
    observer observers

    interface instance Factory.I for FactoryWithIntermediaries where
      view = Factory.View with provider; observers
      instruct Factory.Instruct{instructors; settlers; id; description; contextId; steps} = do
        let
          -- Group steps by instrument. For each group, lookup corresponding paths and expand steps according to the corresponding settlement route.
          groupedSteps = mconcat $ fromSomeNote "Could not find path or route." $ mapA (\steps -> do
            let k = show (head steps).quantity.unit.id
            route <- M.lookup k paths
            mconcat <$> mapA (unfoldStep route) steps
            ) $ groupOn (.quantity.unit) steps
          -- For each step, generate instructions and ids.
          createInstruction step index =
            Instruction with requestors = instructors; signed = empty; settlers; step; allocation = Unallocated; approval = Unapproved; batchId = id; id = Id (show index); observers = M.fromList [(show id, settlers)]
          instructions = mapWithIndex createInstruction groupedSteps
          instructionIds = map (.id) instructions
        instructionCids <- mapA (fmap toInterfaceContractId . create) instructions
        batchCid <- toInterfaceContractId <$> create Batch with requestors = instructors; settlers; id; description; contextId; stepsWithInstructionId = zip groupedSteps instructionIds
        pure (batchCid, instructionCids)
