-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Factory where

import DA.List (groupOn, head)
import DA.Map qualified as M (Map, fromList, lookup)
import DA.Optional (fromSomeNote)
import DA.Set (empty)
import Daml.Finance.Interface.Settlement.Factory qualified as Factory (I, Instruct(..), View(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), RoutedStep(..))
import Daml.Finance.Interface.Types.Common (Id(..), Parties)
import Daml.Finance.Settlement.Batch (Batch(..))
import Daml.Finance.Settlement.Hierarchy (Hierarchy(..), unfoldStep)
import Daml.Finance.Settlement.Instruction (Instruction(..))
import Daml.Finance.Util.Common (mapWithIndex)

-- | Factory template that implements the `Factory` interface.
-- It is used to create a set of settlement `Instruction`\s, and a `Batch` to atomically settle them.
-- This template assumes that a single custodian is used for all steps.
template Factory
  with
    provider : Party
      -- ^ Party providing the facility to create settlement instructions.
    observers : Parties
      -- ^ Observers.
    custodian : Party
      -- ^ The custodian to be used to settle each `Step`.
  where
    signatory provider
    observer observers

    interface instance Factory.I for Factory where
      view = Factory.View with provider; observers
      instruct Factory.Instruct{instructors; settlers; id; description; contextId; steps} = do
        let
          routeStep step = RoutedStep with
            sender = step.sender; receiver = step.receiver; quantity = step.quantity; custodian
          createInstruction routedStep index = Instruction with
            requestors = instructors; signed = empty; settlers; routedStep; allocation = Unallocated
            approval = Unapproved; batchId = id; id = Id (show index)
            observers = M.fromList [(show id, settlers)]
          routedSteps = map routeStep steps
          instructions = mapWithIndex createInstruction routedSteps
          instructionIds = map (.id) instructions
        instructionCids <- mapA (fmap toInterfaceContractId . create) instructions
        batchCid <- toInterfaceContractId <$> create Batch with
          requestors = instructors; settlers; id; description; contextId
          routedStepsWithInstructionId = zip routedSteps instructionIds
        pure (batchCid, instructionCids)

-- | Factory template that implements the `Factory` interface.
--   It is used to create a set of settlement `Instruction`\s, and a `Batch` to atomically settle
--   them. For each instrument to settle as part of the batch, a hierarchy of intermediaries is
--   specified in `paths`. This hierarchy is used to generate the settlement instructions.
template FactoryWithIntermediaries
  with
    provider : Party
      -- ^ Party providing the facility to create settlement instructions.
    observers : Parties
      -- ^ Observers.
    paths : M.Map Text Hierarchy
      -- ^ Hierarchical paths used to settle holding transfers. A path is specified for each
      --   instrument label.
  where
    signatory provider
    observer observers

    interface instance Factory.I for FactoryWithIntermediaries where
      view = Factory.View with provider; observers
      instruct Factory.Instruct{instructors; settlers; id; description; contextId; steps} = do
        let
          -- Group steps by instrument. For each group, lookup corresponding paths and expand steps
          -- according to the corresponding settlement route.
          groupedSteps = mconcat $ fromSomeNote "Could not find path or route." $ mapA (\steps -> do
            let k = show (head steps).quantity.unit.id
            route <- M.lookup k paths
            mconcat <$> mapA (unfoldStep route) steps
            ) $ groupOn (.quantity.unit) steps
          -- For each routed step, generate instructions and ids.
          createInstruction routedStep index = Instruction with
            requestors = instructors; signed = empty; settlers; routedStep; allocation = Unallocated
            approval = Unapproved; batchId = id; id = Id (show index)
            observers = M.fromList [(show id, settlers)]
          instructions = mapWithIndex createInstruction groupedSteps
          instructionIds = map (.id) instructions
        instructionCids <- mapA (fmap toInterfaceContractId . create) instructions
        batchCid <- toInterfaceContractId <$> create Batch with
          requestors = instructors; settlers; id; description; contextId
          routedStepsWithInstructionId = zip groupedSteps instructionIds
        pure (batchCid, instructionCids)
