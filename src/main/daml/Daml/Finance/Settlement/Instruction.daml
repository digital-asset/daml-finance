-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Instruction where

import DA.Assert ((===))
import DA.Set qualified as S (fromList, insert, intersection, isSubsetOf, member, null, singleton)
import Daml.Finance.Interface.Account.Account qualified as Account (I, Credit(..), Debit(..), R, disclose, exerciseInterfaceByKey, undisclose)
import Daml.Finance.Interface.Account.Util (getAccount)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Lockable qualified as Lockable (I, getLockers)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (disclose, getAmount, getInstrument, undisclose)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), Execute(..), HasImplementation, I, View(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..), Step)
import Daml.Finance.Interface.Types.Common (Id(..), Parties, PartiesMap)
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, SetObservers(..), View(..), flattenObservers)

-- | Type synonym for `Instruction`.
type T = Instruction

instance Instruction.HasImplementation T

-- | Instruction is used to settle a single settlement `Step`. In order to settle the instruction,
-- - the sender must allocate a suitable transferable holding.
-- - the receiver must define the receiving account.
template Instruction
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settlers : Parties
      -- ^ Any of the parties can trigger the settlement.
    signed : Parties
      -- ^ Additional signatories, used to collect authorization.
    batchId : Id
      -- ^ Trade identifier.
    id : Id
      -- ^ Instruction identifier.
    step : Step
      -- ^ Settlement step.
    allocation : Allocation
      -- ^ Allocation from the sender.
    approval : Approval
      -- ^ Approval from the receiver.
    observers : PartiesMap
      -- ^ Observers.
  where
    signatory requestors, signed
    observer step.sender, step.receiver, settlers, Disclosure.flattenObservers observers

    key InstructionKey with requestors; batchId; id : InstructionKey
    maintainer key.requestors

    let
      messageSuffix = " / instruction id = " <> show id
      context = show batchId <> "(" <> show id <> ")"
      discloseA account = Account.disclose (context, settlers) account.owner (S.singleton account.owner) account
      undiscloseA account = Account.undisclose (context, settlers) account.owner (S.singleton account.owner) account
      discloseT discloser settlers cid = disclose @Holding.I (show batchId, settlers) discloser (S.singleton discloser) cid
      undiscloseT discloser settlers cid = undisclose @Holding.I (show batchId, settlers) (S.singleton discloser) cid

    interface instance Disclosure.I for Instruction where
      view = Disclosure.View with disclosureControllers = S.fromList [step.sender, step.receiver]; observers
      setObservers Disclosure.SetObservers{newObservers} = toInterfaceContractId <$> create this with observers = newObservers
      archive' self = archive (coerceContractId self : ContractId Instruction)

    interface instance Instruction.I for Instruction where
      asDisclosure = toInterface @Disclosure.I this
      view = Instruction.View with requestors; settlers; signed; batchId; id; step; allocation; approval
      allocate Instruction.Allocate{actors; allocation} = do
        assertMsg ("allocation must be new" <> messageSuffix) $ allocation /= this.allocation
        -- undisclose previous allocation
        otCid <- case this.allocation of
          Pledge transferableCid -> do
            transferable <- fetch transferableCid
            undiscloseA $ getAccount transferable
            undiscloseT step.sender settlers transferableCid
          PassthroughFrom (passthroughAccount, _) -> do
            undiscloseA passthroughAccount
            pure None
          a -> pure None
        -- allocate
        allocationDisclosed <- case allocation of
          Pledge holdingCid -> do
            holdingCid <- discloseT step.sender settlers holdingCid
            holding <- fetch holdingCid
            let
              senderAccount = getAccount holding
            lockable : Lockable.I <- fetch $ coerceContractId holdingCid
            discloseA senderAccount
            vSenderAccount <- view <$> fetchInterfaceByKey @Account.R senderAccount
            assertMsg "actors must include instructors" $ S.isSubsetOf vSenderAccount.controllers.instructors actors
            assertMsg "actors must include lockers" $ S.isSubsetOf (Lockable.getLockers lockable) actors
            getAmount holding === step.quantity.amount
            getInstrument holding === step.quantity.unit
            pure $ Pledge holdingCid
          PassthroughFrom (passthroughAccount, fromInstruction) -> do
            discloseA passthroughAccount
            vSenderAccount <- view <$> fetchInterfaceByKey @Account.R passthroughAccount
            assertMsg "actors must include instructors" $ S.isSubsetOf vSenderAccount.controllers.instructors actors
            pure $ PassthroughFrom (passthroughAccount, fromInstruction)
          a -> do
            assertMsg "actors must include sender" $ S.member step.sender actors
            pure a
        cid <- toInterfaceContractId <$> create this with allocation = allocationDisclosed; signed = S.insert step.sender signed
        pure (cid, otCid)
      approve Instruction.Approve{actors; approval} = do
        let newSigned = S.insert step.receiver signed
        assertMsg ("approval must be new" <> messageSuffix) $ approval /= this.approval
        -- undisclose previous approval
        case this.approval of
          TakeDelivery receiverAccount -> undiscloseA receiverAccount
          PassthroughTo (passthroughAccount, _) -> undiscloseA passthroughAccount
          a -> pure None
        -- approve
        case approval of
          TakeDelivery receiverAccount -> do
            discloseA receiverAccount
            vReceiverAccount <- view <$> fetchInterfaceByKey @Account.R receiverAccount
            assertMsg "actors must include approvers" $ S.isSubsetOf vReceiverAccount.controllers.approvers actors
          PassthroughTo (passthroughAccount, toInstruction) -> do
            discloseA passthroughAccount
            vReceiverAccount <- view <$> fetchInterfaceByKey @Account.R passthroughAccount
            assertMsg "actors must include approvers" $ S.isSubsetOf vReceiverAccount.controllers.approvers actors
          _ ->
            assertMsg "actors must include receiver" $ S.member step.receiver actors

        toInterfaceContractId <$> create this with signed = newSigned; approval
      execute Instruction.Execute{actors} = do
        assertMsg "actors must intersect with settlers" $ not $ S.null $ S.intersection actors settlers
        let
          abortUnapproved = abort $ "instruction must be approved" <> messageSuffix
          abortOnOffLedgerMix = abort $ "mix of on- and off-ledger settlement is not supported" <> messageSuffix
        -- execute instruction
        case (allocation, approval) of
          (Unallocated, Unapproved) -> abort $ "instruction must be allocated and approved" <> messageSuffix
          (Unallocated, _) -> abort $ "instruction must be allocated" <> messageSuffix
          (_, Unapproved) ->
            abortUnapproved
          (PassthroughFrom _, _) ->
            -- Pass-throughs are consumed by the step (*) below
            abort $ "holding has not been passed through" <> messageSuffix
          (Pledge holdingCid, a) ->
            case a of
              TakeDelivery receiverAccount -> do
                holding <- fetch holdingCid
                let
                  senderAccount = getAccount holding
                  transferableCid : ContractId Transferable.I = coerceContractId holdingCid
                transferableCid <- toInterfaceContractId <$> exercise transferableCid Transferable.Transfer with actors = signed; newOwnerAccount = receiverAccount
                undiscloseA senderAccount
                undiscloseA receiverAccount
                -- disclose for the consistency check in the Batch
                Some <$> discloseT step.receiver actors transferableCid
              DebitSender -> do
                holding <- fetch holdingCid
                let senderAccount = getAccount holding
                assertMsg ("the custodian of the transferable must be the receiver" <> messageSuffix) $ senderAccount.custodian == step.receiver
                accountCid <- Account.exerciseInterfaceByKey @Account.I senderAccount step.sender Account.Debit with holdingCid
                undiscloseA senderAccount
                pure None
              PassthroughTo (passthroughAccount, toInstructionKey) -> do
                holding <- fetch holdingCid
                let
                  senderAccount = getAccount holding
                  transferableCid : ContractId Transferable.I = coerceContractId holdingCid
                tCid <- toInterfaceContractId <$> exercise transferableCid Transferable.Transfer with actors = signed; newOwnerAccount = passthroughAccount
                (toInstructionCid, toInstruction) <- fetchByKey @Instruction toInstructionKey
                assertMsg "passthroughs must match" $ toInstruction.allocation == PassthroughFrom (passthroughAccount, key this)
                -- (*) in case of a pass-through, the newly created holding is immediately allocated to the next step
                exercise (toInterfaceContractId @Instruction.I toInstructionCid) Instruction.Allocate with actors = signed; allocation = Pledge tCid
                undiscloseA senderAccount
                undiscloseA passthroughAccount
                pure None
              SettleOffLedgerAcknowledge -> abortOnOffLedgerMix
              Unapproved -> abortUnapproved
          (CreditReceiver, a) ->
            case a of
              TakeDelivery receiverAccount -> do
                assertMsg ("the custodian of the receiver account must be the sender" <> messageSuffix) $ receiverAccount.custodian == step.sender
                holdingCid <- Account.exerciseInterfaceByKey @Account.I receiverAccount step.receiver Account.Credit with quantity = step.quantity
                undiscloseA receiverAccount
                -- disclose to actors (such that they can get the TemplateTypeRep in the Batch)
                Some <$> discloseT step.receiver actors holdingCid
              DebitSender -> do
                assertMsg ("sender must be the same party as receiver" <> messageSuffix) $ step.sender == step.receiver
                pure None
              PassthroughTo _ -> abort $ "passthroughs for credits are not supported" <> messageSuffix
              SettleOffLedgerAcknowledge -> abortOnOffLedgerMix
              Unapproved -> abortUnapproved
          (SettleOffLedger, a) ->
            case a of
              SettleOffLedgerAcknowledge -> pure None
              _ -> abortOnOffLedgerMix
