-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Instruction where

import DA.Assert ((===))
import DA.Set qualified as S (empty, fromList, intersection, isSubsetOf, null, singleton)
import Daml.Finance.Interface.Account.Account qualified as Account (I, Credit(..), Debit(..), R, disclose, exerciseInterfaceByKey, undisclose)
import Daml.Finance.Interface.Account.Util (getAccount)
import Daml.Finance.Interface.Holding.Base qualified as Base (I, getLockers)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (disclose, getAmount, getInstrument, undisclose)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), Execute(..), HasImplementation, I, View(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..), RoutedStep)
import Daml.Finance.Interface.Types.Common (Id(..), Parties, PartiesMap)
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, SetObservers(..), View(..), flattenObservers)

-- | Type synonym for `Instruction`.
type T = Instruction

instance Instruction.HasImplementation T

-- | Instruction is used to settle a single settlement `Step`. In order to settle the instruction,
-- - the sender must allocate a suitable holding
-- - the receiver must define the receiving account
template Instruction
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settlers : Parties
      -- ^ Any of the parties can trigger the settlement.
    signedSenders : Parties
      -- ^ Additional signatories, used to collect authorization.
    signedReceivers : Parties
      -- ^ Additional signatories, used to collect authorization.
    batchId : Id
      -- ^ Trade identifier.
    id : Id
      -- ^ Instruction identifier.
    routedStep : RoutedStep
      -- ^ Routed settlement step.
    allocation : Allocation
      -- ^ Allocation from the sender.
    approval : Approval
      -- ^ Approval from the receiver.
    observers : PartiesMap
      -- ^ Observers.
  where
    signatory requestors, signedSenders, signedReceivers
    observer routedStep.sender, routedStep.receiver, settlers, Disclosure.flattenObservers observers

    key InstructionKey with requestors; batchId; id : InstructionKey
    maintainer key.requestors

    let
      messageSuffix = " / instruction id = " <> show id
      context = show batchId <> "(" <> show id <> ")"
      discloseA account =
        Account.disclose (context, settlers) account.owner (S.singleton account.owner) account
      undiscloseA account =
        Account.undisclose (context, settlers) account.owner (S.singleton account.owner) account
      discloseT discloser settlers cid =
        disclose @Holding.I (show batchId, settlers) discloser (S.singleton discloser) cid
      undiscloseT discloser settlers cid =
        undisclose @Holding.I (show batchId, settlers) (S.singleton discloser) cid
      mustContain' : Parties -> Parties -> Update ()
      mustContain' actors ps =
        assertMsg ("actors must include " <> show ps) $ S.isSubsetOf ps actors

    interface instance Disclosure.I for Instruction where
      view = Disclosure.View with
        disclosureControllers = S.fromList [routedStep.sender, routedStep.receiver]; observers
      setObservers Disclosure.SetObservers{newObservers} =
        toInterfaceContractId <$> create this with observers = newObservers
      archive' = archive . fromInterfaceContractId @Instruction

    interface instance Instruction.I for Instruction where
      asDisclosure = toInterface @Disclosure.I this
      view = Instruction.View with
        requestors; settlers
        signedSenders; signedReceivers
        batchId; id
        routedStep
        allocation; approval
      allocate Instruction.Allocate{actors; allocation} = do
        let mustContain = mustContain' actors
        assertMsg ("allocation must be new" <> messageSuffix) $ allocation /= this.allocation
        -- undisclose previous allocation
        otCid <- case this.allocation of
          Pledge holdingCid -> do
            holding <- fetch holdingCid
            undiscloseA $ getAccount holding
            undiscloseT routedStep.sender settlers holdingCid
          PassthroughFrom (passthroughAccount, _) -> do
            undiscloseA passthroughAccount
            pure None
          _ -> pure None
        -- allocate
        allocationDisclosed <- case allocation of
          Pledge holdingCid -> do
            holdingCid <- discloseT routedStep.sender settlers holdingCid
            holding <- fetch holdingCid
            let senderAccount = getAccount holding
            base : Base.I <- fetch $ coerceContractId holdingCid
            discloseA senderAccount
            vSenderAccount <- view <$> fetchInterfaceByKey @Account.R @Account.I senderAccount
            mustContain vSenderAccount.controllers.instructors
            mustContain $ Base.getLockers base
            assertMsg "the custodian of the pledged asset must match the target custodian" $
              routedStep.custodian == senderAccount.custodian
            getAmount holding === routedStep.quantity.amount
            getInstrument holding === routedStep.quantity.unit
            pure $ Pledge holdingCid
          PassthroughFrom (passthroughAccount, fromInstruction) -> do
            discloseA passthroughAccount
            vSenderAccount <- view <$> fetchInterfaceByKey @Account.R @Account.I passthroughAccount
            mustContain vSenderAccount.controllers.instructors
            pure $ PassthroughFrom (passthroughAccount, fromInstruction)
          CreditReceiver -> do
            mustContain $ S.singleton routedStep.custodian
            pure CreditReceiver
          SettleOffLedger -> do
            mustContain $ S.singleton routedStep.custodian
            mustContain $ S.singleton routedStep.sender
            pure SettleOffLedger
          Unallocated -> do
            mustContain signedSenders
            pure Unallocated
        cid <- toInterfaceContractId <$> create this with
          allocation = allocationDisclosed
          signedSenders = if allocationDisclosed == Unallocated then S.empty else actors
        pure (cid, otCid)
      approve Instruction.Approve{actors; approval} = do
        let mustContain = mustContain' actors
        assertMsg ("approval must be new" <> messageSuffix) $ approval /= this.approval
        -- undisclose previous approval
        case this.approval of
          TakeDelivery receiverAccount -> undiscloseA receiverAccount
          PassthroughTo (passthroughAccount, _) -> undiscloseA passthroughAccount
          _ -> pure None
        -- approve
        case approval of
          TakeDelivery receiverAccount -> do
            discloseA receiverAccount
            vReceiverAccount <- view <$> fetchInterfaceByKey @Account.R @Account.I receiverAccount
            mustContain vReceiverAccount.controllers.approvers
            assertMsg "the custodian must match target custodian" $
              routedStep.custodian == receiverAccount.custodian
          PassthroughTo (passthroughAccount, toInstruction) -> do
            discloseA passthroughAccount
            vReceiverAccount <- view <$>
              fetchInterfaceByKey @Account.R @Account.I passthroughAccount
            mustContain vReceiverAccount.controllers.approvers
            mustContain vReceiverAccount.controllers.instructors
          DebitSender -> do
            assertMsg "the receiver must be the custodian" $
              routedStep.custodian == routedStep.receiver
            mustContain $ S.singleton routedStep.custodian
          SettleOffLedgerAcknowledge -> do
            mustContain $ S.singleton routedStep.custodian
            mustContain $ S.singleton routedStep.receiver
          Unapproved -> mustContain signedReceivers
        toInterfaceContractId <$> create this with
          approval
          signedReceivers = if approval == Unapproved then S.empty else actors
      execute Instruction.Execute{actors} = do
        assertMsg "actors must intersect with settlers" $
          not $ S.null $ S.intersection actors settlers
        let
          abortUnapproved = abort $ "instruction must be approved" <> messageSuffix
          abortOnOffLedgerMix =
            abort $ "mix of on- and off-ledger settlement is not supported" <> messageSuffix
        -- execute instruction
        case (allocation, approval) of
          (Unallocated, Unapproved) ->
            abort $ "instruction must be allocated and approved" <> messageSuffix
          (Unallocated, _) -> abort $ "instruction must be allocated" <> messageSuffix
          (_, Unapproved) -> abortUnapproved
          (PassthroughFrom _, _) ->
            -- Pass-throughs are consumed by the routedStep (*) below
            abort $ "holding has not been passed through" <> messageSuffix
          (Pledge holdingCid, a) ->
            case a of
              TakeDelivery receiverAccount -> do
                holding <- fetch holdingCid
                let
                  senderAccount = getAccount holding
                  transferableCid : ContractId Transferable.I = coerceContractId holdingCid
                holdingCid <- toInterfaceContractId <$> exercise transferableCid
                  Transferable.Transfer with
                    actors = signedSenders <> signedReceivers; newOwnerAccount = receiverAccount
                undiscloseA senderAccount
                undiscloseA receiverAccount
                -- disclose for the consistency check in the Batch
                Some <$> discloseT routedStep.receiver actors holdingCid
              DebitSender -> do
                holding <- fetch holdingCid
                let senderAccount = getAccount holding
                assertMsg ("the custodian of the holding must be the receiver" <> messageSuffix) $
                  senderAccount.custodian == routedStep.receiver
                accountCid <- Account.exerciseInterfaceByKey @Account.I senderAccount
                  routedStep.sender Account.Debit with holdingCid
                undiscloseA senderAccount
                pure None
              PassthroughTo (passthroughAccount, toInstructionKey) -> do
                holding <- fetch holdingCid
                let
                  senderAccount = getAccount holding
                  transferableCid : ContractId Transferable.I = coerceContractId holdingCid
                tCid <- toInterfaceContractId <$>
                  exercise transferableCid Transferable.Transfer with
                    actors = signedSenders <> signedReceivers; newOwnerAccount = passthroughAccount
                (toInstructionCid, toInstruction) <- fetchByKey @Instruction toInstructionKey
                assertMsg "passthroughs must match" $
                  toInstruction.allocation == PassthroughFrom (passthroughAccount, key this)
                -- (*) in case of a pass-through, the newly created holding is immediately allocated
                -- to the next routedStep
                exercise (toInterfaceContractId @Instruction.I toInstructionCid)
                  Instruction.Allocate with
                    actors = signedSenders <> signedReceivers; allocation = Pledge tCid
                undiscloseA senderAccount
                undiscloseA passthroughAccount
                pure None
              SettleOffLedgerAcknowledge -> abortOnOffLedgerMix
              Unapproved -> abortUnapproved
          (CreditReceiver, a) ->
            case a of
              TakeDelivery receiverAccount -> do
                assertMsg ("custodian of the receiver account must be the sender" <> messageSuffix)
                  $ receiverAccount.custodian == routedStep.sender
                holdingCid <- Account.exerciseInterfaceByKey @Account.I receiverAccount
                  routedStep.receiver Account.Credit with quantity = routedStep.quantity
                undiscloseA receiverAccount
                -- disclose to actors (such that they can get the TemplateTypeRep in the Batch)
                Some <$> discloseT routedStep.receiver actors holdingCid
              DebitSender -> do
                assertMsg ("sender must be the same party as receiver" <> messageSuffix) $
                  routedStep.sender == routedStep.receiver
                pure None
              PassthroughTo _ ->
                abort $ "passthroughs for credits are not supported" <> messageSuffix
              SettleOffLedgerAcknowledge -> abortOnOffLedgerMix
              Unapproved -> abortUnapproved
          (SettleOffLedger, a) ->
            case a of
              SettleOffLedgerAcknowledge -> pure None
              _ -> abortOnOffLedgerMix
