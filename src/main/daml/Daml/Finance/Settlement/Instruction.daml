-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Instruction where

import DA.Assert ((===))
import DA.Set qualified as S (fromList, insert, intersection, isSubsetOf, member, null, singleton)
import Daml.Finance.Interface.Account.Account qualified as Account (I, Credit(..), Debit(..), R, disclose, exerciseInterfaceByKey, undisclose)
import Daml.Finance.Interface.Account.Util (getAccount)
import Daml.Finance.Interface.Holding.Lockable (getLockers)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (disclose, getAmount, getInstrument, undisclose)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), Execute(..), HasImplementation, I, View(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..), Step)
import Daml.Finance.Interface.Types.Common (Id(..), Parties, PartiesMap)
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, SetObservers(..), View(..), flattenObservers)

-- | Type synonym for `Instruction`.
type T = Instruction

instance Instruction.HasImplementation T

-- | Instruction is used to settle a single settlement `Step`. In order to settle the instruction,
-- - the sender must allocate a suitable transferable holding.
-- - the receiver must define the receiving account.
template Instruction
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settlers : Parties
      -- ^ Any of the parties can trigger the settlement.
    signed : Parties
      -- ^ Additional signatories, used to collect authorization.
    batchId : Id
      -- ^ Trade identifier.
    id : Id
      -- ^ Instruction identifier.
    step : Step
      -- ^ Settlement step.
    allocation : Allocation
      -- ^ Allocation from the sender.
    approval : Approval
      -- ^ Approval from the receiver.
    observers : PartiesMap
      -- ^ Observers.
  where
    signatory requestors, signed
    observer step.sender, step.receiver, settlers, Disclosure.flattenObservers observers

    key InstructionKey with requestors; batchId; id : InstructionKey
    maintainer key.requestors

    let
      messageSuffix = " / instruction id = " <> show id
      context = show batchId <> "(" <> show id <> ")"
      discloseA account = Account.disclose (context, settlers) account.owner (S.singleton account.owner) account
      undiscloseA account = Account.undisclose (context, settlers) account.owner (S.singleton account.owner) account
      discloseT discloser settlers cid = disclose @Transferable.I (show batchId, settlers) discloser (S.singleton discloser) cid
      undiscloseT discloser settlers cid = undisclose @Transferable.I (show batchId, settlers) (S.singleton discloser) cid

    interface instance Disclosure.I for Instruction where
      view = Disclosure.View with disclosureControllers = S.fromList [step.sender, step.receiver]; observers
      setObservers Disclosure.SetObservers{newObservers} = toInterfaceContractId <$> create this with observers = newObservers
      archive' self = archive (coerceContractId self : ContractId Instruction)

    interface instance Instruction.I for Instruction where
      asDisclosure = toInterface @Disclosure.I this
      view = Instruction.View with requestors; settlers; signed; batchId; id; step; allocation; approval
      allocate Instruction.Allocate{actors; allocation} = do
        assertMsg ("allocation must be new" <> messageSuffix) $ allocation /= this.allocation
        -- undisclose previous allocation
        otCid <- case this.allocation of
          Pledge transferableCid -> do
            transferable <- fetch transferableCid
            undiscloseA $ getAccount transferable
            undiscloseT step.sender settlers transferableCid
          PassthroughFrom (passthroughAccount, _) -> do
            undiscloseA passthroughAccount
            pure None
          a -> pure None
        -- allocate
        allocationDisclosed <- case allocation of
          Pledge transferableCid -> do
            transferableCid <- discloseT step.sender settlers transferableCid
            transferable <- fetch transferableCid
            let senderAccount = getAccount transferable
            discloseA senderAccount
            vSenderAccount <- view <$> fetchInterfaceByKey @Account.R senderAccount
            assertMsg "actors must include instructors" $ S.isSubsetOf vSenderAccount.controllers.instructors actors
            assertMsg "actors must include lockers" $ S.isSubsetOf (getLockers transferable) actors
            getAmount transferable === step.quantity.amount
            getInstrument transferable === step.quantity.unit
            pure $ Pledge transferableCid
          PassthroughFrom (passthroughAccount, fromInstruction) -> do
            discloseA passthroughAccount
            vSenderAccount <- view <$> fetchInterfaceByKey @Account.R passthroughAccount
            assertMsg "actors must include instructors" $ S.isSubsetOf vSenderAccount.controllers.instructors actors
            pure $ PassthroughFrom (passthroughAccount, fromInstruction)
          a -> do
            assertMsg "actors must include sender" $ S.member step.sender actors
            pure a
        cid <- toInterfaceContractId <$> create this with allocation = allocationDisclosed; signed = S.insert step.sender signed
        pure (cid, otCid)
      approve Instruction.Approve{actors; approval} = do
        let newSigned = S.insert step.receiver signed
        assertMsg ("approval must be new" <> messageSuffix) $ approval /= this.approval
        -- undisclose previous approval
        case this.approval of
          TakeDelivery receiverAccount -> undiscloseA receiverAccount
          PassthroughTo (passthroughAccount, _) -> undiscloseA passthroughAccount
          a -> pure None
        -- approve
        case approval of
          TakeDelivery receiverAccount -> do
            discloseA receiverAccount
            vReceiverAccount <- view <$> fetchInterfaceByKey @Account.R receiverAccount
            assertMsg "actors must include approvers" $ S.isSubsetOf vReceiverAccount.controllers.approvers actors
          PassthroughTo (passthroughAccount, toInstruction) -> do
            discloseA passthroughAccount
            vReceiverAccount <- view <$> fetchInterfaceByKey @Account.R passthroughAccount
            assertMsg "actors must include approvers" $ S.isSubsetOf vReceiverAccount.controllers.approvers actors
          _ ->
            assertMsg "actors must include receiver" $ S.member step.receiver actors

        toInterfaceContractId <$> create this with signed = newSigned; approval
      execute Instruction.Execute{actors} = do
        assertMsg "actors must intersect with settlers" $ not $ S.null $ S.intersection actors settlers
        let void allocation approval = abort $ "unsupported combination " <> show (allocation, approval) <> messageSuffix
        -- execute instruction
        case (allocation, approval) of
          (Unallocated, _) -> void allocation approval
          (_, Unapproved) -> void allocation approval
          (PassthroughFrom _, _) -> void allocation approval
          (Pledge transferableCid, a) ->
            case a of
              TakeDelivery receiverAccount -> do
                transferable <- fetch transferableCid
                let senderAccount = getAccount transferable
                transferableCid <- exercise transferableCid Transferable.Transfer with actors = signed; newOwnerAccount = receiverAccount
                undiscloseA senderAccount
                undiscloseA receiverAccount
                -- disclose for the consistency check in the Batch
                Some <$> discloseT step.receiver actors transferableCid
              DebitSender -> do
                transferable <- fetch transferableCid
                let senderAccount = getAccount transferable
                assertMsg ("the custodian of the transferable must be the receiver" <> messageSuffix) $ senderAccount.custodian == step.receiver
                accountCid <- Account.exerciseInterfaceByKey @Account.I senderAccount step.sender Account.Debit with holdingCid = coerceContractId transferableCid
                undiscloseA senderAccount
                pure None
              PassthroughTo (passthroughAccount, toInstructionKey) -> do
                transferable <- fetch transferableCid
                let senderAccount = getAccount transferable
                tCid <- exercise transferableCid Transferable.Transfer with actors = signed; newOwnerAccount = passthroughAccount
                (toInstructionCid, toInstruction) <- fetchByKey @Instruction toInstructionKey
                assertMsg "passthroughs must match" $ toInstruction.allocation == PassthroughFrom (passthroughAccount, key this)
                exercise (toInterfaceContractId @Instruction.I toInstructionCid) Instruction.Allocate with actors = signed; allocation = Pledge tCid
                undiscloseA senderAccount
                undiscloseA passthroughAccount
                pure None
              _ -> void allocation approval
          (CreditReceiver, a) ->
            case a of
              TakeDelivery receiverAccount -> do
                assertMsg ("the custodian of the receiver account must be the sender" <> messageSuffix) $ receiverAccount.custodian == step.sender
                transferableCid : ContractId Transferable.I <- coerceContractId <$> Account.exerciseInterfaceByKey @Account.I receiverAccount step.receiver Account.Credit with quantity = step.quantity
                undiscloseA receiverAccount
                -- disclose to actors (such that they can get the TemplateTypeRep in the Batch)
                Some <$> discloseT step.receiver actors transferableCid
              DebitSender -> do
                assertMsg ("sender must be the same party as receiver" <> messageSuffix) $ step.sender == step.receiver
                pure None
              _ -> void allocation approval
          (SettleOffLedger, a) ->
            case a of
              SettleOffLedgerAcknowledge -> pure None
              _ -> void allocation approval
