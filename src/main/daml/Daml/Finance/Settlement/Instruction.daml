-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Instruction where

import DA.Assert ((===))
import DA.List qualified as L (head)
import DA.Set qualified as S (empty, fromList, intersection, isSubsetOf, null, singleton, toList)
import Daml.Finance.Interface.Account.Account qualified as Account (Credit(..), Debit(..), I, discloseByKey, undiscloseByKey)
import Daml.Finance.Interface.Account.Util (getAccount)
import Daml.Finance.Interface.Holding.Base qualified as Base (I, getLockers)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (getAmount, getInstrument)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), Cancel(..), Execute(..), HasImplementation, I, View(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..), RoutedStep)
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), Parties, PartiesMap)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, View(..), flattenObservers, disclose, undisclose)
import Daml.Finance.Interface.Util.Index qualified as Index (I, View(..), HasIndexTable(..), delete, fetchInterfaceByKey, insert)
import Daml.Finance.Util.Disclosure (addObserversImpl, removeObserversImpl, setObserversImpl)

-- | Type synonym for `Instruction`.
type T = Instruction

instance Instruction.HasImplementation T

-- | Instruction is used to settle a single settlement `Step`. In order to settle the instruction,
-- - the sender must allocate a suitable holding
-- - the receiver must define the receiving account
template Instruction
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settlers : Parties
      -- ^ Any of the parties can trigger the settlement.
    batchId : Id
      -- ^ Trade identifier.
    id : Id
      -- ^ Instruction identifier.
    routedStep : RoutedStep
      -- ^ Routed settlement step.
    settlementTime : Optional Time
      -- ^ Settlement time (if any).
    allocation : Allocation
      -- ^ Allocation from the sender.
    approval : Approval
      -- ^ Approval from the receiver.
    signedSenders : Parties
      -- ^ Additional signatories, used to collect authorization.
    signedReceivers : Parties
      -- ^ Additional signatories, used to collect authorization.
    observers : PartiesMap
      -- ^ Observers.
  where
    signatory requestors, signedSenders, signedReceivers
    observer routedStep.sender, routedStep.receiver, settlers, Disclosure.flattenObservers observers

    let
      instruction = InstructionKey with requestors; batchId; id
      messageSuffix = " / instruction id = " <> show id
      context = show batchId <> "(" <> show id <> ")"
      mustBe : Role -> Party -> Update ()
      mustBe role party = do
        let
          roleParty = case role of
            Custodian -> routedStep.custodian
            Sender -> routedStep.sender
            Receiver -> routedStep.receiver
        assertMsg (show party <> " must match " <> show roleParty <> "(" <> show role <> ")") $
          party == roleParty
      -- utilitise for disclose / undisclose
      discloseA = \a idx -> fmap snd <$> Account.discloseByKey (context, settlers) a idx
      undiscloseA = \a idx -> fmap snd <$> Account.undiscloseByKey (context, settlers) a idx
      discloseB disclosers settlers cid = do
        let viewer = L.head $ S.toList disclosers
        Disclosure.disclose @Base.I (show batchId, settlers) viewer disclosers cid
      undiscloseB disclosers settlers cid =
        Disclosure.undisclose @Base.I (show batchId, settlers) disclosers cid
      undisclosePreviousAllocation idx =
        case allocation of
          Pledge previousBaseCid -> do
            previousBase <- fetch previousBaseCid
            let previousSenderAccount = getAccount previousBase
            idx <- undiscloseA previousSenderAccount True idx
            viewA <- view . snd <$>
              Index.fetchInterfaceByKey @Account.I @AccountKey @Account.I idx previousSenderAccount
            (, idx) <$> undiscloseB viewA.controllers.outgoing settlers previousBaseCid
          PassThroughFrom (previousPassthroughAccount, _) -> do
            (None, ) <$> undiscloseA previousPassthroughAccount True idx
          _ ->
            pure (None, idx)
      undisclosePreviousApproval idx =
        case approval of
          TakeDelivery previousReceiverAccount ->
            undiscloseA previousReceiverAccount False idx
          PassThroughTo (previousPassthroughAccount, _) ->
            undiscloseA previousPassthroughAccount False idx
          _ -> pure idx

    interface instance Index.I for Instruction where
      view = Index.View {}

    interface instance Disclosure.I for Instruction where
      view = Disclosure.View with
        disclosureControllers = S.fromList [routedStep.sender, routedStep.receiver]; observers
      setObservers = setObserversImpl @Instruction this
      addObservers = addObserversImpl @Instruction this
      removeObservers = removeObserversImpl @Instruction this

    interface instance Instruction.I for Instruction where
      asDisclosure = toInterface @Disclosure.I this
      view = Instruction.View with
        requestors
        settlers
        batchId
        id
        routedStep
        settlementTime
        signedSenders
        signedReceivers
        allocation
        approval
      allocate Instruction.Allocate{actors; allocation; idx} = do
        let mustAuthorize = mustAuthorizeHelper actors
        assertMsg ("allocation must be new" <> messageSuffix) $ allocation /= this.allocation
        -- undisclose previous allocation
        (obCid, idx) <- undisclosePreviousAllocation idx
        -- allocate
        (newAllocation, idx) <- case allocation of
          Pledge baseCid -> do
            base <- fetch baseCid
            let senderAccount = getAccount base
            vSenderAccount <- view . snd <$>
              Index.fetchInterfaceByKey @Account.I @AccountKey @Account.I idx senderAccount
            idx <- discloseA senderAccount True idx
            baseCid <- discloseB vSenderAccount.controllers.outgoing settlers baseCid
            mustAuthorize vSenderAccount.controllers.outgoing
            mustAuthorize $ Base.getLockers base
            mustBe Custodian senderAccount.custodian
            mustBe Sender senderAccount.owner
            getAmount base === routedStep.quantity.amount
            getInstrument base === routedStep.quantity.unit
            pure $ (Pledge baseCid, idx)
          PassThroughFrom (passthroughAccount, fromInstruction) -> do
            (fromInstructionCid, vFromInstruction) <- fmap view <$>
              Index.fetchInterfaceByKey @Instruction.I @InstructionKey @Instruction.I idx
                fromInstruction
            idx <- discloseA passthroughAccount True idx
            (passthroughAccountCid, vPassthroughAccount) <- fmap view <$>
              Index.fetchInterfaceByKey @Account.I @AccountKey @Account.I idx passthroughAccount
            mustAuthorize vPassthroughAccount.controllers.outgoing
            mustBe Custodian passthroughAccount.custodian
            mustBe Sender passthroughAccount.owner
            assertMsg "must be part of the batch" $ vFromInstruction.batchId == batchId
            mustBe Custodian vFromInstruction.routedStep.custodian
            pure $ (allocation, idx)
          CreditReceiver -> do
            mustAuthorize $ S.singleton routedStep.custodian
            pure (allocation, idx)
          SettleOffledger -> do
            mustAuthorize $ S.singleton routedStep.custodian
            mustAuthorize $ S.singleton routedStep.sender
            pure (allocation, idx)
          Unallocated -> do
            mustAuthorize signedSenders
            pure (allocation, idx)
        cid <- toInterfaceContractId @Instruction.I <$>
          create this with
            allocation = newAllocation
            signedSenders = if newAllocation == Unallocated then S.empty else actors
        let newIdx = Index.insert instruction cid idx
        pure (cid, obCid, newIdx)
      approve Instruction.Approve{actors; approval; idx} = do
        let mustAuthorize = mustAuthorizeHelper actors
        -- approval
        assertMsg ("approval must be new" <> messageSuffix) $ approval /= this.approval
        -- undisclose previous approval
        idx <- undisclosePreviousApproval idx
        -- approve
        idx <- case approval of
          TakeDelivery receiverAccount -> do
            idx <- discloseA receiverAccount False idx
            (receiverAccountCid, vReceiverAccount) <- fmap view <$>
              Index.fetchInterfaceByKey @Account.I @AccountKey @Account.I idx receiverAccount
            mustAuthorize vReceiverAccount.controllers.incoming
            mustBe Custodian vReceiverAccount.custodian
            mustBe Receiver vReceiverAccount.owner
            pure idx
          PassThroughTo (passthroughAccount, toInstruction) -> do
            (toInstructionCid, vToInstruction) <- fmap view <$>
              Index.fetchInterfaceByKey @Instruction.I @InstructionKey @Instruction.I idx
                toInstruction
            idx <- discloseA passthroughAccount False idx
            (passThroughAccountCid, vPassThroughAccount) <- fmap view <$>
              Index.fetchInterfaceByKey @Account.I @AccountKey @Account.I idx passthroughAccount
            mustAuthorize vPassThroughAccount.controllers.incoming
            mustAuthorize vPassThroughAccount.controllers.outgoing
            mustBe Custodian vPassThroughAccount.custodian
            mustBe Receiver vPassThroughAccount.owner
            assertMsg "must be part of the batch" $ toInstruction.batchId == batchId
            mustBe Custodian vToInstruction.routedStep.custodian
            pure idx
          DebitSender -> do
            mustAuthorize $ S.singleton routedStep.custodian
            mustBe Custodian routedStep.receiver
            pure idx
          SettleOffledgerAcknowledge -> do
            mustAuthorize $ S.fromList [routedStep.custodian, routedStep.receiver]
            pure idx
          Unapproved -> do
            mustAuthorize signedReceivers
            pure idx
        instructionCid <- toInterfaceContractId <$> create this with
          approval
          signedReceivers = if approval == Unapproved then S.empty else actors
        pure (instructionCid, Index.insert instruction instructionCid idx)
      execute Instruction.Execute{actors; idx} = do
        let mustAuthorize = mustAuthorizeHelper actors
        mustAuthorize requestors
        assertMsg "actors must intersect with settlers" $
          not $ S.null $ actors `S.intersection` settlers
        let
          abortUnapproved = abort $ "instruction must be approved" <> messageSuffix
          abortOnOffledgerMix =
            abort $ "mix of on- and off-ledger settlement is not supported" <> messageSuffix
        -- execute instruction
        (oCid, idx) <- case (allocation, approval) of
          (Unallocated, Unapproved) -> do
            abort $ "instruction must be allocated and approved" <> messageSuffix
          (Unallocated, _) -> abort $ "instruction must be allocated" <> messageSuffix
          (_, Unapproved) -> abortUnapproved
          (PassThroughFrom _, _) -> do
            -- Pass-throughs are consumed by the routedStep (*) below
            abort $ "holding has not been passed through" <> messageSuffix
          (Pledge baseCid, a) -> do
            case a of
              TakeDelivery receiverAccount -> do
                base <- fetch baseCid
                let
                  senderAccount = getAccount base
                  transferableCid = coerceInterfaceContractId @Transferable.I baseCid
                baseCid <- toInterfaceContractId <$>
                  exercise transferableCid Transferable.Transfer with
                    actors = signedSenders <> signedReceivers; newOwnerAccount = receiverAccount
                    idx
                viewA <- view . snd <$>
                  Index.fetchInterfaceByKey @Account.I @AccountKey @Account.I idx receiverAccount
                -- undiclose accounts
                idx <- undiscloseA senderAccount True idx
                idx <- undiscloseA receiverAccount False idx
                -- disclose to settlers (such that they can get the TemplateTypeRep in the Batch)
                (, idx) . Some <$> discloseB viewA.controllers.incoming settlers baseCid
              DebitSender -> do
                base <- fetch baseCid
                let senderAccount = getAccount base
                (senderAccountCid, _) <- Index.fetchInterfaceByKey @Account.I @AccountKey @Account.I
                  idx senderAccount
                exercise senderAccountCid Account.Debit with holdingCid = baseCid
                (None,) <$> undiscloseA senderAccount True idx
              PassThroughTo (passthroughAccount, toInstruction) -> do
                (toInstructionCid, iToInstruction) <-
                  Index.fetchInterfaceByKey @Instruction.I @InstructionKey @Instruction.I
                    idx toInstruction
                holding <- fetch baseCid
                let
                  senderAccount = getAccount holding
                  transferableCid = coerceInterfaceContractId @Transferable.I baseCid
                tCid <- toInterfaceContractId <$>
                  exercise transferableCid Transferable.Transfer with
                    actors = signedSenders <> signedReceivers
                    newOwnerAccount = passthroughAccount
                    idx
                let vToInstruction = view iToInstruction
                assertMsg "passthroughs must match" $
                  vToInstruction.allocation ==
                    PassThroughFrom (passthroughAccount, instruction)
                -- (*) in case of a pass-through, the newly created holding is immediately allocated
                -- to the next routedStep
                (toInstructionCid, toAllocation, idx) <-
                  exercise (toInterfaceContractId @Instruction.I toInstructionCid)
                    Instruction.Allocate with
                      actors = signedSenders <> signedReceivers
                      allocation = Pledge tCid
                      idx
                toInstruction <- view <$> fetch toInstructionCid
                let newAllocation = toAllocation
                idx <- undiscloseA senderAccount True idx
                idx <- undiscloseA passthroughAccount False idx
                pure (None, idx)
              SettleOffledgerAcknowledge -> abortOnOffledgerMix
              Unapproved -> abortUnapproved
          (CreditReceiver, a) ->
            case a of
              TakeDelivery receiverAccount -> do
                mustBe Custodian routedStep.sender
                (receiverAccountCid, vReceiverAccount) <- fmap view <$>
                  Index.fetchInterfaceByKey @Account.I @AccountKey @Account.I idx receiverAccount
                baseCid <-
                  exercise receiverAccountCid Account.Credit with quantity = routedStep.quantity
                -- undisclose
                idx <- undiscloseA receiverAccount False idx
                -- disclose to actors (such that they can get the TemplateTypeRep in the Batch)
                baseCid <- discloseB signedReceivers actors baseCid
                pure (Some baseCid, idx)
              DebitSender -> do
                mustBe Custodian routedStep.sender
                assertMsg ("sender must be the same party as receiver" <> messageSuffix) $
                  routedStep.sender == routedStep.receiver
                pure (None, idx)
              PassThroughTo _ ->
                abort $ "passthroughs for credits are not supported" <> messageSuffix
              SettleOffledgerAcknowledge -> abortOnOffledgerMix
              Unapproved -> abortUnapproved
          (SettleOffledger, a) ->
            case a of
              SettleOffledgerAcknowledge -> pure (None, idx)
              _ -> abortOnOffledgerMix
        pure (oCid, Index.delete @Instruction.I instruction idx)
      cancel Instruction.Cancel{actors; idx} = do
        let mustAuthorize = mustAuthorizeHelper actors
        mustAuthorize requestors
        idx <- undisclosePreviousApproval idx
        undisclosePreviousAllocation idx

-- | HIDE
data Role
  = Custodian
  | Sender
  | Receiver
  deriving (Eq, Show)

-- | HIDE
mustAuthorizeHelper : Parties -> Parties -> Update ()
mustAuthorizeHelper authorizers parties =
  assertMsg (show parties <> " must be a subset of authorizers (" <> show authorizers <> ")") $
    parties `S.isSubsetOf` authorizers
