-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Instruction where

import DA.Assert ((===))
import DA.Set (fromList, insert, singleton)
import Daml.Finance.Interface.Holding.Account qualified as Account (I, Credit(..), Debit(..), exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (getAccount, getAmount, getInstrument)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), HasImplementation, I, View(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), Step)
import Daml.Finance.Interface.Types.Common (Id(..), Observers, Parties)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), SetObservers(..), I, View(..), flattenObservers)

-- | Type synonym for `Instruction`.
type T = Instruction

instance Instruction.HasImplementation T

-- | Instruction is used to settle a single settlement `Step`. In order to settle the instruction,
-- - the sender must allocate a suitable transferable holding.
-- - the receiver must define the receiving account.
template Instruction
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    signed : Parties
      -- ^ Additional signatories, used to collect authorization.
    settler : Party
      -- ^ Party triggering the settlement.
    id : Id
      -- ^ Instruction identifier.
    step : Step
      -- ^ Settlement step.
    allocation : Allocation
      -- ^ Allocated holding and its template type rep text representation.
    approval : Approval
      -- ^ Receiving account.
    observers : Observers
      -- ^ Observers.
  where
    signatory requestors, signed
    observer step.sender, step.receiver, settler, Disclosure.flattenObservers observers

    key (requestors, id) : (Parties, Id)
    maintainer fst key

    let messageSuffix = " / instruction id = " <> show id

    interface instance Disclosure.I for Instruction where
      view = Disclosure.View with disclosureControllers = fromList [singleton step.sender, singleton step.receiver]; observers
      setObservers Disclosure.SetObservers{newObservers} = toInterfaceContractId <$> create this with observers = newObservers
      archive' self = archive (coerceContractId self : ContractId Instruction)

    interface instance Instruction.I for Instruction where
      asDisclosure = toInterface @Disclosure.I this
      view = Instruction.View with id; step; settler
      allocate Instruction.Allocate{allocation} = do
        assertMsg ("allocation must be new" <> messageSuffix) $ allocation /= this.allocation
        -- verify and disclose allocation
        allocationDisclosed <- case allocation of
          Pledge transferableCid -> do
            transferableCid : ContractId Transferable.I <- coerceContractId <$> exercise (toInterfaceContractId @Disclosure.I transferableCid) Disclosure.AddObservers with disclosers = singleton step.sender; observersToAdd = (show id, singleton settler)
            transferable <- fetch transferableCid
            accountCid <- Account.exerciseInterfaceByKey @Disclosure.I (getAccount transferable) step.sender Disclosure.AddObservers with disclosers = singleton step.sender; observersToAdd = (show id, singleton settler)
            getAmount transferable === step.quantity.amount
            getInstrument transferable === step.quantity.unit
            pure $ Pledge transferableCid
          a -> pure a
        -- update instruction state
        toInterfaceContractId <$> create this with allocation = allocationDisclosed; signed = insert step.sender signed
      approve Instruction.Approve{approval} = do
        assertMsg ("approval must be new" <> messageSuffix) $ approval /= this.approval
        -- disclose approval
        case approval of
          TakeDelivery receiverAccount -> do
            Account.exerciseInterfaceByKey @Disclosure.I receiverAccount step.receiver Disclosure.AddObservers with disclosers = singleton step.receiver; observersToAdd = (show id, singleton settler)
            pure ()
          _ -> pure ()
        -- update instruction state
        toInterfaceContractId <$> create this with signed = insert step.receiver signed; approval
      execute =
        -- execute instruction
        case (allocation, approval) of
          (Unallocated, _) -> abort $ "instruction must be allocated" <> messageSuffix
          (_, Unapproved) -> abort $ "instruction must be approved" <> messageSuffix
          (Pledge transferableCid, TakeDelivery account) -> do
            transferable <- fetch transferableCid
            transferableCid <- exercise transferableCid Transferable.Transfer with newOwnerAccount = account
            Some . coerceContractId <$> exercise (toInterfaceContractId @Disclosure.I transferableCid) Disclosure.AddObservers with disclosers = singleton step.receiver; observersToAdd = (show id, singleton settler)
          (Pledge transferableCid, DebitSender) -> do
            transferable <- fetch transferableCid
            let senderAccount = getAccount transferable
            assertMsg ("the custodian of the transferable must be the receiver" <> messageSuffix) $ senderAccount.custodian == step.receiver
            accountCid <- Account.exerciseInterfaceByKey @Account.I senderAccount step.sender Account.Debit with holdingCid = coerceContractId transferableCid
            pure None
          (CreditReceiver, TakeDelivery receiverAccount) -> do
            assertMsg ("the custodian of the receiver account must be the sender" <> messageSuffix) $ receiverAccount.custodian == step.sender
            transferableCid <- Account.exerciseInterfaceByKey @Account.I receiverAccount step.receiver Account.Credit with quantity = step.quantity
            Some . coerceContractId <$> exercise (toInterfaceContractId @Disclosure.I transferableCid) Disclosure.AddObservers with disclosers = singleton step.receiver; observersToAdd = (show id, singleton settler)
          (CreditReceiver, DebitSender) -> do
            assertMsg ("sender must be the same party as receiver" <> messageSuffix) $ step.sender == step.receiver
            pure None
          (SettleOffledger, SettleOffledgerAcknowledge) -> pure None
          (SettleOffledger, _) -> abort $ "offledger settlement must be acknowledged" <> messageSuffix
          (_, SettleOffledgerAcknowledge) -> abort $ "offledger settlement must be initiated" <> messageSuffix
