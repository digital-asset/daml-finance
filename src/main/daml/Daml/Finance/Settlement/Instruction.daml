-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Instruction where

import DA.List.Total qualified as L (head)
import DA.Optional (fromSomeNote)
import DA.Set qualified as S (empty, fromList, intersection, isSubsetOf, null, singleton, toList, union)
import Daml.Finance.Interface.Account.Account qualified as Account (Credit(..), Debit(..), I, discloseByKey, undiscloseByKey)
import Daml.Finance.Interface.Account.Util (getAccount)
import Daml.Finance.Interface.Holding.Base qualified as Base (Acquire(..), I, LockType(..), Release(..))
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util qualified as Holding (getAmount, getInstrument)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), Cancel(..), Execute(..), I, View(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..), RoutedStep)
import Daml.Finance.Interface.Types.Common.Types (Id(..), Parties, PartiesMap)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, View(..), flattenObservers, disclose, undisclose)
import Daml.Finance.Interface.Util.KeyTable (UpdateWithKey, createWithKey, exercise, exerciseByKey, fetch, deleteWithState, exercise, fetchByKey, withKeyTable)
import Daml.Finance.Interface.Util.KeyTable qualified as SyntheticallyKeyed (I, View(..))
import Daml.Finance.Util.Disclosure (addObserversImpl, removeObserversImpl, setObserversImpl)
import Prelude hiding (archive, create, exercise, exerciseByKey, fetch, fetchByKey, fetchFromInterface, lookup, lookupByKey)

-- | Type synonym for `Instruction`.
type T = Instruction

-- | Instruction is used to settle a single settlement `Step`. In order to settle the instruction,
-- - the sender must allocate a suitable holding
-- - the receiver must define the receiving account
template Instruction
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settlers : Parties
      -- ^ Any of the parties can trigger the settlement.
    batchId : Id
      -- ^ Trade identifier.
    id : Id
      -- ^ Instruction identifier.
    routedStep : RoutedStep
      -- ^ Routed settlement step.
    settlementTime : Optional Time
      -- ^ Settlement time (if any).
    allocation : Allocation
      -- ^ Allocation from the sender.
    approval : Approval
      -- ^ Approval from the receiver.
    signedSenders : Parties
      -- ^ Additional signatories, used to collect authorization.
    signedReceivers : Parties
      -- ^ Additional signatories, used to collect authorization.
    observers : PartiesMap
      -- ^ Observers.
  where
    signatory requestors, signedSenders, signedReceivers
    observer routedStep.sender, routedStep.receiver, settlers, Disclosure.flattenObservers observers

    let
      instructionKey = InstructionKey with requestors; batchId; id
      context = show instructionKey
      mustBe role party = do
        let
          roleParty = case role of
            Custodian -> routedStep.custodian
            Sender -> routedStep.sender
            Receiver -> routedStep.receiver
        assertMsg @UpdateWithKey
          (show party <> " must match " <> show roleParty <> "(" <> show role <> ")") $
          party == roleParty
      addSignatories parties = parties `S.union` S.fromList (signatory this)
      discloseAccount accountKey actors = Account.discloseByKey (context, settlers) accountKey $
        addSignatories actors
      undiscloseAccount accountKey actors = Account.undiscloseByKey (context, settlers) accountKey $
        addSignatories actors
      disclosePledge baseCid actors = Disclosure.disclose @Base.I @UpdateWithKey (context, settlers)
        (addSignatories actors) baseCid
      undisclosePledge baseCid actors = Disclosure.undisclose @Base.I @UpdateWithKey (context,
        settlers) (addSignatories actors) baseCid
      releasePreviousAllocation actors = do
        let allMustAuthorize = mustAuthorizeHelper True actors
        -- signed senders must agree to release previous allocation
        allMustAuthorize signedSenders
        case allocation of
          Pledge lockedCid -> do
            baseCid <- exercise lockedCid Base.Release with context
            base <- fetch baseCid
            let senderAccountKey = getAccount base
            undiscloseAccount senderAccountKey actors
            undisclosePledge baseCid actors
          PassThroughFrom (passThroughAccountKey, _) -> do
            undiscloseAccount passThroughAccountKey actors
            pure None
          _ -> pure None
      releasePreviousApproval actors = do
        let allMustAuthorize = mustAuthorizeHelper True actors
        -- signed receivers must authorize to release previous approval
        allMustAuthorize signedReceivers
        case approval of
          TakeDelivery receiverAccountKey -> undiscloseAccount receiverAccountKey actors
          PassThroughTo (passThroughAccountKey, _) -> undiscloseAccount passThroughAccountKey actors
          _ -> pure None

    interface instance SyntheticallyKeyed.I for Instruction where
      view = SyntheticallyKeyed.View {}

    interface instance Disclosure.I for Instruction where
      view = Disclosure.View with
        disclosureControllers = S.fromList [routedStep.sender, routedStep.receiver]; observers
      setObservers = setObserversImpl @Instruction this
      addObservers = addObserversImpl @Instruction this
      removeObservers = removeObserversImpl @Instruction this

    interface instance Instruction.I for Instruction where
      view = Instruction.View with
        requestors; settlers; batchId; id; routedStep; settlementTime; signedSenders
        signedReceivers; allocation; approval
      getKey = instructionKey
      allocate Instruction.Allocate{actors; allocation; keyTable} = withKeyTable keyTable do
        let
          allMustAuthorize = mustAuthorizeHelper True actors
          atLeastOneMustAuthorize = mustAuthorizeHelper False actors
        atLeastOneMustAuthorize $ S.fromList [routedStep.custodian, routedStep.sender]
        assertMsg ("Allocation must be new. " <> context) $ allocation /= this.allocation
        releasedCid <- releasePreviousAllocation actors
        -- allocate
        newAllocation <- case allocation of
          Pledge baseCid -> do
            baseCid <- disclosePledge baseCid actors
            base <- fetch baseCid
            let senderAccountKey = getAccount base
            senderAccount <- view . snd <$> fetchByKey @Account.I @Account.I senderAccountKey
            discloseAccount senderAccountKey actors
            allMustAuthorize senderAccount.controllers.outgoing
            mustBe Custodian senderAccount.custodian
            mustBe Sender senderAccount.owner
            assertMsg ("Pledged amount must match. " <> context) $
              Holding.getAmount base == routedStep.quantity.amount
            assertMsg ("Pledged instrument must match. " <> context) $
              Holding.getInstrument base == routedStep.quantity.unit
            lockedCid <- exercise baseCid Base.Acquire with
              newLockers = requestors <> senderAccount.controllers.outgoing
              context
              lockType = Base.Semaphore
            pure $ Pledge lockedCid
          PassThroughFrom (passThroughAccountKey, fromInstructionKey) -> do
            discloseAccount passThroughAccountKey actors
            passThroughAccount <- view . snd <$> fetchByKey @Account.I @Account.I
              passThroughAccountKey
            allMustAuthorize passThroughAccount.controllers.incoming
            allMustAuthorize passThroughAccount.controllers.outgoing
            mustBe Custodian passThroughAccount.custodian
            mustBe Sender passThroughAccount.owner
            fromInstruction <- view . snd <$> fetchByKey @Instruction.I @Instruction.I
              fromInstructionKey
            assertMsg ("Pass-through-from instruction must be part of the batch. " <> context) $
              fromInstruction.batchId == batchId && fromInstruction.requestors == requestors
            mustBe Custodian fromInstruction.routedStep.custodian
            mustBe Sender fromInstruction.routedStep.receiver
            pure allocation
          CreditReceiver -> do
            allMustAuthorize $ S.singleton routedStep.custodian
            pure allocation
          SettleOffledger -> do
            allMustAuthorize $ S.fromList [routedStep.custodian, routedStep.sender]
            pure allocation
          Unallocated ->
            pure allocation
        newInstructionCid <- toInterfaceContractId @Instruction.I <$>
          createWithKey @Instruction.I @InstructionKey this with
            allocation = newAllocation
            signedSenders = if newAllocation == Unallocated then S.empty else actors
        pure (newInstructionCid, releasedCid)
      approve Instruction.Approve{actors; approval; keyTable} = withKeyTable keyTable do
        let
          allMustAuthorize = mustAuthorizeHelper True actors
          atLeastOneMustAuthorize = mustAuthorizeHelper False actors
        atLeastOneMustAuthorize $ S.fromList [routedStep.custodian, routedStep.receiver]
        assertMsg ("Approval must be new. " <> context) $ approval /= this.approval
        releasePreviousApproval actors
        -- approve
        case approval of
          TakeDelivery receiverAccountKey -> do
            discloseAccount receiverAccountKey actors
            receiverAccount <- view . snd <$> fetchByKey @Account.I @Account.I receiverAccountKey
            allMustAuthorize receiverAccount.controllers.incoming
            mustBe Custodian receiverAccount.custodian
            mustBe Receiver receiverAccount.owner
          PassThroughTo (passThroughAccountKey, toInstructionKey) -> do
            discloseAccount passThroughAccountKey actors
            passThroughAccount <- view . snd <$> fetchByKey @Account.I @Account.I
              passThroughAccountKey
            allMustAuthorize passThroughAccount.controllers.incoming
            allMustAuthorize passThroughAccount.controllers.outgoing
            mustBe Custodian passThroughAccount.custodian
            mustBe Receiver passThroughAccount.owner
            toInstruction <- view . snd <$> fetchByKey @Instruction.I @Instruction.I
              toInstructionKey
            assertMsg ("Pass-through-to instruction must be part of the batch. " <> context) $
              toInstruction.batchId == batchId && toInstruction.requestors == requestors
            mustBe Custodian toInstruction.routedStep.custodian
            mustBe Receiver toInstruction.routedStep.sender
          DebitSender -> do
            allMustAuthorize $ S.singleton routedStep.custodian
            mustBe Custodian routedStep.receiver
          SettleOffledgerAcknowledge ->
            allMustAuthorize $ S.fromList [routedStep.custodian, routedStep.receiver]
          Unapproved -> pure ()
        toInterfaceContractId <$> createWithKey @Instruction.I @InstructionKey this with
          approval
          signedReceivers = if approval == Unapproved then S.empty else actors
      execute Instruction.Execute{actors; keyTable} = withKeyTable keyTable do
        let allMustAuthorize = mustAuthorizeHelper True actors
        allMustAuthorize requestors
        let
          settler = fromSomeNote ("Actors must intersect with settlers. " <> context) . L.head .
            S.toList $ actors `S.intersection` settlers
          abortUnapproved = abort $ "Instruction must be approved. " <> context
          abortOnOffledgerMix =
            abort $ "Mix of on- and off-ledger settlement is not supported. " <> context
        -- execute instruction
        settledCid <- case (allocation, approval) of
          (Unallocated, Unapproved) -> do
            abort $ "Instruction must be allocated and approved. " <> context
          (Unallocated, _) -> abort $ "Instruction must be allocated. " <> context
          (_, Unapproved) -> abortUnapproved
          (PassThroughFrom _, _) -> do
            -- Pass-throughs are consumed by the routedStep (*) below
            abort $ "Holding has not been passed through. " <> context
          (Pledge lockedCid, a) -> do
            baseCid <- exercise lockedCid Base.Release with context
            base <- fetch baseCid
            let senderAccountKey = getAccount base
            case a of
              TakeDelivery receiverAccountKey -> do
                let transferableCid = fromInterfaceContractId @Transferable.I baseCid
                newBaseCid <- toInterfaceContractId <$> exercise transferableCid
                  (Transferable.Transfer (signedSenders <> signedReceivers) receiverAccountKey)
                -- undisclose accounts
                undiscloseAccount senderAccountKey actors
                undiscloseAccount receiverAccountKey actors
                -- disclose to settlers (such that they can get the TemplateTypeRep in the Batch)
                Some <$> disclosePledge newBaseCid actors
              DebitSender -> do
                senderAccountCid <- fst <$> fetchByKey @Account.I @Account.I senderAccountKey
                exercise senderAccountCid Account.Debit with holdingCid = baseCid
                undiscloseAccount senderAccountKey actors
                pure None
              PassThroughTo (passThroughAccountKey, toInstructionKey) -> do
                let transferableCid = fromInterfaceContractId @Transferable.I baseCid
                baseCid <- toInterfaceContractId <$> exercise transferableCid (Transferable.Transfer
                  (signedSenders <> signedReceivers) passThroughAccountKey)
                (toInstructionCid, toInstruction) <- fmap view <$> fetchByKey @Instruction.I
                  @Instruction.I toInstructionKey
                assertMsg ("The pass-through process must be compatible between the origin and " <>
                  "destination endpoints. " <> context) $
                  toInstruction.allocation == PassThroughFrom (passThroughAccountKey,
                    instructionKey)
                -- (*) in case of a pass-through, the newly created holding is immediately allocated
                -- to the next routedStep
                exercise (toInterfaceContractId @Instruction.I toInstructionCid) $
                  Instruction.Allocate (signedSenders <> signedReceivers) (Pledge baseCid)
                undiscloseAccount senderAccountKey actors
                undiscloseAccount passThroughAccountKey actors
                pure None
              SettleOffledgerAcknowledge -> abortOnOffledgerMix
              Unapproved -> abortUnapproved
          (CreditReceiver, a) ->
            case a of
              TakeDelivery receiverAccountKey -> do
                mustBe Custodian routedStep.sender
                baseCid <- exerciseByKey @Account.I @Account.I settler receiverAccountKey
                  Account.Credit with quantity = routedStep.quantity
                undiscloseAccount receiverAccountKey actors
                -- disclose to actors (such that they can get the TemplateTypeRep in the Batch)
                Some <$> disclosePledge baseCid actors
              DebitSender -> do
                assertMsg ("Sender must be the same party as receiver. " <> context) $
                  routedStep.sender == routedStep.receiver
                pure None
              PassThroughTo _ -> abort $
                "Credit-receiver and pass-through-to combination is not supported. " <> context
              SettleOffledgerAcknowledge -> abortOnOffledgerMix
              Unapproved -> abortUnapproved
          (SettleOffledger, a) ->
            case a of
              SettleOffledgerAcknowledge -> pure None
              _ -> abortOnOffledgerMix
        deleteWithState @Update @Instruction.I instructionKey
        pure settledCid
      cancel Instruction.Cancel{actors; keyTable} = withKeyTable keyTable do
        let allMustAuthorize = mustAuthorizeHelper True actors
        allMustAuthorize requestors
        deleteWithState @Update @Instruction.I instructionKey
        releasePreviousApproval actors
        releasePreviousAllocation actors

-- | HIDE
data Role
  = Custodian
  | Sender
  | Receiver
  deriving (Eq, Show)

-- | HIDE
mustAuthorizeHelper : Bool -> Parties -> Parties -> UpdateWithKey ()
mustAuthorizeHelper requireAllToAuthorize authorizers parties =
  if requireAllToAuthorize then
    assertMsg ("All parties in " <> show parties <> " must be in the authorizing set " <>
      show authorizers <> ")") $ parties `S.isSubsetOf` authorizers
  else
    assertMsg ("At least one party from " <> show parties <> " must be in the authorizing set "
      <> show authorizers <> ".") . not . S.null $ parties  `S.intersection` authorizers
