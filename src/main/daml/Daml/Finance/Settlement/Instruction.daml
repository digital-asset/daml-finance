-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Instruction where

import DA.Assert ((===))
import DA.Optional (fromSome)
import DA.Set (fromList, insert, singleton)
import Daml.Finance.Interface.Holding.Account qualified as Account (exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (getAccount, getAmount, getInstrument)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), HasImplementation, I, View(..))
import Daml.Finance.Interface.Settlement.Types (Step)
import Daml.Finance.Interface.Types.Common (AccountKey(..), Id, Observers, Parties)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), SetObservers(..), I, View(..), flattenObservers)

-- | Type synonym for `Instruction`.
type T = Instruction

instance Instruction.HasImplementation T

-- | Instruction is used to settle a single settlement `Step`. In order to settle the instruction,
-- - the sender must allocate a suitable transferable holding.
-- - the receiver must define the receiving account.
template Instruction
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    signed : Parties
      -- ^ Additional signatories, used to collect authorization.
    settler : Party
      -- ^ Party triggering the settlement.
    id : Id
      -- ^ Instruction identifier.
    step : Step
      -- ^ Settlement step.
    allocation : Optional (ContractId Transferable.I, Text)
      -- ^ Allocated holding and its template type rep text representation.
    account : Optional AccountKey
      -- ^ Receiving account.
    observers : Observers
      -- ^ Observers.
  where
    signatory requestors, signed
    observer step.sender, step.receiver, settler, Disclosure.flattenObservers observers

    key (requestors, id) : (Parties, Id)
    maintainer fst key

    interface instance Disclosure.I for Instruction where
      view = Disclosure.View with disclosureControllers = fromList [singleton step.sender, singleton step.receiver]; observers
      setObservers Disclosure.SetObservers{newObservers} = toInterfaceContractId <$> create this with observers = newObservers
      archive' self = archive (coerceContractId self : ContractId Instruction)

    interface instance Instruction.I for Instruction where
      asDisclosure = toInterface @Disclosure.I this
      view = Instruction.View with id; step; settler
      allocate Instruction.Allocate{transferableCid} = do
        transferableCid <- coerceContractId <$> exercise (toInterfaceContractId @Disclosure.I transferableCid) Disclosure.AddObservers with disclosers = singleton step.sender; observersToAdd = (show id, singleton settler)
        transferable <- fetch transferableCid
        accountCid <- Account.exerciseInterfaceByKey @Disclosure.I (getAccount transferable) step.sender Disclosure.AddObservers with disclosers = singleton step.sender; observersToAdd = (show id, singleton settler)
        getAmount transferable === step.quantity.amount
        getInstrument transferable === step.quantity.unit
        toInterfaceContractId <$> create this with allocation = Some (transferableCid, templateTypeRepToText $ interfaceTypeRep transferable); signed = insert step.sender signed
      approve Instruction.Approve{receiverAccount} = do
        Account.exerciseInterfaceByKey @Disclosure.I receiverAccount step.receiver Disclosure.AddObservers with disclosers = singleton step.receiver; observersToAdd = (show id, singleton settler)
        toInterfaceContractId <$> create this with signed = insert step.receiver signed; account = Some receiverAccount
      execute = exercise (fst $ fromSome allocation) Transferable.Transfer with newOwnerAccount = fromSome account
