-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Instruction where

import DA.Assert ((===))
import DA.List qualified as L (head)
import DA.Set qualified as S (empty, fromList, intersection, isSubsetOf, null, singleton, toList)
import Daml.Finance.Interface.Account.Account qualified as Account (Credit(..), Debit(..), I, R, disclose, exerciseInterfaceByKey, undisclose)
import Daml.Finance.Interface.Account.Util (getAccount)
import Daml.Finance.Interface.Holding.Base qualified as Base (I, getLockers)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (disclose, getAmount, getInstrument, undisclose)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), Execute(..), HasImplementation, I, View(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..), RoutedStep)
import Daml.Finance.Interface.Types.Common (AccountKey, Id(..), Parties, PartiesMap)
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, SetObservers(..), View(..), flattenObservers)

-- | Type synonym for `Instruction`.
type T = Instruction

instance Instruction.HasImplementation T

-- | Instruction is used to settle a single settlement `Step`. In order to settle the instruction,
-- - the sender must allocate a suitable holding
-- - the receiver must define the receiving account
template Instruction
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settlers : Parties
      -- ^ Any of the parties can trigger the settlement.
    signedSenders : Parties
      -- ^ Additional signatories, used to collect authorization.
    signedReceivers : Parties
      -- ^ Additional signatories, used to collect authorization.
    batchId : Id
      -- ^ Trade identifier.
    id : Id
      -- ^ Instruction identifier.
    routedStep : RoutedStep
      -- ^ Routed settlement step.
    allocation : Allocation
      -- ^ Allocation from the sender.
    approval : Approval
      -- ^ Approval from the receiver.
    observers : PartiesMap
      -- ^ Observers.
  where
    signatory requestors, signedSenders, signedReceivers
    observer routedStep.sender, routedStep.receiver, settlers, Disclosure.flattenObservers observers

    key InstructionKey with requestors; batchId; id : InstructionKey
    maintainer key.requestors

    let
      messageSuffix = " / instruction id = " <> show id
      context = show batchId <> "(" <> show id <> ")"
      discloseA = discloseAccountHelper Account.disclose (context, settlers)
      undiscloseA = discloseAccountHelper Account.undisclose (context, settlers)
      discloseB disclosers settlers cid = do
        let viewer = L.head $ S.toList disclosers
        disclose @Base.I (show batchId, settlers) viewer disclosers cid
      undiscloseB disclosers settlers cid =
        undisclose @Base.I (show batchId, settlers) disclosers cid
      mustContain' : Parties -> Parties -> Update ()
      mustContain' actors ps =
        assertMsg ("actors must include " <> show ps) $ S.isSubsetOf ps actors

    interface instance Disclosure.I for Instruction where
      view = Disclosure.View with
        disclosureControllers = S.fromList [routedStep.sender, routedStep.receiver]; observers
      setObservers Disclosure.SetObservers{newObservers} =
        toInterfaceContractId <$> create this with observers = newObservers
      archive' = archive . fromInterfaceContractId @Instruction

    interface instance Instruction.I for Instruction where
      asDisclosure = toInterface @Disclosure.I this
      view = Instruction.View with
        requestors; settlers
        signedSenders; signedReceivers
        batchId; id
        routedStep
        allocation; approval
      allocate Instruction.Allocate{actors; allocation} = do
        let mustContain = mustContain' actors
        assertMsg ("allocation must be new" <> messageSuffix) $ allocation /= this.allocation
        -- undisclose previous allocation
        otCid <- case this.allocation of
          Pledge previousBaseCid -> do
            previousBase <- fetch previousBaseCid
            let previousSenderAccount = getAccount previousBase
            undiscloseA previousSenderAccount True
            viewA <- view <$> fetchInterfaceByKey @Account.R @Account.I previousSenderAccount
            undiscloseB viewA.controllers.debitControllers settlers previousBaseCid
          PassthroughFrom (previousPassthroughAccount, _) -> do
            undiscloseA previousPassthroughAccount True
            pure None
          _ -> pure None
        -- allocate
        allocationDisclosed <- case allocation of
          Pledge baseCid -> do
            base <- fetch baseCid
            let senderAccount = getAccount base
            vSenderAccount <- view <$> fetchInterfaceByKey @Account.R @Account.I senderAccount
            discloseA senderAccount True
            baseCid <- discloseB vSenderAccount.controllers.debitControllers settlers baseCid
            mustContain vSenderAccount.controllers.debitControllers
            mustContain $ Base.getLockers base
            assertMsg "the custodian of the pledged asset must match the target custodian" $
              routedStep.custodian == senderAccount.custodian
            getAmount base === routedStep.quantity.amount
            getInstrument base === routedStep.quantity.unit
            pure $ Pledge baseCid
          PassthroughFrom (passthroughAccount, fromInstruction) -> do
            discloseA passthroughAccount True
            vSenderAccount <- view <$> fetchInterfaceByKey @Account.R @Account.I passthroughAccount
            mustContain vSenderAccount.controllers.debitControllers
            pure $ PassthroughFrom (passthroughAccount, fromInstruction)
          CreditReceiver -> do
            mustContain $ S.singleton routedStep.custodian
            pure CreditReceiver
          SettleOffLedger -> do
            mustContain $ S.singleton routedStep.custodian
            mustContain $ S.singleton routedStep.sender
            pure SettleOffLedger
          Unallocated -> do
            mustContain signedSenders
            pure Unallocated
        cid <- toInterfaceContractId <$> create this with
          allocation = allocationDisclosed
          signedSenders = if allocationDisclosed == Unallocated then S.empty else actors
        pure (cid, otCid)
      approve Instruction.Approve{actors; approval} = do
        let mustContain = mustContain' actors
        assertMsg ("approval must be new" <> messageSuffix) $ approval /= this.approval
        -- undisclose previous approval
        case this.approval of
          TakeDelivery previousReceiverAccount ->
            undiscloseA previousReceiverAccount False
          PassthroughTo (previousPassthroughAccount, _) ->
            undiscloseA previousPassthroughAccount False
          _ -> pure None
        -- approve
        case approval of
          TakeDelivery receiverAccount -> do
            discloseA receiverAccount False
            vReceiverAccount <- view <$> fetchInterfaceByKey @Account.R @Account.I receiverAccount
            mustContain vReceiverAccount.controllers.creditControllers
            assertMsg "the custodian must match target custodian" $
              routedStep.custodian == receiverAccount.custodian
          PassthroughTo (passthroughAccount, toInstruction) -> do
            discloseA passthroughAccount False
            vReceiverAccount <- view <$>
              fetchInterfaceByKey @Account.R @Account.I passthroughAccount
            mustContain vReceiverAccount.controllers.creditControllers
            mustContain vReceiverAccount.controllers.debitControllers
          DebitSender -> do
            assertMsg "the receiver must be the custodian" $
              routedStep.custodian == routedStep.receiver
            mustContain $ S.singleton routedStep.custodian
          SettleOffLedgerAcknowledge -> do
            mustContain $ S.singleton routedStep.custodian
            mustContain $ S.singleton routedStep.receiver
          Unapproved -> mustContain signedReceivers
        toInterfaceContractId <$> create this with
          approval
          signedReceivers = if approval == Unapproved then S.empty else actors
      execute Instruction.Execute{actors} = do
        assertMsg "actors must intersect with settlers" $
          not $ S.null $ S.intersection actors settlers
        let
          abortUnapproved = abort $ "instruction must be approved" <> messageSuffix
          abortOnOffLedgerMix =
            abort $ "mix of on- and off-ledger settlement is not supported" <> messageSuffix
        -- execute instruction
        case (allocation, approval) of
          (Unallocated, Unapproved) ->
            abort $ "instruction must be allocated and approved" <> messageSuffix
          (Unallocated, _) -> abort $ "instruction must be allocated" <> messageSuffix
          (_, Unapproved) -> abortUnapproved
          (PassthroughFrom _, _) -> do
            -- Pass-throughs are consumed by the routedStep (*) below
            abort $ "holding has not been passed through" <> messageSuffix
          (Pledge baseCid, a) -> do
            case a of
              TakeDelivery receiverAccount -> do
                base <- fetch baseCid
                let
                  senderAccount = getAccount base
                  transferableCid : ContractId Transferable.I = coerceContractId baseCid
                baseCid <- toInterfaceContractId <$> exercise transferableCid
                  Transferable.Transfer with
                    actors = signedSenders <> signedReceivers; newOwnerAccount = receiverAccount
                -- disclose for the consistency check in the Batch
                viewA <- view <$> fetchInterfaceByKey @Account.R @Account.I receiverAccount
                oCid <- Some <$> discloseB viewA.controllers.creditControllers actors baseCid
                -- undiclose accounts
                undiscloseA senderAccount True
                undiscloseA receiverAccount False
                pure oCid
              DebitSender -> do
                base <- fetch baseCid
                let senderAccount = getAccount base
                assertMsg ("the custodian of the holding must be the receiver" <> messageSuffix) $
                  senderAccount.custodian == routedStep.receiver
                accountCid <- Account.exerciseInterfaceByKey @Account.I senderAccount
                  routedStep.sender Account.Debit with holdingCid = baseCid
                undiscloseA senderAccount True
                pure None
              PassthroughTo (passthroughAccount, toInstructionKey) -> do
                holding <- fetch baseCid
                let
                  senderAccount = getAccount holding
                  transferableCid : ContractId Transferable.I = coerceContractId baseCid
                tCid <- toInterfaceContractId <$>
                  exercise transferableCid Transferable.Transfer with
                    actors = signedSenders <> signedReceivers; newOwnerAccount = passthroughAccount
                (toInstructionCid, toInstruction) <- fetchByKey @Instruction toInstructionKey
                assertMsg "passthroughs must match" $
                  toInstruction.allocation == PassthroughFrom (passthroughAccount, key this)
                -- (*) in case of a pass-through, the newly created holding is immediately allocated
                -- to the next routedStep
                exercise (toInterfaceContractId @Instruction.I toInstructionCid)
                  Instruction.Allocate with
                    actors = signedSenders <> signedReceivers; allocation = Pledge tCid
                undiscloseA senderAccount True
                undiscloseA passthroughAccount False
                pure None
              SettleOffLedgerAcknowledge -> abortOnOffLedgerMix
              Unapproved -> abortUnapproved
          (CreditReceiver, a) ->
            case a of
              TakeDelivery receiverAccount -> do
                assertMsg ("custodian of the receiver account must be the sender" <> messageSuffix)
                  $ receiverAccount.custodian == routedStep.sender
                baseCid <- Account.exerciseInterfaceByKey @Account.I receiverAccount
                  routedStep.receiver Account.Credit with quantity = routedStep.quantity
                viewA <- view <$> fetchInterfaceByKey @Account.R @Account.I receiverAccount
                -- disclose to actors (such that they can get the TemplateTypeRep in the Batch)
                oCid <- Some <$> discloseB signedReceivers actors baseCid
                -- undisclose
                undiscloseA receiverAccount False
                pure oCid
              DebitSender -> do
                assertMsg ("sender must be the same party as receiver" <> messageSuffix) $
                  routedStep.sender == routedStep.receiver
                pure None
              PassthroughTo _ ->
                abort $ "passthroughs for credits are not supported" <> messageSuffix
              SettleOffLedgerAcknowledge -> abortOnOffLedgerMix
              Unapproved -> abortUnapproved
          (SettleOffLedger, a) ->
            case a of
              SettleOffLedgerAcknowledge -> pure None
              _ -> abortOnOffLedgerMix

-- | HIDE
discloseAccountHelper : forall a. ((Text, Parties) -> Party -> Parties -> AccountKey -> Update a) ->
  (Text, Parties) -> AccountKey -> Bool -> Update a
discloseAccountHelper f (context, settlers) account isInstructor = do
  viewA <- view <$> fetchInterfaceByKey @Account.R @Account.I account
  let
    disclosers = if isInstructor
                 then viewA.controllers.debitControllers
                 else viewA.controllers.creditControllers
    viewer = L.head $ S.toList disclosers
  f (context, settlers) viewer disclosers account
