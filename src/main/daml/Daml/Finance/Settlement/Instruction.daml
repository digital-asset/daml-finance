-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Instruction where

import DA.Assert ((===))
import DA.Set (fromList, insert, singleton)
import Daml.Finance.Interface.Holding.Account qualified as Account (I, Credit(..), Debit(..), exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (getAccount, getAmount, getInstrument)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), HasImplementation, I, View(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), Step)
import Daml.Finance.Interface.Types.Common (Id(..), Parties, PartiesMap)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), SetObservers(..), I, View(..), flattenObservers)
import DA.Tuple (fst3)

-- | Type synonym for `Instruction`.
type T = Instruction

instance Instruction.HasImplementation T

-- | Instruction is used to settle a single settlement `Step`. In order to settle the instruction,
-- - the sender must allocate a suitable transferable holding.
-- - the receiver must define the receiving account.
template Instruction
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    signed : Parties
      -- ^ Additional signatories, used to collect authorization.
    settler : Party
      -- ^ Party triggering the settlement.
    tradeId : Id
      -- ^ Trade identifier.
    id : Id
      -- ^ Instruction identifier.
    step : Step
      -- ^ Settlement step.
    allocation : Allocation
      -- ^ Allocated holding and its template type rep text representation.
    approval : Approval
      -- ^ Receiving account.
    observers : PartiesMap
      -- ^ Observers.
  where
    signatory requestors, signed
    observer step.sender, step.receiver, settler, Disclosure.flattenObservers observers

    key (requestors, tradeId, id) : (Parties, Id, Id)
    maintainer fst3 key

    let
      messageSuffix = " / instruction id = " <> show id
      discloseAccount account discloser = Account.exerciseInterfaceByKey @Disclosure.I account discloser Disclosure.AddObservers with disclosers = singleton discloser; observersToAdd = (show tradeId, singleton settler)
      discloseTransferable : ContractId Transferable.I -> Party -> Update (ContractId Transferable.I) = \transferableCid discloser -> coerceContractId <$> exercise (toInterfaceContractId @Disclosure.I transferableCid) Disclosure.AddObservers with disclosers = singleton discloser; observersToAdd = (show tradeId, singleton settler)

    interface instance Disclosure.I for Instruction where
      view = Disclosure.View with disclosureControllers = fromList [step.sender, step.receiver]; observers
      setObservers Disclosure.SetObservers{newObservers} = toInterfaceContractId <$> create this with observers = newObservers
      archive' self = archive (coerceContractId self : ContractId Instruction)

    interface instance Instruction.I for Instruction where
      asDisclosure = toInterface @Disclosure.I this
      view = Instruction.View with id; step; settler
      allocate Instruction.Allocate{allocation} = do
        assertMsg ("allocation must be new" <> messageSuffix) $ allocation /= this.allocation
        -- verify and disclose allocation
        allocationDisclosed <- case allocation of
          Pledge transferableCid -> do
            transferableCid <- discloseTransferable transferableCid step.sender
            transferable <- fetch transferableCid
            discloseAccount (getAccount transferable) step.sender
            getAmount transferable === step.quantity.amount
            getInstrument transferable === step.quantity.unit
            pure $ Pledge transferableCid
          a -> pure a
        -- update instruction state
        toInterfaceContractId <$> create this with allocation = allocationDisclosed; signed = insert step.sender signed
      approve Instruction.Approve{approval} = do
        assertMsg ("approval must be new" <> messageSuffix) $ approval /= this.approval
        -- disclose approval
        case approval of
          TakeDelivery receiverAccount -> do
            discloseAccount receiverAccount step.receiver
            pure ()
          _ -> pure ()
        -- update instruction state
        toInterfaceContractId <$> create this with signed = insert step.receiver signed; approval
      execute =
        -- execute instruction
        case (allocation, approval) of
          (Unallocated, _) -> abort $ "instruction must be allocated" <> messageSuffix
          (_, Unapproved) -> abort $ "instruction must be approved" <> messageSuffix
          (Pledge transferableCid, TakeDelivery account) -> do
            transferable <- fetch transferableCid
            transferableCid <- exercise transferableCid Transferable.Transfer with newOwnerAccount = account
            Some <$> discloseTransferable transferableCid step.receiver
          (Pledge transferableCid, DebitSender) -> do
            transferable <- fetch transferableCid
            let senderAccount = getAccount transferable
            assertMsg ("the custodian of the transferable must be the receiver" <> messageSuffix) $ senderAccount.custodian == step.receiver
            accountCid <- Account.exerciseInterfaceByKey @Account.I senderAccount step.sender Account.Debit with holdingCid = coerceContractId transferableCid
            pure None
          (CreditReceiver, TakeDelivery receiverAccount) -> do
            assertMsg ("the custodian of the receiver account must be the sender" <> messageSuffix) $ receiverAccount.custodian == step.sender
            transferableCid <- coerceContractId <$> Account.exerciseInterfaceByKey @Account.I receiverAccount step.receiver Account.Credit with quantity = step.quantity
            Some <$> discloseTransferable transferableCid step.receiver
          (CreditReceiver, DebitSender) -> do
            assertMsg ("sender must be the same party as receiver" <> messageSuffix) $ step.sender == step.receiver
            pure None
          (SettleOffLedger, SettleOffLedgerAcknowledge) -> pure None
          (SettleOffLedger, _) -> abort $ "offledger settlement must be acknowledged" <> messageSuffix
          (_, SettleOffLedgerAcknowledge) -> abort $ "offledger settlement must be initiated" <> messageSuffix
