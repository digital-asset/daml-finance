-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Instruction where

import DA.Assert ((===))
import DA.Set qualified as S (fromList, insert, intersection, isSubsetOf, member, null, singleton)
import Daml.Finance.Interface.Account.Account qualified as Account (I, Credit(..), Debit(..), R, disclose, exerciseInterfaceByKey, undisclose)
import Daml.Finance.Interface.Account.Util (getAccount)
import Daml.Finance.Interface.Holding.Base qualified as Base (I, getLockers)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (disclose, getAmount, getInstrument, undisclose)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..), Execute(..), HasImplementation, I, View(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..), RoutedStep)
import Daml.Finance.Interface.Types.Common (Id(..), Parties, PartiesMap)
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, SetObservers(..), View(..), flattenObservers)

-- | Type synonym for `Instruction`.
type T = Instruction

instance Instruction.HasImplementation T

-- | Instruction is used to settle a single settlement `Step`. In order to settle the instruction,
-- - the sender must allocate a suitable holding
-- - the receiver must define the receiving account
template Instruction
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settlers : Parties
      -- ^ Any of the parties can trigger the settlement.
    signed : Parties
      -- ^ Additional signatories, used to collect authorization.
    batchId : Id
      -- ^ Trade identifier.
    id : Id
      -- ^ Instruction identifier.
    routedStep : RoutedStep
      -- ^ Routed settlement step.
    allocation : Allocation
      -- ^ Allocation from the sender.
    approval : Approval
      -- ^ Approval from the receiver.
    observers : PartiesMap
      -- ^ Observers.
  where
    signatory requestors, signed
    observer routedStep.sender, routedStep.receiver, settlers, Disclosure.flattenObservers observers

    key InstructionKey with requestors; batchId; id : InstructionKey
    maintainer key.requestors

    let
      messageSuffix = " / instruction id = " <> show id
      context = show batchId <> "(" <> show id <> ")"
      discloseA account = Account.disclose (context, settlers) account.owner (S.singleton account.owner) account
      undiscloseA account = Account.undisclose (context, settlers) account.owner (S.singleton account.owner) account
      discloseT discloser settlers cid = disclose @Holding.I (show batchId, settlers) discloser (S.singleton discloser) cid
      undiscloseT discloser settlers cid = undisclose @Holding.I (show batchId, settlers) (S.singleton discloser) cid

    interface instance Disclosure.I for Instruction where
      view = Disclosure.View with disclosureControllers = S.fromList [routedStep.sender, routedStep.receiver]; observers
      setObservers Disclosure.SetObservers{newObservers} = toInterfaceContractId <$> create this with observers = newObservers
      archive' self = archive (coerceContractId self : ContractId Instruction)

    interface instance Instruction.I for Instruction where
      asDisclosure = toInterface @Disclosure.I this
      view = Instruction.View with requestors; settlers; signed; batchId; id; routedStep; allocation; approval
      allocate Instruction.Allocate{actors; allocation} = do
        assertMsg ("allocation must be new" <> messageSuffix) $ allocation /= this.allocation
        -- undisclose previous allocation
        otCid <- case this.allocation of
          Pledge holdingCid -> do
            holding <- fetch holdingCid
            undiscloseA $ getAccount holding
            undiscloseT routedStep.sender settlers holdingCid
          PassthroughFrom (passthroughAccount, _) -> do
            undiscloseA passthroughAccount
            pure None
          a -> pure None
        -- allocate
        allocationDisclosed <- case allocation of
          Pledge holdingCid -> do
            holdingCid <- discloseT routedStep.sender settlers holdingCid
            holding <- fetch holdingCid
            let
              senderAccount = getAccount holding
            base : Base.I <- fetch $ coerceContractId holdingCid
            discloseA senderAccount
            vSenderAccount <- view <$> fetchInterfaceByKey @Account.R senderAccount
            assertMsg "actors must include instructors" $ S.isSubsetOf vSenderAccount.controllers.instructors actors
            assertMsg "actors must include lockers" $ S.isSubsetOf (Base.getLockers base) actors
            assertMsg "the custodian of the pledged asset must match the target custodian" $ routedStep.custodian == senderAccount.custodian
            getAmount holding === routedStep.quantity.amount
            getInstrument holding === routedStep.quantity.unit
            pure $ Pledge holdingCid
          PassthroughFrom (passthroughAccount, fromInstruction) -> do
            discloseA passthroughAccount
            vSenderAccount <- view <$> fetchInterfaceByKey @Account.R passthroughAccount
            assertMsg "actors must include instructors" $ S.isSubsetOf vSenderAccount.controllers.instructors actors
            pure $ PassthroughFrom (passthroughAccount, fromInstruction)
          CreditReceiver -> do
            assertMsg "the sender must match the target custodian" $ routedStep.custodian == routedStep.sender
            assertMsg "actors must include sender" $ S.member routedStep.sender actors
            pure CreditReceiver
          a -> do
            assertMsg "actors must include sender" $ S.member routedStep.sender actors
            pure a
        cid <- toInterfaceContractId <$> create this with allocation = allocationDisclosed; signed = S.insert routedStep.sender signed
        pure (cid, otCid)
      approve Instruction.Approve{actors; approval} = do
        let newSigned = S.insert routedStep.receiver signed
        assertMsg ("approval must be new" <> messageSuffix) $ approval /= this.approval
        -- undisclose previous approval
        case this.approval of
          TakeDelivery receiverAccount -> undiscloseA receiverAccount
          PassthroughTo (passthroughAccount, _) -> undiscloseA passthroughAccount
          a -> pure None
        -- approve
        case approval of
          TakeDelivery receiverAccount -> do
            discloseA receiverAccount
            vReceiverAccount <- view <$> fetchInterfaceByKey @Account.R receiverAccount
            assertMsg "actors must include approvers" $ S.isSubsetOf vReceiverAccount.controllers.approvers actors
            assertMsg "the custodian of the receiver account does not match the target custodian" $ routedStep.custodian == receiverAccount.custodian
          PassthroughTo (passthroughAccount, toInstruction) -> do
            discloseA passthroughAccount
            vReceiverAccount <- view <$> fetchInterfaceByKey @Account.R passthroughAccount
            assertMsg "actors must include approvers" $ S.isSubsetOf vReceiverAccount.controllers.approvers actors
          DebitSender -> do
            assertMsg "the receiver must match the target custodian" $ routedStep.custodian == routedStep.receiver
            assertMsg "actors must include receiver" $ S.member routedStep.receiver actors
          _ ->
            assertMsg "actors must include receiver" $ S.member routedStep.receiver actors

        toInterfaceContractId <$> create this with signed = newSigned; approval
      execute Instruction.Execute{actors} = do
        assertMsg "actors must intersect with settlers" $ not $ S.null $ S.intersection actors settlers
        let
          abortUnapproved = abort $ "instruction must be approved" <> messageSuffix
          abortOnOffLedgerMix = abort $ "mix of on- and off-ledger settlement is not supported" <> messageSuffix
        -- execute instruction
        case (allocation, approval) of
          (Unallocated, Unapproved) -> abort $ "instruction must be allocated and approved" <> messageSuffix
          (Unallocated, _) -> abort $ "instruction must be allocated" <> messageSuffix
          (_, Unapproved) ->
            abortUnapproved
          (PassthroughFrom _, _) ->
            -- Pass-throughs are consumed by the routedStep (*) below
            abort $ "holding has not been passed through" <> messageSuffix
          (Pledge holdingCid, a) ->
            case a of
              TakeDelivery receiverAccount -> do
                holding <- fetch holdingCid
                let
                  senderAccount = getAccount holding
                  transferableCid : ContractId Transferable.I = coerceContractId holdingCid
                holdingCid <- toInterfaceContractId <$> exercise transferableCid Transferable.Transfer with actors = signed; newOwnerAccount = receiverAccount
                undiscloseA senderAccount
                undiscloseA receiverAccount
                -- disclose for the consistency check in the Batch
                Some <$> discloseT routedStep.receiver actors holdingCid
              DebitSender -> do
                holding <- fetch holdingCid
                let senderAccount = getAccount holding
                assertMsg ("the custodian of the holding must be the receiver" <> messageSuffix) $ senderAccount.custodian == routedStep.receiver
                accountCid <- Account.exerciseInterfaceByKey @Account.I senderAccount routedStep.sender Account.Debit with holdingCid
                undiscloseA senderAccount
                pure None
              PassthroughTo (passthroughAccount, toInstructionKey) -> do
                holding <- fetch holdingCid
                let
                  senderAccount = getAccount holding
                  transferableCid : ContractId Transferable.I = coerceContractId holdingCid
                tCid <- toInterfaceContractId <$> exercise transferableCid Transferable.Transfer with actors = signed; newOwnerAccount = passthroughAccount
                (toInstructionCid, toInstruction) <- fetchByKey @Instruction toInstructionKey
                assertMsg "passthroughs must match" $ toInstruction.allocation == PassthroughFrom (passthroughAccount, key this)
                -- (*) in case of a pass-through, the newly created holding is immediately allocated to the next routedStep
                exercise (toInterfaceContractId @Instruction.I toInstructionCid) Instruction.Allocate with actors = signed; allocation = Pledge tCid
                undiscloseA senderAccount
                undiscloseA passthroughAccount
                pure None
              SettleOffLedgerAcknowledge -> abortOnOffLedgerMix
              Unapproved -> abortUnapproved
          (CreditReceiver, a) ->
            case a of
              TakeDelivery receiverAccount -> do
                assertMsg ("the custodian of the receiver account must be the sender" <> messageSuffix) $ receiverAccount.custodian == routedStep.sender
                holdingCid <- Account.exerciseInterfaceByKey @Account.I receiverAccount routedStep.receiver Account.Credit with quantity = routedStep.quantity
                undiscloseA receiverAccount
                -- disclose to actors (such that they can get the TemplateTypeRep in the Batch)
                Some <$> discloseT routedStep.receiver actors holdingCid
              DebitSender -> do
                assertMsg ("sender must be the same party as receiver" <> messageSuffix) $ routedStep.sender == routedStep.receiver
                pure None
              PassthroughTo _ -> abort $ "passthroughs for credits are not supported" <> messageSuffix
              SettleOffLedgerAcknowledge -> abortOnOffLedgerMix
              Unapproved -> abortUnapproved
          (SettleOffLedger, a) ->
            case a of
              SettleOffLedgerAcknowledge -> pure None
              _ -> abortOnOffLedgerMix
