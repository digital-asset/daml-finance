-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Batch
  ( Batch(..)
  , T
  ) where

import DA.Foldable (forA_)
import DA.List (groupOn)
import DA.Optional (catOptionals)
import DA.Set (fromList, singleton, size)
import DA.Traversable qualified as T
import Daml.Finance.Interface.Holding.Account qualified as Account (exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Holding.Util (fetchAccount, getAccount)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (HasImplementation, I, View(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Execute(..), I)
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), Step(..))
import Daml.Finance.Interface.Types.Common (Id(..), Parties)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, RemoveObservers(..))
import Daml.Finance.Settlement.Instruction (Instruction(..))

-- | Type synonym for `Batch`.
type T = Batch

instance Batch.HasImplementation T

-- | Allows to atomically settle a set of settlement `Step`\s.
template Batch
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settler : Party
      -- ^ Party triggering the settlement.
    id : Id
      -- ^ Batch identifier.
    description : Text
      -- ^ Batch description.
    stepsWithInstructionId : [(Step, Id)]
      -- ^ The settlement `Step`\s and the identifiers of the corresponding `Instruction`\s.
  where
    signatory requestors
    observer settler

    let (steps, instructionIds) = unzip stepsWithInstructionId

    interface instance Batch.I for Batch where
      view = Batch.View with id; description; settler; steps
      settle = do
        -- collect accounts and check that sender accounts are still active
        accountInstructionIds <- fromList . mconcat <$> forA stepsWithInstructionId
          \(step, instructionId) -> do
            (instructionCid, instruction) <- fetchByKey @Instruction (requestors, instructionId)
            s <- case instruction.allocation of
              Pledge senderTransferableCid -> do
                holding <- fetch $ toInterfaceContractId @Base.I senderTransferableCid
                fetchAccount holding
                pure . Some $ (getAccount holding, instructionId)
              _ -> pure None
            let
              r = case instruction.approval of
                TakeDelivery receiverAccount -> Some (receiverAccount, instructionId)
                _ -> None
            pure $ catOptionals [s, r]
        -- settle
        let
          settleInstruction instructionId = do
            -- NOTE: ideally we should exerciseByKey (but currently doesn't work for interface choices).
            -- (as a workaround we could proxy the choice in the same contract)
            (instructionCid, instruction) <- fetchByKey @Instruction (requestors, instructionId)
            allocatedTransferable <- case instruction.allocation of
              Pledge cid -> Some <$> fetch cid
              _ -> pure None
            transferableCidOpt <- exercise (toInterfaceContractId @Instruction.I instructionCid) Instruction.Execute
            settledTransferable <- T.mapA fetch transferableCidOpt
            -- undisclose transferable
            transferableCidOpt <- fmap coerceContractId . join <$> T.mapA (\tCid -> exercise (toInterfaceContractId @Disclosure.I tCid) Disclosure.RemoveObservers with observersToRemove = (show instructionId, singleton settler)) transferableCidOpt
            let usedTypeRepOpts = fmap (\t -> (instruction.step.quantity.unit, interfaceTypeRep t)) <$> [allocatedTransferable, settledTransferable]
            pure (transferableCidOpt, usedTypeRepOpts)
        -- execute instruction
        (transferableCidOpts, usedTypeRepOpts) <- unzip <$> mapA settleInstruction instructionIds
        -- consistency check
        forA_ (groupOn fst $ catOptionals . concat $ usedTypeRepOpts) \ts ->
          assertMsg "The template type rep of allocated transferables must be the same for all instructions for the same instrument." $ size (fromList ts) == 1
        -- undisclose accounts
        forA_ accountInstructionIds \(account, id) ->
          Account.exerciseInterfaceByKey @Disclosure.I account settler Disclosure.RemoveObservers with observersToRemove = (show id, singleton settler)
        pure $ catOptionals transferableCidOpts
