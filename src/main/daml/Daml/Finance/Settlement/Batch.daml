-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Batch where

import DA.Action (foldlA)
import DA.Foldable (forA_)
import DA.List (groupOn)
import DA.Optional (catOptionals, fromOptional)
import DA.Set (Set)
import DA.Set qualified as S (empty, member, fromList, insert, intersection, null, size, union)
import DA.Traversable qualified as T (mapA)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Cancel(..), HasImplementation, I, Settle(..), View(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Cancel(..), Execute(..), I)
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..), RoutedStep(..))
import Daml.Finance.Interface.Types.Common.Types (Id(..), Parties)
import Daml.Finance.Interface.Util.Disclosure (undisclose)
import Daml.Finance.Interface.Util.Index qualified as Index (IndexTable, fetchInterfaceByKey, getKey)
import Daml.Finance.Settlement.Instruction (mustAuthorizeHelper)

-- | Type synonym for `Batch`.
type T = Batch

instance Batch.HasImplementation T

-- | Type for batch key.
data BatchKey = BatchKey
  with
    requestors : Parties
    id : Id
  deriving (Eq, Show, Ord)

-- | Allows you to atomically settle a set of settlement `Step`.
template Batch
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settlers : Parties
      -- ^ Any of the parties can trigger the settlement.
    id : Id
      -- ^ Batch identifier.
    description : Text
      -- ^ Batch description.
    contextId : Optional Id
      -- ^ Identifier to link a batch to a context (e.g. the `Effect` it originated from).
    routedStepsWithInstructionId : [(RoutedStep, Id)]
      -- ^ The settlement `RoutedStep`\s and the identifiers of the corresponding `Instruction`\s.
    settlementTime : Optional Time
      -- ^ Settlement time (if any).
  where
    signatory requestors
    observer settlers

    let
      (routedSteps, instructionIds) = unzip routedStepsWithInstructionId
      undiscloseT actors = undisclose @Holding.I (show id, settlers) actors
      buildKey instructionId = InstructionKey with requestors; batchId = id; id = instructionId

    interface instance Batch.I for Batch where
      view = Batch.View with
        requestors; settlers; id; description; contextId; routedSteps; settlementTime
      settle Batch.Settle{actors; idx} = do
        assertMsg "actors must intersect with settlers" $
          not $ S.null $ actors `S.intersection` settlers
        -- order instructions (such that they can be executed with passthroughs)
        orderedInstructions <-
          orderPassThroughChains idx . fmap (fmap buildKey) $ routedStepsWithInstructionId
        assertMsg "ordering must be complete" $
          length orderedInstructions == length routedStepsWithInstructionId
        -- settle
        let
          settleInstruction (idx, ts) instruction = do
            (instructionCid, vInstruction) <- fmap view <$> Index.fetchInterfaceByKey @Instruction.I
              @InstructionKey @Instruction.I idx instruction
            allocatedHolding <- case vInstruction.allocation of
              Pledge cid -> Some <$> fetch cid
              _ -> pure None
            (settledHoldingCid, idx) <- exercise instructionCid Instruction.Execute with
              actors = actors `S.union` requestors; idx
            settledHolding <- T.mapA fetch settledHoldingCid
            let
              usedTypeRepOpts = fmap
                (\t -> (vInstruction.routedStep.quantity.unit, interfaceTypeRep t)) <$>
                [allocatedHolding, settledHolding]
            oHoldingCid <-
              T.mapA (\tCid -> fromOptional tCid <$> undiscloseT actors tCid) settledHoldingCid
            pure (idx, (oHoldingCid, usedTypeRepOpts) :: ts)
        -- execute instructions
        (holdingCids, usedTypeReps) <- unzip . reverse . snd <$>
          foldlA settleInstruction (idx, []) orderedInstructions
        -- consistency check
        forA_ (groupOn fst . catOptionals . concat $ usedTypeReps) \ts ->
          assertMsg "Allocated holdings of the same instrument must have the same template type rep"
            $ S.size (S.fromList ts) == 1
        pure $ catOptionals holdingCids
      cancel Batch.Cancel{actors; idx} = do
        let
          mustAuthorize = mustAuthorizeHelper actors
          cancelInstruction instruction = do
            instructionCid <- fst <$> Index.fetchInterfaceByKey @Instruction.I @InstructionKey
              @Instruction.I idx instruction
            fst <$> exercise instructionCid Instruction.Cancel with actors; idx
        mustAuthorize requestors
        -- cancel instructions
        catOptionals <$> mapA (cancelInstruction . buildKey . snd) routedStepsWithInstructionId

-- | HIDE
-- Partially order instructions, so that pass-through chains can be executed in order.
orderPassThroughChains : Index.IndexTable -> [(RoutedStep, InstructionKey)] -> Update [InstructionKey]
orderPassThroughChains idx ts =
  reverse . fst <$> foldlA
    (\(ordered, usedInstructionKeys) (routedStep, instructionKey) -> do
      (instructionCid, instruction) <-
        Index.fetchInterfaceByKey @Instruction.I @InstructionKey @Instruction.I idx instructionKey
      if S.member instructionKey usedInstructionKeys
      then
        -- instruction has already been visited, do not re-insert in list
        pure (ordered, usedInstructionKeys)
      else do
        assertMsg "keys must match" $ instructionKey == Index.getKey instruction
        assertMsg "routed step must match" $ routedStep == (view instruction).routedStep
        let
          ordered' = instructionKey :: ordered
          usedInstructionKeys' = S.insert instructionKey usedInstructionKeys
        case (view instruction).allocation of
          Pledge _ ->
            -- a Pledge might be the start of a pass-through chain, try to follow the chain
            collectPassThroughChain idx ordered' usedInstructionKeys' instructionKey
          PassThroughFrom _ ->
            -- A PassThrough will be visited as part of a chain, do not insert in list
            pure (ordered, usedInstructionKeys)
          _ ->
            pure (ordered', usedInstructionKeys')
    ) ([], S.empty) ts

-- | HIDE
-- Follows the pass-through chain and collects the corresponding instructions in an ordered list.
collectPassThroughChain : Index.IndexTable -> [InstructionKey] -> Set InstructionKey -> InstructionKey ->
  Update ([InstructionKey], Set InstructionKey)
collectPassThroughChain
  idx
  orderedInstructionKeys -- i.e., previously-ordered instructions
  usedInstructionKeys    -- i.e., instructions that have already been visited
  instructionKey = do    -- i.e., first instruction of the chain
    (instructionCid, instruction) <-
      Index.fetchInterfaceByKey @Instruction.I @InstructionKey @Instruction.I idx instructionKey
    case (view instruction).approval of
      PassThroughTo (passthroughAccount, toInstructionKey) -> do
        (toInstructionCid, toInstruction) <-
          Index.fetchInterfaceByKey @Instruction.I @InstructionKey @Instruction.I idx
            toInstructionKey
        assertMsg
          ("toInstruction (" <> show toInstructionKey <> ") must not have been used before (" <>
            show usedInstructionKeys <> ")") $
          not $ S.member toInstructionKey usedInstructionKeys
        collectPassThroughChain
          idx
          (toInstructionKey :: orderedInstructionKeys)
          (S.insert toInstructionKey usedInstructionKeys)
          toInstructionKey
      _ -> pure (orderedInstructionKeys, usedInstructionKeys)
