-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Batch where

import DA.Action (foldlA)
import DA.Foldable (forA_)
import DA.List (groupOn)
import DA.Optional (catOptionals, fromOptional)
import DA.Set (Set, empty, member, fromList, insert, size)
import DA.Traversable qualified as T
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I)
import Daml.Finance.Interface.Holding.Util (undisclose)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (HasImplementation, I, Settle(..), View(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Execute(..), I)
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), Step(..))
import Daml.Finance.Interface.Types.Common (Id(..), InstructionKey(..), Parties)
import Daml.Finance.Settlement.Instruction (Instruction(..))

-- | Type synonym for `Batch`.
type T = Batch

instance Batch.HasImplementation T

-- | Type for batch key.
data BatchKey = BatchKey
  with
    requestors : Parties
    id : Id
  deriving (Eq, Show, Ord)

-- | Allows you to atomically settle a set of settlement `Step`.
template Batch
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settlers : Parties
      -- ^ Any of the parties can trigger the settlement.
    id : Id
      -- ^ Batch identifier.
    description : Text
      -- ^ Batch description.
    contextId : Optional Id
      -- ^ Identifier to link a batch to a context (eg. the `Effect` it originated from).
    stepsWithInstructionId : [(Step, Id)]
      -- ^ The settlement `Step`\s and the identifiers of the corresponding `Instruction`\
  where
    signatory requestors
    observer settlers

    key BatchKey with requestors; id : BatchKey
    maintainer key.requestors

    let
      (steps, instructionIds) = unzip stepsWithInstructionId
      undiscloseT actors = undisclose @Transferable.I (show id, actors) actors

    interface instance Batch.I for Batch where
      view = Batch.View with requestors; settlers; id; description; contextId; steps
      settle Batch.Settle{actors} = do
        -- order instructions (such that they can be executed with passthroughs)
        orderedInstructions <- reverse . fst <$> foldlA
          (\(orderedInstructions, usedInstructionIds) (step, instructionId) ->
            if member instructionId usedInstructionIds then
              -- instruction has already been ordered
              pure (orderedInstructions, usedInstructionIds)
            else
              do
                (instructionCid, instruction) <- fetchByKey @Instruction $ InstructionKey with requestors; batchId = id; id = instructionId
                assertMsg "step must match" $ step == instruction.step
                let
                  orderedInstructions' = instruction :: orderedInstructions
                  usedInstructionIds' = insert instruction.id usedInstructionIds
                case instruction.allocation of
                  Pledge _ -> addPathOfInstructions orderedInstructions' usedInstructionIds' instruction
                  PassthroughFrom _ -> pure (orderedInstructions, usedInstructionIds)
                  _ -> pure (orderedInstructions', usedInstructionIds')
          )
          ([], empty)
          stepsWithInstructionId
        assertMsg "ordering must be complete" $ length orderedInstructions == length stepsWithInstructionId
        -- settle
        let
          settleInstruction instruction = do
            instructionCid <- fst <$> (fetchByKey @Instruction $ key instruction)
            allocatedTransferable <- case instruction.allocation of
              Pledge cid -> Some <$> fetch cid
              _ -> pure None
            transferableCidOpt <- exercise (toInterfaceContractId @Instruction.I instructionCid) Instruction.Execute with actors
            settledTransferable <- T.mapA fetch transferableCidOpt
            -- undisclose transferable
            transferableCidOpt <- T.mapA (\tCid -> fromOptional tCid <$> undiscloseT actors tCid) transferableCidOpt
            let usedTypeRepOpts = fmap (\t -> (instruction.step.quantity.unit, interfaceTypeRep t)) <$> [allocatedTransferable, settledTransferable]
            pure (transferableCidOpt, usedTypeRepOpts)
        -- execute instructions
        (transferableCidOpts, usedTypeRepOpts) <- unzip <$> mapA settleInstruction orderedInstructions
        -- consistency check
        forA_ (groupOn fst $ catOptionals . concat $ usedTypeRepOpts) \ts ->
          assertMsg "The template type rep of allocated transferables must be the same for all instructions for the same instrument." $ size (fromList ts) == 1
        pure $ catOptionals transferableCidOpts

-- | Gets the passthrough instruction path.
addPathOfInstructions : [Instruction] -> Set Id -> Instruction -> Update ([Instruction], Set Id)
addPathOfInstructions orderedInstructions usedInstructionIds instruction =
    case instruction.approval of
      PassthroughTo (passthroughAccount, toInstructionKey) -> do
        toInstruction <- snd <$> fetchByKey @Instruction toInstructionKey
        assertMsg "toInstruction must not have been used before" $ not $ member toInstruction.id usedInstructionIds
        addPathOfInstructions (toInstruction :: orderedInstructions) (insert toInstruction.id usedInstructionIds) toInstruction
      _ -> pure (orderedInstructions, usedInstructionIds)
