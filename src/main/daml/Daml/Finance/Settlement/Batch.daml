-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Batch where

import DA.Action (foldlA)
import DA.Foldable (forA_)
import DA.List (groupOn)
import DA.Optional (catOptionals, fromOptional)
import DA.Set (Set)
import DA.Set qualified as S (empty, member, fromList, insert, intersection, null, size, union)
import DA.Traversable qualified as T (mapA)
import Daml.Control.Monad.Trans.State ()
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Cancel(..), I, Settle(..), View(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Cancel(..), Execute(..), I, V)
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), BatchKey(..), InstructionKey(..), RoutedStep(..))
import Daml.Finance.Interface.Types.Common.Types (Id(..), Parties)
import Daml.Finance.Interface.Util.Disclosure (undisclose)
import Daml.Finance.Interface.Util.SyntheticKey (UpdateWithKey, fetch, exercise, fetchByKey, withKeyTable)
import Daml.Finance.Interface.Util.SyntheticKey qualified as SyntheticKey (I, View(..))
import Daml.Finance.Settlement.Instruction (mustAuthorizeHelper)
import Prelude hiding (archive, create, exercise, exerciseByKey, fetch, fetchByKey, fetchFromInterface, lookup, lookupByKey)

-- | Type synonym for `Batch`.
type T = Batch

-- | Allows you to atomically settle a set of settlement `Step`.
template Batch
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settlers : Parties
      -- ^ Any of the parties can trigger the settlement.
    id : Id
      -- ^ Batch identifier.
    description : Text
      -- ^ Batch description.
    contextId : Optional Id
      -- ^ Identifier to link a batch to a context (e.g. the `Effect` it originated from).
    routedStepsWithInstructionId : [(RoutedStep, Id)]
      -- ^ The settlement `RoutedStep`\s and the identifiers of the corresponding `Instruction`\s.
    settlementTime : Optional Time
      -- ^ Settlement time (if any).
  where
    signatory requestors
    observer settlers

    let
      batch = BatchKey with requestors; id
      (routedSteps, instructionIds) = unzip routedStepsWithInstructionId
      buildKey instructionId = InstructionKey with requestors; batchId = id; id = instructionId

    interface instance SyntheticKey.I for Batch where
      view = SyntheticKey.View {}

    interface instance Batch.I for Batch where
      view = Batch.View with
        requestors; settlers; id; description; contextId; routedSteps; settlementTime
      getKey = batch
      settle Batch.Settle{actors; keyTable} = withKeyTable keyTable do
        assertMsg "actors must intersect with settlers" $
          not $ S.null $ actors `S.intersection` settlers
        -- order instructions (such that they can be executed with passthroughs)
        orderedInstructions <-
          orderPassThroughChains $ buildKey . snd <$> routedStepsWithInstructionId
        assertMsg "ordering must be complete" $
          length orderedInstructions == length routedStepsWithInstructionId
        -- settle
        let
          settleInstruction instruction = do
            (instructionCid, vInstruction) <- fmap view <$> fetchByKey @Instruction.I @Instruction.I
              instruction
            allocatedHolding <- case vInstruction.allocation of
              Pledge cid -> Some <$> fetch cid
              _ -> pure None
            settledHoldingCid <- exercise instructionCid $ Instruction.Execute
              (actors `S.union` requestors)
            settledHolding <- T.mapA fetch settledHoldingCid
            let
              usedTypeRepOpts = fmap
                (\t -> (vInstruction.routedStep.quantity.unit, interfaceTypeRep t)) <$>
                [allocatedHolding, settledHolding]
            holdingCid <- T.mapA
              (\tCid -> fromOptional tCid <$> undisclose @Holding.I (show id, settlers) actors tCid)
              settledHoldingCid
            pure $ (holdingCid, usedTypeRepOpts)
        -- execute instructions (from left to right and implicitly update state)
        (holdingCids, usedTypeReps) <- unzip <$> T.mapA settleInstruction orderedInstructions
        -- consistency check
        forA_ (groupOn fst . catOptionals . concat $ usedTypeReps) \ts ->
          assertMsg "Allocated holdings of the same instrument must have the same template type rep"
            $ S.size (S.fromList ts) == 1
        pure $ catOptionals holdingCids
      cancel Batch.Cancel{actors; keyTable} = withKeyTable keyTable do
        let
          mustAuthorize = mustAuthorizeHelper actors
          cancelInstruction instruction = do
            instructionCid <- fst <$> fetchByKey @Instruction.I @Instruction.I instruction
            exercise instructionCid $ Instruction.Cancel actors
        mustAuthorize requestors
        -- cancel instructions
        catOptionals <$> mapA (cancelInstruction . buildKey . snd) routedStepsWithInstructionId

-- | HIDE
-- Partially order instruction keys, so that pass-through chains can be executed in order.
orderPassThroughChains : [InstructionKey] -> UpdateWithKey [InstructionKey]
orderPassThroughChains l =
  reverse . fst <$> foldlA
    (\(ordered, used) current -> do
      if S.member current used
      then
        -- instruction has already been visited, do not re-insert in list
        pure (ordered, used)
      else do
        currentView <- view . snd <$> fetchByKey @Instruction.I @Instruction.I current
        let
          ordered' = current :: ordered
          used' = S.insert current used
        case currentView.allocation of
          Pledge _ ->
            -- a Pledge might be the start of a pass-through chain, try to follow the chain
            collectPassThroughChain ordered' used' (currentView, current)
          PassThroughFrom _ ->
            -- A PassThrough will be visited as part of a chain, do not insert in list
            pure (ordered, used)
          _ ->
            pure (ordered', used')
    )
    ([], S.empty)
    l

-- | HIDE
-- Follows the pass-through chain and collects the corresponding keys in an ordered list.
collectPassThroughChain : [InstructionKey] -> Set InstructionKey ->
  (Instruction.V, InstructionKey) ->
  UpdateWithKey ([InstructionKey], Set InstructionKey)
collectPassThroughChain
  ordered                  -- i.e., keys for previously-ordered instructions
  used                     -- i.e., keys that have already been visited
  (currentView, current) = -- i.e., first instruction of the chain
    case currentView.approval of
      PassThroughTo (passthroughAccount, toInstruction) -> do
        toInstructionView <- view . snd <$>
          fetchByKey @Instruction.I @Instruction.I toInstruction
        assertMsg "toInstruction must not have been visited before" $
          not $ S.member toInstruction used
        collectPassThroughChain
          (toInstruction :: ordered)
          (S.insert toInstruction used)
          (toInstructionView, toInstruction)
      _ -> pure (ordered, used)
