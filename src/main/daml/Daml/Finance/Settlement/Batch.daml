-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Batch
  ( Batch(..)
  , T
  ) where

import DA.Foldable (forA_)
import DA.Optional (fromSome, fromSomeNote)
import DA.Set (fromList, singleton, size)
import DA.List (groupOn)
import Daml.Finance.Interface.Holding.Account qualified as Account (exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Holding.Util (fetchAccount, getAccount)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (HasImplementation, I, View(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Execute(..))
import Daml.Finance.Interface.Settlement.Types (Step(..))
import Daml.Finance.Interface.Types.Common (Id(..), Parties)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, RemoveObservers(..))
import Daml.Finance.Settlement.Instruction (Instruction(..))

-- | Type synonym for `Batch`.
type T = Batch

instance Batch.HasImplementation T

-- | Allows to atomically settle a set of settlement `Step`\s.
template Batch
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settler : Party
      -- ^ Party triggering the settlement.
    id : Id
      -- ^ Batch identifier.
    description : Text
      -- ^ Batch description.
    stepsWithInstructionId : [(Step, Id)]
      -- ^ The settlement `Step`\s and the identifiers of the corresponding `Instruction`\s.
  where
    signatory requestors
    observer settler

    let (steps, instructionIds) = unzip stepsWithInstructionId

    interface instance Batch.I for Batch where
      view = Batch.View with id; description; settler; steps
      settle = do
        -- collect accounts and check that sender accounts are still active
        accountInstructionIds <- fromList . mconcat <$> forA stepsWithInstructionId
          \(step, instructionId) -> do
            (instructionCid, instruction) <- fetchByKey @Instruction (requestors, instructionId)
            let
              receiverAccount = fromSomeNote "Receiving account not set" instruction.account
              senderTransferableCid = fst $ fromSomeNote "Holding not allocated" instruction.allocation
              holdingCid : ContractId Base.I = coerceContractId senderTransferableCid
            holding <- fetch holdingCid
            fetchAccount holding
            pure [(receiverAccount, instructionId), (getAccount holding, instructionId)]
        -- settle
        let
          settleInstruction instructionId = do
            -- NOTE: ideally we should exerciseByKey (but currently doesn't work for interface choices).
            -- (as a workaround we could proxy the choice in the same contract)
            (instructionCid, instruction) <- fetchByKey @Instruction (requestors, instructionId)
            transferableCid <- exercise instructionCid Instruction.Execute
            pure (transferableCid, (snd $ fromSome instruction.allocation, instruction.step.quantity.unit))
        l <- mapA settleInstruction instructionIds
        -- check consistency
        let
          (transferableCids, ts) = unzip l
          groupedPerInstrument = groupOn snd ts
        forA_ groupedPerInstrument \ts ->
          assertMsg "The template type rep of allocated holdings must be the same for all instructions for the same instrument." $ size (fromList ts) == 1
        forA_ accountInstructionIds \(account, id) ->
          Account.exerciseInterfaceByKey @Disclosure.I account settler Disclosure.RemoveObservers with observersToRemove = (show id, singleton settler)
        pure transferableCids
