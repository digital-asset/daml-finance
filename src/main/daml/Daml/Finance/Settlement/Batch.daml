-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Batch where

import DA.Action (foldlA)
import DA.Foldable (forA_)
import DA.List qualified as L (singleton)
import DA.Map qualified as M (fromList, lookup)
import DA.Optional (catOptionals, fromSomeNote, optionalToList)
import DA.Set (Set)
import DA.Set qualified as S (empty, fromList, insert, intersection, member, null, size, union)
import DA.Traversable qualified as T
import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I)
import Daml.Finance.Interface.Holding.Util (undisclose)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Cancel(..), I, Settle(..), View(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Cancel(..), Execute(..), I)
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..), RoutedStep(..))
import Daml.Finance.Interface.Types.Common.Types (Id(..), Parties)
import Daml.Finance.Settlement.Instruction (Instruction(..), mustAuthorizeHelper)
import Daml.Finance.Util.Common (isInstanceOf, sortAndGroupOn)

-- | Type synonym for `Batch`.
type T = Batch

-- | Allows you to atomically settle a set of settlement `Step`.
template Batch
  with
    requestors : Parties
      -- ^ Parties requesting the settlement.
    settlers : Parties
      -- ^ Any of the parties can trigger the settlement.
    id : Id
      -- ^ Batch identifier.
    description : Text
      -- ^ Batch description.
    contextId : Optional Id
      -- ^ Identifier to link a batch to a context (e.g. the `Effect` it originated from).
    routedStepsWithInstructionId : [(RoutedStep, Id)]
      -- ^ The settlement `RoutedStep`\s and the identifiers of the corresponding `Instruction`\s.
    settlementTime : Optional Time
      -- ^ Settlement time (if any).
  where
    signatory requestors
    observer settlers

    interface instance Batch.I for Batch where
      view = Batch.View with
        requestors; settlers; id; description; contextId; routedSteps = routedSteps this.routedStepsWithInstructionId; settlementTime
      settle Batch.Settle{actors} = do
        assertMsg "actors must intersect with settlers" $
          not $ S.null $ actors `S.intersection` settlers
        -- order instructions (such that they can be executed with passthroughs)
        orderedInstructions <-
          orderPassThroughChains . fmap (fmap (buildKey this)) $ routedStepsWithInstructionId
        assertMsg "ordering must be complete" $
          length orderedInstructions == length routedStepsWithInstructionId
        -- settle
        let
          settleInstruction instructionKey = do
            let context = show instructionKey
            -- execute instruction and get used token standards for the instrument
            (instructionCid, instruction) <- fetchByKey @Instruction instructionKey
            pledgedTokenStandard <- case instruction.allocation of
              Pledge cid -> L.singleton <$> getTokenStandard cid
              _ -> pure []
            settledCid <- exercise (toInterfaceContractId @Instruction.I instructionCid)
              Instruction.Execute with actors = actors `S.union` requestors
            settledTokenStandard <- optionalToList <$> T.mapA getTokenStandard settledCid

            let
              instrumentWithTokenStandards = fmap ((instruction.routedStep.quantity.unit, )) $
                settledTokenStandard <> pledgedTokenStandard
            settledCid <- join <$> T.mapA (undisclose (context, settlers) actors) settledCid
            pure (settledCid, instrumentWithTokenStandards)
        -- execute instructions
        (orderedSettledCids, instrumentWithTokenStandards) <-
          fmap concat . unzip <$> mapA settleInstruction orderedInstructions
        -- assert consistent token standard for each instrument
        forA_ (sortAndGroupOn fst instrumentWithTokenStandards)
          \ts -> assertMsg "Each instrument must use a consistent token standard."
            $ S.size (S.fromList ts) == 1
        -- order returned settledCids according to the initial order of the instructions
        let
          orderedInstructionIdsAndSettleCids =
            zip ((.id) <$> orderedInstructions) orderedSettledCids
          settledCids = fromSomeNote "All keys must exist in the map." .
            (`M.lookup` (M.fromList orderedInstructionIdsAndSettleCids)) <$> instructionIds this.routedStepsWithInstructionId
        pure $ catOptionals settledCids
      cancel Batch.Cancel{actors} = do
        let
          allMustAuthorize = mustAuthorizeHelper True actors
          cancelInstruction instruction = do
            instructionCid <- fst <$> fetchByKey @Instruction instruction
            exercise (toInterfaceContractId @Instruction.I instructionCid)
              Instruction.Cancel with actors
        allMustAuthorize requestors
        -- cancel instructions
        catOptionals <$> mapA (cancelInstruction . buildKey this . snd) routedStepsWithInstructionId

-- Various token standards.
data TokenStandard
  = NonTransferable
    -- ^ Represents a token that implements Base.I but not Transferable.I.
  | NonFungible
    -- ^ Represents a token that implements Transferable.I but not Transferable.I.
  | Fungible
    -- ^ Represents a token that implements Fungible.I.
  deriving (Eq, Ord)

-- | HIDE
-- Returns the token standard of a holding.
getTokenStandard : ContractId Base.I -> Update TokenStandard
getTokenStandard cid = do
  implementsFungible <- isInstanceOf @Fungible.I cid
  if implementsFungible then
    pure Fungible
  else do
    implementsTransferable <- isInstanceOf @Transferable.I cid
    pure $ if implementsTransferable then NonFungible else NonTransferable

-- | HIDE
routedSteps : [(RoutedStep, Id)] -> [RoutedStep]
routedSteps = fmap fst

-- | HIDE
instructionIds : [(RoutedStep, Id)] -> [Id]
instructionIds = fmap snd

-- | HIDE
buildKey : Batch -> Id -> InstructionKey
buildKey Batch {requestors; id} instructionId =
  InstructionKey with requestors; batchId = id; id = instructionId

-- | HIDE
-- Partially order instructions, so that pass-through chains can be executed in order.
orderPassThroughChains : [(RoutedStep, InstructionKey)] -> Update [InstructionKey]
orderPassThroughChains routedStepsWithInstructions =
  reverse . fst <$> foldlA
    (\(ordered, used) (routedStep, current) ->
      if S.member current used
      then
        -- instruction has already been visited, do not re-insert in list
        pure (ordered, used)
      else do
        currentInstruction <- snd <$> fetchByKey @Instruction current
        assertMsg "routed step must match" $ routedStep == currentInstruction.routedStep
        let
          ordered' = current :: ordered
          used' = S.insert current used
        case currentInstruction.allocation of
          -- a Pledge might be the start of a pass-through chain, try to follow the chain
          Pledge _ -> collectPassThroughChain ordered' used' currentInstruction
          -- A PassThroughFrom will be visited as part of a chain, do not insert in list
          PassThroughFrom _ -> pure (ordered, used)
          _ -> pure (ordered', used')
    ) ([], S.empty) routedStepsWithInstructions

-- | HIDE
-- Follows the pass-through chain and collects the corresponding instructions in an ordered list.
collectPassThroughChain : [InstructionKey] -> Set InstructionKey -> Instruction ->
    Update ([InstructionKey], Set InstructionKey)
collectPassThroughChain
  ordered              -- i.e., previously-ordered instructions
  used                 -- i.e., instructions that have already been visited
  currentInstruction = -- i.e., first instruction of the chain
    case currentInstruction.approval of
      PassThroughTo (_, next) -> do
        nextInstruction <- snd <$> fetchByKey @Instruction next
        assertMsg "next instruction must not have been used before" . not $ S.member next used
        collectPassThroughChain (next :: ordered) (S.insert next used) nextInstruction
      _ -> pure (ordered, used)
