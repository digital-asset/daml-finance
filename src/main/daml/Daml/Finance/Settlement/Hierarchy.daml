-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Hierarchy
  ( Hierarchy(..)
  , unfoldStep
  ) where

import DA.List (dedup, isSuffixOf, stripInfix, stripSuffix, tails)
import DA.Optional (isSome)
import Daml.Finance.Interface.Settlement.Types (Step(..))

-- | Data type that describes a hierarchical account structure among multiple parties for holdings on an instrument.
data Hierarchy = Hierarchy
  with
    rootCustodian : Party
      -- ^ Root custodian of the instrument.
    pathsToRootCustodian : [[Party]]
      -- ^ Paths from "leaf" owners to the root custodian of the instrument.
  deriving (Eq, Show)

-- Given a hierarchy, unfold a step from sender to receiver onto the corresponding route.
-- Returns `None` if no route can be found.
unfoldStep : Hierarchy -> Step -> Optional [Step]
unfoldStep hierarchy step = do
  senderPath <- locateParty step.sender hierarchy
  receiverPath <- locateParty step.receiver hierarchy
  map (\(sender, receiver) -> Step with sender; receiver; quantity = step.quantity ) <$> getRoute senderPath receiverPath

-- | HIDE
-- Given a sender path to root custodian and a receiver path to root custodian,
-- calculate the route to transfer a holding from sender to receiver.
-- We assume that transfers can only be done between accounts at the same custodian.
-- Returns `None` if no such route can be found. Otherwise, a list of (sender, receiver) pairs is returned.
getRoute : (Eq a) => [a] -> [a] -> Optional [(a,a)]
getRoute senderPath receiverPath | senderPath `isSuffixOf` receiverPath = do
  -- sending down the chain : cut the receiver path at the sender and flip the chain
  fullRoute <- reverse <$> stripSuffix (drop 1 senderPath) receiverPath
  pure $ zip fullRoute (drop 1 fullRoute)
getRoute senderPath receiverPath | receiverPath `isSuffixOf` senderPath = do
  -- sending up the chain : cut the sender path at the receiver
  fullRoute <- stripSuffix (drop 1 receiverPath) senderPath
  pure $ zip fullRoute (drop 1 fullRoute)
getRoute senderPath receiverPath =
  -- sending up and then down the chain
  case filter (`isSuffixOf` receiverPath) $ tails senderPath of
  [] -> None
  h :: _ -> do
    fromRoute <- stripSuffix h senderPath
    toRoute <- reverse <$> stripSuffix h receiverPath
    let fullRoute = fromRoute <> toRoute
    pure $ zip fullRoute (drop 1 fullRoute)

-- | HIDE
-- Locate a party within a hierarchy, returning the path to the root custodian.
-- Returns `None` if no path can could be found.
-- Returns an error if multiple paths could be found.
locateParty : Party -> Hierarchy -> Optional [Party]
locateParty p h | p == h.rootCustodian = pure [p, p]
locateParty p h =
  case dedup . filter isSome $ map (fmap snd . stripInfix [p]) h.pathsToRootCustodian of
  [Some path] -> pure $ [p] <> path <> [h.rootCustodian]
  [] -> None
  _ -> error $ "Multiple paths to root custodian found for party " <> show p
