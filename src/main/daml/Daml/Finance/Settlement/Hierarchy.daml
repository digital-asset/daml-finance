-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Settlement.Hierarchy
  ( Hierarchy(..)
  , locateParty
  , getRoute
  , unfoldStep
  ) where

import DA.List (dedup, isSuffixOf, stripInfix, stripSuffix, tails)
import DA.Optional (isSome)
import Daml.Finance.Interface.Settlement.Types (RoutedStep(..), Step(..))

-- | Data type that describes a hierarchical account structure among multiple parties for holdings
-- on an instrument.
data Hierarchy = Hierarchy
  with
    rootCustodian : Party
      -- ^ Root custodian of the instrument.
    pathsToRootCustodian : [[Party]]
      -- ^ Paths from "leaf" owners to the root custodian of the instrument.
  deriving (Eq, Show)

-- Given a hierarchy, unfold a step from sender to receiver onto the corresponding route.
-- Returns `None` if no route can be found.
unfoldStep : Hierarchy -> Step -> Optional [RoutedStep]
unfoldStep hierarchy step = do
  senderPath <- locateParty step.sender hierarchy
  receiverPath <- locateParty step.receiver hierarchy
  map (\(sender, receiver, custodian) -> RoutedStep with
    sender; receiver; custodian; quantity = step.quantity ) <$> getRoute senderPath receiverPath

-- | HIDE
-- Given a sender path to root custodian and a receiver path to root custodian, calculate the
-- route to transfer a holding from sender to receiver. We assume that transfers can only be done
-- between accounts at the same custodian. Returns `None` if no such route can be found.
-- Otherwise, a list of (sender, receiver, custodian) triplets is returned.
getRoute : (Eq a) => [a] -> [a] -> Optional [(a,a,a)]
getRoute senderPath receiverPath | senderPath `isSuffixOf` receiverPath = do
  -- sending down the chain : cut the receiver path at the sender and flip the chain
  fullRoute <- reverse <$> stripSuffix (drop 1 senderPath) receiverPath
  pure $ zip3 fullRoute (drop 1 fullRoute) fullRoute
getRoute senderPath receiverPath | receiverPath `isSuffixOf` senderPath = do
  -- sending up the chain : cut the sender path at the receiver
  fullRoute <- stripSuffix (drop 1 receiverPath) senderPath
  let receivers = drop 1 fullRoute
  pure $ zip3 fullRoute receivers receivers
getRoute senderPath receiverPath =
  -- sending up and then down the chain
  case filter (`isSuffixOf` receiverPath) $ tails senderPath of
  [] -> None
  h :: _ -> do
    fromRoute <- stripSuffix h senderPath
    toRoute <- stripSuffix h receiverPath
    let
      -- custodians on the path up the chain
      fromCustodians = fmap snd $ zip fromRoute $ drop 1 senderPath
      -- custodians on the path down the chain
      toCustodians = reverse . fmap snd $ zip toRoute $ drop 1 receiverPath
      fullRoute = fromRoute <> reverse toRoute
      receivers = drop 1 fullRoute
      custodians = fromCustodians <> drop 1 toCustodians
    pure $ zip3 fullRoute receivers custodians

-- | HIDE
-- Locate a party within a hierarchy, returning the path to the root custodian.
-- Returns `None` if no path could be found. Returns an error if multiple paths could be found.
locateParty : Party -> Hierarchy -> Optional [Party]
locateParty p h | p == h.rootCustodian = pure [p, p]
locateParty p h =
  case dedup . filter isSome $ map (fmap snd . stripInfix [p]) h.pathsToRootCustodian of
  [Some path] -> pure $ [p] <> path <> [h.rootCustodian]
  [] -> None
  _ -> error $ "Multiple paths to root custodian found for party " <> show p
