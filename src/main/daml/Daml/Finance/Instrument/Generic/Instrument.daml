-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Generic.Instrument where

import DA.Date (toDateUTC)
import DA.Set (fromList, singleton)
import DA.Text (sha256)
import Daml.Finance.Claims.Util (isZero')
import Daml.Finance.Claims.Util.Lifecycle (electionEvent, lifecycle, splitPending)
import Daml.Finance.Interface.Claims.Claim qualified as Claim (I, GetClaims(..), View(..), getClaims)
import Daml.Finance.Interface.Claims.Types (C, TaggedClaim(..))
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as BaseInstrument (I, R, View(..), createReference, disclosureUpdateReference, getKey)
import Daml.Finance.Interface.Instrument.Generic.Election qualified as Election (ApplyElection(..), Exercisable(..), ExercisableView(..), getElectionTime)
import Daml.Finance.Interface.Instrument.Generic.Instrument qualified as GenericInstrument (HasImplementation, I, View(..))
import Daml.Finance.Interface.Types.Common (Id, InstrumentKey(..), PartiesMap)
import Daml.Finance.Interface.Types.Date.Classes (toUTCTime)
import Daml.Finance.Interface.Util.Common (verify)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, SetObservers(..), View(..), flattenObservers)
import Daml.Finance.Lifecycle.ElectionEffect (ElectionEffect(..))
import Prelude hiding (exercise, key)

-- | Type synonym for `Instrument`.
type T = Instrument

instance GenericInstrument.HasImplementation T

-- | An instrument representing a generic payoff, modelled using the Contingent Claims library.
-- The responsibility for processing lifecycle events as well as elections is delegated to the
-- issuer, who is hence responsible for providing the correct `Observable`\s.
template Instrument
  with
    depository : Party
      -- ^ The instrument depository.
    issuer : Party
      -- ^ The instrument issuer.
    id : Id
      -- ^ The identifier with corresponding version.
    version : Text
      -- ^ The instrument's version.
    description : Text
      -- ^ A human readable description of the instrument.
    claims : C
      -- ^ The claim tree.
    acquisitionTime : Time
      -- ^ The claim's acquisition time. This usually corresponds to the start date of the contract.
    observers : PartiesMap
      -- ^ Observers.
    lastEventTimestamp : Time
      -- ^ (Market) time of the last recorded lifecycle event. If no event has occurred yet, the
      --   time of creation should be used.
  where
    signatory depository, issuer
    observer Disclosure.flattenObservers observers

    let
      instrumentKey = InstrumentKey with depository; issuer; id; version
      lifecycler = issuer

    interface instance Claim.I for Instrument where
      view = Claim.View with acquisitionTime
      asBaseInstrument = toInterface @BaseInstrument.I this
      getClaims _ = pure [TaggedClaim with tag = "Generic"; claim = this.claims]

    interface instance BaseInstrument.I for Instrument where
      asDisclosure = toInterface @Disclosure.I this
      view = BaseInstrument.View with
        depository; issuer; id; version; description; validAsOf = lastEventTimestamp
      getKey = instrumentKey

    interface instance GenericInstrument.I for Instrument where
      asBaseInstrument = toInterface @BaseInstrument.I this
      asClaim = toInterface @Claim.I this
      view = GenericInstrument.View with instrument = instrumentKey; claims

    interface instance Disclosure.I for Instrument where
      view = Disclosure.View with disclosureControllers = singleton issuer; observers
      setObservers Disclosure.SetObservers{newObservers} = do
        cid <- toInterfaceContractId <$> create this with observers = newObservers
        BaseInstrument.disclosureUpdateReference newObservers instrumentKey cid
      archive' self = archive (coerceContractId self : ContractId Instrument)

    interface instance Election.Exercisable for Instrument where
      view = Election.ExercisableView with lifecycler
      applyElection Election.ApplyElection{clockCid; electionCid; observableCids} self = do
        currentTime <- toUTCTime <$> fetch clockCid
        election <- fetch electionCid
        instrumentClaim <- Claim.getClaims (toInterface @Claim.I this) $ Claim.GetClaims with
          actor = lifecycler
        let
          v = view election
          electionTime = Election.getElectionTime election
          election = electionEvent electionTime v.electorIsOwner v.claim
        verify (currentTime == electionTime) $
          "Election time " <> show electionTime <> " is different than Current time " <>
          show currentTime
        (remaining, pending) <- lifecycle lifecycler observableCids (toInterface this) [election]
        if remaining == instrumentClaim && null pending then
          pure (coerceContractId self, [])
        else do
          let
            settlementDate = toDateUTC electionTime
            currentKey = BaseInstrument.getKey $ toInterface this
            newKey = currentKey with version = sha256 $ show remaining
            [claim] = fmap (.claim) remaining
          existingRefCidOpt <- lookupByKey @BaseInstrument.R newKey
          newInstrumentCid <-
            case existingRefCidOpt of
              Some existingRefCid -> do
                ref <- fetch existingRefCid
                pure ref.cid
              None -> do
                instCid <- create this with
                  claims = claim; lastEventTimestamp = electionTime; version = newKey.version
                BaseInstrument.createReference issuer $ toInterfaceContractId instCid
                pure $ toInterfaceContractId instCid
          let (otherConsumed, otherProduced) = splitPending pending
          effectCid <- toInterfaceContractId <$> create ElectionEffect with
            providers = fromList [this.issuer, this.depository]
            custodian = if v.electorIsOwner then v.counterparty else v.elector
            owner = if v.electorIsOwner then v.elector else v.counterparty
            id = v.id
            description = v.description
            targetInstrument = currentKey
            producedInstrument = if isZero' remaining then None else Some newKey
            amount = v.amount
            otherConsumed
            otherProduced
            settlementDate
            observers = v.observers
          pure (newInstrumentCid, [effectCid])
