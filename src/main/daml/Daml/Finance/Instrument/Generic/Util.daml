-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Generic.Util where

import ContingentClaims.Claim (Claim(..), Inequality(..), one, scale, when)
import ContingentClaims.Observation (Observation(..))
import DA.Date
import DA.Record (HasField)
import DA.Set (fromList)
import DA.Text (sha256)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (I, createReference, getKey)
import Daml.Finance.Interface.Instrument.Generic.HasClaims qualified as HasClaims (I, getAcquisitionTime, getClaims)
import Daml.Finance.Interface.Instrument.Generic.Types (C, Deliverable, Observable, TaggedClaim, taggedClaim)
import Daml.Finance.Interface.Instrument.Generic.Util.Claims (isZero', toTime')
import Daml.Finance.Interface.Instrument.Generic.Util.Claims.Lifecycle (lifecycle, lifecycleClaims, splitPending, timeEvent)
import Daml.Finance.Interface.Lifecycle.Clock qualified as Clock (I)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I)
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I)
import Daml.Finance.Interface.Data.Observable qualified as Observable (I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (I)
import Daml.Finance.Interface.Types.Common (Id)
import Daml.Finance.Interface.Types.Date.Classes (toUTCTime)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule(..), Schedule, SchedulePeriod)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, flattenObservers)
import Daml.Finance.Lifecycle.Effect (Effect(..))
import Daml.Finance.Data.Reference.HolidayCalendar (GetCalendar(..), HolidayCalendar, HolidayCalendarKey(..))
import Daml.Finance.Lifecycle.Time.DateClock (Unit(..))
import Daml.Finance.Util.Date.DayCount (calcPeriodDcf)
import Daml.Finance.Util.Date.Schedule (createSchedule)
import Prelude hiding (key)

-- | Retrieve holiday calendar(s) from the ledger and roll out the payment schedule.
rollPaymentSchedule : PeriodicSchedule -> [Text] -> Party -> Party -> Update Schedule
rollPaymentSchedule periodicSchedule holidayCalendarIds issuer calendarDataAgency = do
  let
    -- get a holiday calendar from the ledger
    getCalendar holidayCalendarId = do
      exerciseByKey @HolidayCalendar holCalKey GetCalendar with viewer = issuer where
        holCalKey = HolidayCalendarKey with
          agency = calendarDataAgency
          entity = holidayCalendarId
  -- Get the holiday calendars
  cals <- mapA getCalendar holidayCalendarIds
  pure $ createSchedule cals periodicSchedule

-- | Convert the claims to UTCTime and tag them.
prepareAndTagClaims : Applicative f => [Claim Date Decimal Deliverable Observable] -> Text -> f [TaggedClaim]
prepareAndTagClaims claim tag = do
  let claims = mapClaimToUTCTime $ mconcat claim
  pure [taggedClaim tag claims]

-- FIXED_RATE_BOND_COUPON_CLAIMS_BEGIN
-- | Calculate a fix rate amount for each payment date and create claims.
createFixRatePaymentClaims : Applicative f => [SchedulePeriod] -> PeriodicSchedule -> Bool -> Decimal -> Decimal -> DayCountConventionEnum -> Deliverable -> f [TaggedClaim]
createFixRatePaymentClaims schedule periodicSchedule useAdjustedDatesForDcf couponRate weightMultiplier dayCountConvention cashInstrumentCid = do
  let
    couponDatesAdjusted = map (.adjustedEndDate) schedule
    couponAmounts = map (\p -> couponRate * (calcPeriodDcf dayCountConvention p useAdjustedDatesForDcf periodicSchedule.terminationDate periodicSchedule.frequency)) schedule
    couponClaims = zipWith (\d a -> when (TimeGte $ d) $ scale (Const weightMultiplier * Const a) $ one cashInstrumentCid) couponDatesAdjusted couponAmounts
  prepareAndTagClaims couponClaims "Fix rate payment"
-- FIXED_RATE_BOND_COUPON_CLAIMS_END

-- FLOATING_RATE_BOND_COUPON_CLAIMS_BEGIN
-- | Calculate a floating rate amount for each payment date and create claims.
-- The floating rate is always observed on the first day of each payment period and used for the corresponding payment on the last day of that payment period.
-- This means that the calculation agent needs to provide such an Observable, irrespective of
-- the kind of reference rate used (e.g. a forward looking LIBOR or a backward looking SOFR-COMPOUND).
createFloatingRatePaymentClaims : Applicative f => [SchedulePeriod] -> PeriodicSchedule -> Bool -> Decimal -> Decimal -> DayCountConventionEnum -> Deliverable -> Observable -> f [TaggedClaim]
createFloatingRatePaymentClaims schedule periodicSchedule useAdjustedDatesForDcf floatingRateSpread weightMultiplier dayCountConvention cashInstrumentCid referenceRateId = do
  let
    couponClaims = map (\p ->
      when (TimeGte $ p.adjustedStartDate) $ scale (Const weightMultiplier * (Observe referenceRateId + Const floatingRateSpread) * (Const (calcPeriodDcf dayCountConvention p useAdjustedDatesForDcf periodicSchedule.terminationDate periodicSchedule.frequency))) $
      when (TimeGte $ p.adjustedEndDate) $ one cashInstrumentCid) schedule
  prepareAndTagClaims couponClaims "Floating rate payment"
-- FLOATING_RATE_BOND_COUPON_CLAIMS_END

-- FIXED_RATE_BOND_REDEMPTION_CLAIM_BEGIN
-- | Create a redemption claim.
createRedemptionClaim : Applicative f => Deliverable -> Date -> f [TaggedClaim]
createRedemptionClaim cashInstrumentCid maturityDate = do
  let redemptionClaim = [when (TimeGte $ maturityDate) $ one cashInstrumentCid]
  prepareAndTagClaims redemptionClaim "Redemption payment"
-- FIXED_RATE_BOND_REDEMPTION_CLAIM_END

-- | HIDE
-- Type-class constraint verified by the bond templates.
type IsBond t =
  ( HasToInterface t Disclosure.I
  , HasToInterface t Instrument.I
  , HasToInterface t HasClaims.I
  , HasToInterface t Lifecycle.I
  , HasField "id" t Id
  , HasField "version" t Text
  , HasField "issuer" t Party
  , HasField "lastEventTimestamp" t Time
  , HasCreate t
  )

-- | Maps a `Date` to `Time` using the rule in the `DateClock`.
-- From the Daml.Finance.Instrument.Generics.Test file, but could not import here (duplicated for now).
-- In the termsheet only date is mentioned, but lifecycle logic is based on time.
dateToDateClockTime : Date -> Time
dateToDateClockTime = toUTCTime . Unit

-- | Maps a `Date` claim to a `Time` claim using the rule in the `DateClock`.
-- From the Daml.Finance.Instrument.Generics.Test file, but could not import here (duplicated for now).
-- In the termsheet only date is mentioned, but lifecycle logic is based on time.
mapClaimToUTCTime : Claim Date Decimal Deliverable Observable -> C
mapClaimToUTCTime =
  let dateToTime = toUTCTime . Unit in toTime' dateToTime

-- BOND_PROCESS_CLOCK_UPDATE_INITAL_CLAIMS_BEGIN
-- | Rule to process a clock update event.
processClockUpdate : IsBond t => Party -> ContractId Event.I -> ContractId Clock.I -> ContractId Lifecycle.I -> t -> [ContractId Observable.I] -> Update (ContractId Lifecycle.I, [ContractId Effect.I])
processClockUpdate settler eventCid _ self instrument observableCids = do
  v <- view <$> fetch eventCid
  let
    claimInstrument = toInterface @HasClaims.I instrument
    acquisitionTime = HasClaims.getAcquisitionTime claimInstrument

  -- Recover claims tree as of the lastEventTimestamp. For a bond, this just requires lifecycling as of the lastEventTimestamp.
  initialClaims <- HasClaims.getClaims claimInstrument
  -- BOND_PROCESS_CLOCK_UPDATE_INITAL_CLAIMS_END
  -- BOND_PROCESS_CLOCK_UPDATE_LIFECYCLE_FASTFORWARD_BEGIN
  claims <- Prelude.fst <$> lifecycle observableCids claimInstrument [timeEvent instrument.lastEventTimestamp]
  -- BOND_PROCESS_CLOCK_UPDATE_LIFECYCLE_FASTFORWARD_END

  -- BOND_PROCESS_CLOCK_UPDATE_LIFECYCLE_BEGIN
  -- Lifecycle
  (remaining, pending) <- lifecycleClaims observableCids acquisitionTime claims [timeEvent v.eventTime]
  let (consumed, produced) = splitPending pending
  if remaining == claims && null pending then
    pure (self, [])
  else do
    let
      currentKey = Instrument.getKey $ toInterface @Instrument.I instrument
      settlementDate = toDateUTC v.eventTime -- TODO remove this dependency
      newKey = currentKey with version = sha256 $ show remaining
    newInstrumentCid <- create instrument with lastEventTimestamp = v.eventTime; version = newKey.version
    Instrument.createReference instrument.issuer $ toInterfaceContractId newInstrumentCid
    effectCid <- toInterfaceContractId <$> create Effect with
      provider = fromList [ currentKey.issuer, currentKey.depository ]
      settler
      id = v.id
      description = v.description
      targetInstrument = currentKey
      producedInstrument = if isZero' remaining then None else Some newKey
      consumed
      produced
      settlementDate
      observers = Disclosure.flattenObservers . (.observers) . view $ toInterface @Disclosure.I instrument
    pure (toInterfaceContractId newInstrumentCid, [effectCid])
  -- BOND_PROCESS_CLOCK_UPDATE_LIFECYCLE_END
