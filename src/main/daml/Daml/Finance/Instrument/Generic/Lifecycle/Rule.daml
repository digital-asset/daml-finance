-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Generic.Lifecycle.Rule where

import DA.Date (toDateUTC)
import DA.Optional (fromSome)
import DA.Set (fromList, singleton)
import DA.Text (sha256)
import Daml.Finance.Claims.Util (isZero')
import Daml.Finance.Claims.Util.Lifecycle (electionEvent, lifecycle, splitPending, timeEvent)
import Daml.Finance.Interface.Claims.Claim qualified as Claim (I, GetClaims(..), View(..), getClaims)
import Daml.Finance.Interface.Claims.Types (C, TaggedClaim(..))
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as BaseInstrument (I, R, View(..), createReference, disclosureUpdateReference, getKey)
import Daml.Finance.Interface.Instrument.Generic.Election qualified as Election (ApplyElection(..), Exercisable(..), ExercisableHasImplementation, ExercisableView(..), getElectionTime)
import Daml.Finance.Interface.Instrument.Generic.Instrument qualified as GenericInstrument (HasImplementation, I, View(..))
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I)
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (I, Evolve(..), View(..))
import Daml.Finance.Interface.Types.Common (Id, InstrumentKey(..), Parties, PartiesMap)
import Daml.Finance.Interface.Types.Date.Classes (toUTCTime)
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey, verify)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, SetObservers(..), View(..), flattenObservers)
import Daml.Finance.Instrument.Generic.Instrument (Instrument(..))
import Daml.Finance.Lifecycle.Effect (Effect(..))
import Daml.Finance.Lifecycle.ElectionEffect (ElectionEffect(..))
import Prelude hiding (exercise, key)

-- | Rule to process a time update event.
template Rule
  with
    providers : Parties
      -- ^ Providers of the distribution rule.
    lifecycler : Party
      -- ^ Party performing the lifecycling.
    observers : Parties
      -- ^ Observers of the distribution rule.
  where
    signatory providers
    observer observers, lifecycler

    interface instance Lifecycle.I for Rule where
      view = Lifecycle.View with lifecycler
      evolve Lifecycle.Evolve{eventCid; observableCids; instrument} = do

        -- fetch event
        eventView <- view <$> fetch eventCid
        let eventTime = eventView.eventTime

        -- fetch claim tree
        claimInstrument <- fetchInterfaceByKey @BaseInstrument.R instrument
        claims <- Claim.getClaims claimInstrument $ Claim.GetClaims with actor = lifecycler

        -- lifecycle as of the time given by the event
        (remaining, pending) <-
          lifecycle lifecycler observableCids claimInstrument [timeEvent eventTime]
        if remaining == claims && null pending then
          pure (None, [])
        else do
          let
            instrumentT : Instrument = fromSome $ fromInterface claimInstrument
            settlementDate = toDateUTC eventTime
            currentKey = BaseInstrument.getKey $ toInterface claimInstrument
            [claim] = fmap (.claim) remaining
            newKey = currentKey with version = sha256 $ show remaining
          existingRefCidOpt <- lookupByKey @BaseInstrument.R newKey
          newInstrumentCid <-
            case existingRefCidOpt of
              Some existingRefCid -> do
                ref <- fetch existingRefCid
                pure ref.cid
              None -> do
                instCid <- create instrumentT with
                  claims = claim; lastEventTimestamp = eventTime; version = newKey.version
                BaseInstrument.createReference instrumentT.issuer $ toInterfaceContractId instCid
                pure $ toInterfaceContractId instCid
          let (otherConsumed, otherProduced) = splitPending pending
          effectCid <- toInterfaceContractId <$> create Effect with
            providers = fromList [instrumentT.issuer, instrumentT.depository]
            id = eventView.id
            description = eventView.description
            targetInstrument = currentKey
            producedInstrument = if isZero' remaining then None else Some newKey
            otherConsumed
            otherProduced
            settlementDate
            observers = Disclosure.flattenObservers instrumentT.observers
          pure (Some newKey, [effectCid])
