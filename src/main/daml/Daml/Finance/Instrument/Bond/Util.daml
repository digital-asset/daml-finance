-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Bond.Util where

import ContingentClaims.Core.Claim (and, at, give, one, or, scale, when)
import ContingentClaims.Core.Observation (Observation(..))
import DA.List (last)
import Daml.Finance.Claims.Util.Builders (prepareAndTagClaims)
import Daml.Finance.Data.Reference.HolidayCalendar (GetCalendar(..), HolidayCalendar, HolidayCalendarKey(..))
import Daml.Finance.Data.Time.DateClock.Types (Unit(..))
import Daml.Finance.Interface.Claims.Types (Deliverable, TaggedClaim(..))
import Daml.Finance.Interface.Instrument.Bond.Callable.BondTypes
import Daml.Finance.Interface.Types.Date.Calendar
import Daml.Finance.Interface.Types.Date.Classes (toUTCTime)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule(..), Schedule)
import Daml.Finance.Util.Date.DayCount (calcPeriodDcf)
import Daml.Finance.Util.Date.Schedule (createSchedule)
import Prelude hiding (and, key, or)

-- | Maps a `Date` to `Time` using the rule in the `DateClock`.
dateToDateClockTime : Date -> Time
dateToDateClockTime = toUTCTime . Unit

-- | Retrieve holiday calendar(s) from the ledger.
getHolidayCalendars : Party -> Party -> [Text] -> Update [HolidayCalendarData]
getHolidayCalendars actor provider holidayCalendarIds =
  let
    -- get a holiday calendar from the ledger
    getCalendar id = exerciseByKey @HolidayCalendar (HolidayCalendarKey with provider; id)
      GetCalendar with viewer = actor
  in
    -- get the holiday calendars
    mapA getCalendar holidayCalendarIds

-- | Retrieve holiday calendar(s) from the ledger and roll out a schedule.
rollSchedule : ([Text] -> Update [HolidayCalendarData]) -> PeriodicSchedule -> [Text] ->
  Update Schedule
rollSchedule getHolidayCalendars periodicSchedule holidayCalendarIds = do
  cals <- getHolidayCalendars holidayCalendarIds
  pure $ createSchedule cals periodicSchedule

-- | Calculate the claims for a callable bond with a fixed and/or floating coupon on each payment
--   date and a redemption amount at the end (unless called by the issuer).
createCallableBondClaims : (Date -> Time) -> Schedule -> PeriodicSchedule -> Bool
  -> Decimal -> DayCountConventionEnum -> Decimal -> Deliverable -> Optional FloatingRate
  -> Update TaggedClaim
createCallableBondClaims dateToTime schedule periodicSchedule useAdjustedDatesForDcf
  couponRate dayCountConvention notional cashInstrumentCid floatingRate = do
    let
      couponDatesAdjusted = map (.adjustedEndDate) schedule

      notionalAmount = scale (Const notional) $ one cashInstrumentCid
      principal = give $ notionalAmount

      finalCouponDate = last couponDatesAdjusted
      notCalledFinal = when (at finalCouponDate) principal

      -- Coupons and principal have a give node in front, to undo the give required in the main
      -- claim (in front of the or node, see explanation below).
      combineTagClaim p notCalledClaim =
        let
          dcf = Const $ calcPeriodDcf dayCountConvention p useAdjustedDatesForDcf
            periodicSchedule.terminationDate periodicSchedule.frequency
          notionalAtPeriodEnd = when (at p.adjustedEndDate) $ notionalAmount
          cpn = case floatingRate of
            None -> scale ((Const couponRate) * dcf) $ notionalAtPeriodEnd
            Some fr -> when (at resetDate) $
              scale ((Observe fr.referenceRateId + Const couponRate) * dcf) $ notionalAtPeriodEnd
              where
                resetDate = if fr.resetRelativeTo == CalculationPeriodStartDate
                  then p.adjustedStartDate
                  else p.adjustedEndDate
          coupon = give $ cpn
          called = ("CALLED", principal)
          notCalled = ("NOT CALLED", notCalledClaim)
        in
          and coupon $ when (at p.adjustedEndDate) $ or called notCalled
        -- TODO: exclude the Or on the last coupon date (there is no decision to call/not call, just pay the principal)

      claimAmount = foldr (\p acc -> combineTagClaim p acc) notCalledFinal schedule

      -- For a callable bond, it is the issuer that has the right to call. This is indicated
      -- by a give node, which applies to all sub-nodes of the claims branch. However, the
      -- coupons and the principal belong to the invester, which is why another give node is
      -- required to undo the first give.
      claims = give claimAmount

    debug $ show claims
    pure $ prepareAndTagClaims dateToTime [claims] "Callable bond payment"
