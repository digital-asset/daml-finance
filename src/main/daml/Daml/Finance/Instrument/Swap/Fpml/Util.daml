-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Swap.Fpml.Util where

import ContingentClaims.Claim (Inequality(..), give, one, scale, when)
import ContingentClaims.Observation (Observation(..))
import DA.Date
import DA.Optional (fromOptional, fromSome, isNone, isSome)
import Daml.Finance.Instrument.Generic.Util
import Daml.Finance.Interface.Claims.Types (Deliverable, Observable, TaggedClaim(..))
import Daml.Finance.Interface.Types.Date.Calendar
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule(..), SchedulePeriod, StubPeriodTypeEnum(..))
import Daml.Finance.Interface.Types.Fpml
import Daml.Finance.Util.Date.Calendar (addBusinessDays, adjustDate, merge)
import Daml.Finance.Util.Date.DayCount (calcPeriodDcf)
import Daml.Finance.Util.Date.RollConvention (addPeriod)
import Prelude hiding (key)

-- | Create claims from swapStream that describes a fix coupon stream.
calculateClaimsFromFixSwapStream : SwapStream -> PeriodicSchedule -> [SchedulePeriod] -> Bool -> Bool -> Deliverable -> Update TaggedClaim
calculateClaimsFromFixSwapStream s periodicSchedule streamSchedule useAdjustedDatesForDcf issuerPaysLeg currency = do
  let f = fromSome s.calculationPeriodAmount.calculation.fixedRateSchedule
  pure $ createFixRatePaymentClaims streamSchedule periodicSchedule useAdjustedDatesForDcf f.initialValue issuerPaysLeg s.calculationPeriodAmount.calculation.dayCountFraction currency

-- | Rule when one specific floating rate is provided for a stub period.
getSingleStubRateFromFpml : StubFloatingRate -> Optional (Observation Date Decimal Observable)
getSingleStubRateFromFpml floatingRate = do
  Some (Observe floatingRate.floatingRateIndex)

-- | Linearly interpolates two rates within a period, as specified in https://www.isda.org/a/aWkgE/Linear-interpolation-04022022.pdf
getInterpolatedStubRateFromFpml : StubFloatingRate -> StubFloatingRate -> SchedulePeriod -> HolidayCalendarData -> BusinessDayConventionEnum -> Optional (Observation Date Decimal Observable)
getInterpolatedStubRateFromFpml fr1 fr2 p cal convention = do
  let
    tenor1 = fromSome fr1.indexTenor
    tenor2 = fromSome fr2.indexTenor
    s = p.adjustedStartDate
    p1 = adjustDate cal convention (addPeriod s tenor1)
    p2 = adjustDate cal convention (addPeriod s tenor2)
    tn = subDate p.adjustedEndDate s
    t1 = subDate p1 s
    t2 = subDate p2 s
    d1 = tn - t1
    d2 = t2 - tn
    w1 = intToDecimal d2 / intToDecimal (d1 + d2)
    w2 = 1.0 - w1

  -- In the ISDA paper, the following expression is used for linear interpolation:
  --Some (Observe (fr1.floatingRateIndex) + (Observe (fr2.floatingRateIndex) - Observe (fr1.floatingRateIndex)) * Const (intToDecimal (tn - t1) / intToDecimal (t2 - t1)))

  -- This expression can be simplified to:
  Some $ Const w1 * Observe fr1.floatingRateIndex + Const w2 * Observe fr2.floatingRateIndex

-- | Get the floating stub rate to be used for a stub period.
--getStubRateFloatingFromFpml : (DA.Internal.Record.HasField "adjustedEndDate" r1 Date, DA.Internal.Record.HasField "adjustedStartDate" r1 Date, DA.Internal.Record.HasField "floatingRateIndex" r3 o, DA.Internal.Record.HasField "indexTenor" r3 (Optional Period)) => [r3] -> r1 -> HolidayCalendarData -> BusinessDayConventionEnum -> Optional (Observation t Decimal o)
getStubRateFloatingFromFpml : [StubFloatingRate] -> SchedulePeriod -> HolidayCalendarData -> BusinessDayConventionEnum -> Optional (Observation Date Decimal Observable)
getStubRateFloatingFromFpml floatingRates p cal convention = do
  case floatingRates of
    [rate] -> getSingleStubRateFromFpml rate
    [rate1, rate2] -> getInterpolatedStubRateFromFpml rate1 rate2 p cal convention
    other -> error "only one or two floating stub rates supported"

-- | Get the stub rate to be used for a stub period.
-- Currently, three main options from the FpML schema are supported:
-- 1. A fix stubRate.
-- 2. One or two floating rates for the stub.
-- 3. No specific stub rate defined -> use the same rate as is used for regular periods.
--getStubRateFromFpml : (DA.Internal.Record.HasField "adjustedEndDate" r1 Date, DA.Internal.Record.HasField "adjustedStartDate" r1 Date, DA.Internal.Record.HasField "finalStub" r2 (Optional r3), DA.Internal.Record.HasField "floatingRate" r3 (Optional [r4]), DA.Internal.Record.HasField "floatingRateIndex" r4 o, DA.Internal.Record.HasField "indexTenor" r4 (Optional Period), DA.Internal.Record.HasField "initialStub" r2 (Optional r3), DA.Internal.Record.HasField "stubRate" r3 (Optional Decimal)) => r2 -> Bool -> r1 -> HolidayCalendarData -> BusinessDayConventionEnum -> Optional (Observation t Decimal o)
getStubRateFromFpml : StubCalculationPeriodAmount -> Bool -> SchedulePeriod -> HolidayCalendarData -> BusinessDayConventionEnum -> Optional (Observation Date Decimal Observable)
getStubRateFromFpml sc initialStub p cal convention = do
  let
    s = if initialStub then fromSome sc.initialStub else fromSome sc.finalStub
    stubRate = s.stubRate
  case s.stubRate of
    Some stubRate -> if isSome s.floatingRate then error "both stubRate and floatingRate provided" else Some (Const (fromSome s.stubRate))
    None -> getStubRateFloatingFromFpml (fromSome s.floatingRate) p cal convention <$> s.floatingRate

-- | Calculate a floating rate amount for each payment date and create claims.
-- The floating rate is observed according to the FpML ResetDates component and used for the corresponding payment on the last day of that payment period.
-- This function is under construction and can probably be merged with createFloatingRatePaymentClaims above once all necessary FpML features have been implemented.
createFloatingRatePaymentClaimsFpml : [SchedulePeriod] -> PeriodicSchedule -> Bool -> Decimal -> Bool -> DayCountConventionEnum -> Deliverable -> Observable -> HolidayCalendarData -> SwapStream -> Update TaggedClaim
createFloatingRatePaymentClaimsFpml schedule periodicSchedule useAdjustedDatesForDcf floatingRateSpread issuerPays dayCountConvention cashInstrumentCid referenceRateId fixingCalendars s = do
  let
    resetDates = fromSome s.resetDates
    bdc = s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessDayConvention
  assertMsg "Only daily fixing date period supported" (resetDates.fixingDates.period == D)
  assertMsg "Only Business day type supported" (resetDates.fixingDates.dayType == Business)
  assertMsg "No adjustement (besides business day type) supported" (resetDates.fixingDates.businessDayConvention == NoAdjustment)
  let
    fixingDates = map (\p -> addBusinessDays fixingCalendars resetDates.fixingDates.periodMultiplier p.adjustedStartDate) schedule
    createClaim (p,f) =
      when (TimeGte f) $ scale (rate * (Const (calcPeriodDcf dayCountConvention p useAdjustedDatesForDcf periodicSchedule.terminationDate periodicSchedule.frequency))) $
      when (TimeGte p.adjustedEndDate) $ one cashInstrumentCid
        where
          regularRate = Observe referenceRateId + Const floatingRateSpread
          stubType = p.stubType
          rate = case stubType of
            None -> regularRate
            Some stubType -> if isNone s.stubCalculationPeriodAmount then regularRate else fromOptional regularRate (getStubRateFromFpml (fromSome s.stubCalculationPeriodAmount) (stubType == LongInitial || stubType == ShortInitial) p fixingCalendars bdc)
    floatingClaimAmounts = mconcat $ map createClaim $ zip schedule fixingDates
    floatingClaims = if issuerPays then floatingClaimAmounts else give floatingClaimAmounts
  pure $ prepareAndTagClaims [floatingClaims] "Floating rate payment"

-- | Create claims from swapStream that describes a floating coupon stream.
calculateClaimsFromFloatingSwapStream : SwapStream -> PeriodicSchedule -> [SchedulePeriod] -> Bool -> Bool -> Deliverable -> Party -> Party -> Update TaggedClaim
calculateClaimsFromFloatingSwapStream s periodicSchedule streamSchedule useAdjustedDatesForDcf issuerPaysLeg currency issuer calendarDataAgency = do
  let
    f = fromSome s.calculationPeriodAmount.calculation.floatingRateCalculation
    resetDates = fromSome s.resetDates
  fixingCalendars <- getHolidayCalendars resetDates.fixingDates.businessCenters issuer calendarDataAgency
  createFloatingRatePaymentClaimsFpml streamSchedule periodicSchedule useAdjustedDatesForDcf f.spreadSchedule.initialValue issuerPaysLeg s.calculationPeriodAmount.calculation.dayCountFraction currency f.floatingRateIndex (merge fixingCalendars) s
