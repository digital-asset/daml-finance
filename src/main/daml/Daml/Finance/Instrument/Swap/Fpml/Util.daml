-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Swap.Fpml.Util where

import ContingentClaims.Core.Claim (Claim(..), Inequality(..), give, one, scale, when)
import ContingentClaims.Core.Observation (Observation(..))
import DA.Date
import DA.Foldable (foldMap)
import DA.List (head, last)
import DA.Optional (fromOptional, fromSome, isNone, isSome)
import Daml.Finance.Instrument.Generic.Util (createFixRatePaymentClaims, getHolidayCalendars, prepareAndTagClaims)
import Daml.Finance.Interface.Claims.Types (Deliverable, Observable, TaggedClaim(..))
import Daml.Finance.Interface.Types.Common (Id(..))
import Daml.Finance.Interface.Types.Date.Calendar
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention
import Daml.Finance.Interface.Types.Date.Schedule (Frequency(..), PeriodicSchedule(..), SchedulePeriod, StubPeriodTypeEnum(..))
import Daml.Finance.Interface.Types.Fpml
import Daml.Finance.Util.Date.Calendar (addBusinessDays, adjustDate, merge)
import Daml.Finance.Util.Date.DayCount (calcPeriodDcf)
import Daml.Finance.Util.Date.RollConvention (addPeriod)
import Prelude hiding (key)

type O = Observation Date Decimal Observable

-- | Create a schedule for calculation periods.
createCalculationPeriodicSchedule : CalculationPeriodDates -> PeriodicSchedule
createCalculationPeriodicSchedule c = do
  let
    periodicSchedule = PeriodicSchedule with
      businessDayAdjustment =
        BusinessDayAdjustment with
          calendarIds = c.calculationPeriodDatesAdjustments.businessCenters
          convention = c.calculationPeriodDatesAdjustments.businessDayConvention
      effectiveDateBusinessDayAdjustment = None
      terminationDateBusinessDayAdjustment = None
      frequency =
        Frequency with
          rollConvention = c.calculationPeriodFrequency.rollConvention
          period = c.calculationPeriodFrequency.period
          periodMultiplier = c.calculationPeriodFrequency.periodMultiplier
      effectiveDate = c.effectiveDate.unadjustedDate
      firstRegularPeriodStartDate = c.firstRegularPeriodStartDate
      lastRegularPeriodEndDate = c.lastRegularPeriodEndDate
      stubPeriodType = None
      terminationDate = c.terminationDate.unadjustedDate
  periodicSchedule

-- | Create a schedule for payment periods.
createPaymentPeriodicSchedule : SwapStream -> PeriodicSchedule
createPaymentPeriodicSchedule s = do
  let
    periodicSchedule = PeriodicSchedule with
      businessDayAdjustment =
        BusinessDayAdjustment with
          calendarIds = fromSome s.paymentDates.paymentDatesAdjustments.businessCenters
          convention = s.paymentDates.paymentDatesAdjustments.businessDayConvention
      effectiveDateBusinessDayAdjustment = None
      terminationDateBusinessDayAdjustment = None
      frequency =
        Frequency with
          rollConvention = s.calculationPeriodDates.calculationPeriodFrequency.rollConvention
          period = s.paymentDates.paymentFrequency.period
          periodMultiplier = s.paymentDates.paymentFrequency.periodMultiplier
      effectiveDate = s.calculationPeriodDates.effectiveDate.unadjustedDate
      firstRegularPeriodStartDate = s.paymentDates.firstPaymentDate
      lastRegularPeriodEndDate = s.paymentDates.lastRegularPaymentDate
      stubPeriodType = None
      terminationDate = s.calculationPeriodDates.terminationDate.unadjustedDate
  periodicSchedule

-- | Retrieve holiday calendars and adjust a date as specified in a BusinessDayAdjustments FpML element
getCalendarsAndAdjust : Date -> BusinessDayAdjustments -> Party -> Party -> Update Date
getCalendarsAndAdjust unadjustedDate businessDayAdjustments issuer calendarDataAgency = do
  let holidayCalendarIds = fromSome businessDayAdjustments.businessCenters
  cals <- getHolidayCalendars holidayCalendarIds issuer calendarDataAgency
  pure $ adjustDate (merge cals) businessDayAdjustments.businessDayConvention unadjustedDate

-- | Adjust a date as specified in a BusinessDayAdjustments FpML element (or not at all if NoAdjustment)
adjustDateAccordingToBusinessDayAdjustments : Date -> BusinessDayAdjustments -> Party -> Party -> Update Date
adjustDateAccordingToBusinessDayAdjustments unadjustedDate businessDayAdjustments issuer calendarDataAgency = do
  case businessDayAdjustments.businessDayConvention of
    NoAdjustment -> pure $ unadjustedDate
    _ -> getCalendarsAndAdjust unadjustedDate businessDayAdjustments issuer calendarDataAgency

-- TODO: remove this when merged with FpML functions below
createFixRateAmortizingNotionalPaymentClaimsList : SwapStream -> [SchedulePeriod] -> PeriodicSchedule -> Bool -> Decimal -> Bool -> DayCountConventionEnum -> Decimal -> Deliverable -> [Claim Date Decimal Deliverable Observable]
createFixRateAmortizingNotionalPaymentClaimsList s calculationSchedule periodicSchedule useAdjustedDatesForDcf couponRate issuerPays dayCountConvention notional cashInstrumentCid = do
  let
    c = s.calculationPeriodAmount.calculation
    n = fromSome c.notionalSchedule
    notionalSteps = n.notionalStepSchedule.step
  debug notionalSteps
  debug calculationSchedule
  let
    --assertMsg "Number of notional steps do not match the number of calculationSchedule periods" $ length steps == length calculationSchedule
    a = if length notionalSteps == length calculationSchedule then
      if any (\(n, p) -> n.stepDate /= p.unadjustedStartDate) $ zip notionalSteps calculationSchedule then error("notional step schedule does not match calculationSchedule")
      else
        --error "return no error, void"
        1
    else
      error("Number of notional steps do not match the number of calculationSchedule periods")
  let
    couponDatesAdjusted = map (.adjustedEndDate) calculationSchedule
    couponAmounts = map (\p -> couponRate * (calcPeriodDcf dayCountConvention p useAdjustedDatesForDcf periodicSchedule.terminationDate periodicSchedule.frequency)) calculationSchedule
    couponClaimAmounts = mconcat $ zipWith3 (\d a n -> when (TimeGte d) $ scale (Const a) $ scale (Const n.stepValue) $ one cashInstrumentCid) couponDatesAdjusted couponAmounts notionalSteps
    couponClaims = if issuerPays then couponClaimAmounts else give couponClaimAmounts
  debug couponDatesAdjusted
  debug couponAmounts
  pure couponClaims

-- TODO: remove this when merged with FpML functions below
createFixRateAmortizingNotionalPaymentClaims : SwapStream -> [SchedulePeriod] -> PeriodicSchedule -> Bool -> Decimal -> Bool -> DayCountConventionEnum -> Decimal -> Deliverable -> TaggedClaim
createFixRateAmortizingNotionalPaymentClaims s schedule calculationSchedule useAdjustedDatesForDcf couponRate issuerPays dayCountConvention notional cashInstrumentCid = do
  let couponClaims = createFixRateAmortizingNotionalPaymentClaimsList s schedule calculationSchedule useAdjustedDatesForDcf couponRate issuerPays dayCountConvention notional cashInstrumentCid
  prepareAndTagClaims couponClaims "Fix rate payment"

-- | Create claims from swapStream that describes a fix coupon stream.
calculateClaimsFromFixSwapStream : SwapStream -> PeriodicSchedule -> [SchedulePeriod] -> [SchedulePeriod] -> Bool -> Bool -> Deliverable -> Update TaggedClaim
calculateClaimsFromFixSwapStream s periodicSchedule calculationSchedule paymentSchedule useAdjustedDatesForDcf issuerPaysLeg currency = do
  let
    c = s.calculationPeriodAmount.calculation
    n = fromSome c.notionalSchedule
    notional = if Id n.notionalStepSchedule.currency == currency.id then n.notionalStepSchedule.initialValue else error "swapStream currency does not match swap currency"
  assertMsg "The payment schedule must match the calculation schedule" $ paymentSchedule == calculationSchedule
  assertMsg "Non-standard stub rates not supported for the fixed rate leg" $ isNone s.stubCalculationPeriodAmount
  let f = fromSome s.calculationPeriodAmount.calculation.fixedRateSchedule
  case null n.notionalStepSchedule.step of
    True -> pure $ createFixRatePaymentClaims calculationSchedule periodicSchedule useAdjustedDatesForDcf f.initialValue issuerPaysLeg s.calculationPeriodAmount.calculation.dayCountFraction notional currency
    False -> pure $ createFixRateAmortizingNotionalPaymentClaims s calculationSchedule periodicSchedule useAdjustedDatesForDcf f.initialValue issuerPaysLeg s.calculationPeriodAmount.calculation.dayCountFraction notional currency
      where a=1

-- | Define observable part of claim when one specific floating rate is provided for a stub period.
getSingleStubRate : StubFloatingRate -> Optional O
getSingleStubRate floatingRate = do
  Some (Observe floatingRate.floatingRateIndex)

-- | Linearly interpolates two rates within a period, as specified in https://www.isda.org/a/aWkgE/Linear-interpolation-04022022.pdf
getInterpolatedStubRate : StubFloatingRate -> StubFloatingRate -> SchedulePeriod -> HolidayCalendarData -> BusinessDayConventionEnum -> Optional O
getInterpolatedStubRate fr1 fr2 p cal convention = do
  let
    tenor1 = fromSome fr1.indexTenor
    tenor2 = fromSome fr2.indexTenor
    s = p.adjustedStartDate
    p1 = adjustDate cal convention (addPeriod s tenor1)
    p2 = adjustDate cal convention (addPeriod s tenor2)
    tn = subDate p.adjustedEndDate s
    t1 = subDate p1 s
    t2 = subDate p2 s
    d1 = tn - t1
    d2 = t2 - tn
    w1 = intToDecimal d2 / intToDecimal (d1 + d2)
    w2 = 1.0 - w1

  -- In the ISDA paper, the following expression is used for linear interpolation:
  --Some (Observe (fr1.floatingRateIndex) + (Observe (fr2.floatingRateIndex) - Observe (fr1.floatingRateIndex)) * Const (intToDecimal (tn - t1) / intToDecimal (t2 - t1)))

  -- This expression can be simplified to:
  Some $ Const w1 * Observe fr1.floatingRateIndex + Const w2 * Observe fr2.floatingRateIndex

-- | Get the floating stub rate to be used for a stub period.
getStubRateFloating : [StubFloatingRate] -> SchedulePeriod -> HolidayCalendarData -> BusinessDayConventionEnum -> Optional O
getStubRateFloating floatingRates p cal convention = do
  case floatingRates of
    [rate] -> getSingleStubRate rate
    [rate1, rate2] -> getInterpolatedStubRate rate1 rate2 p cal convention
    other -> error "only one or two floating stub rates supported"

-- | Get the stub rate to be used for a stub period.
-- Currently, three main options from the FpML schema are supported:
-- 1. A fix stubRate.
-- 2. One or two floating rates for the stub.
-- 3. No specific stub rate defined -> use the same rate as is used for regular periods.
getStubRate : StubCalculationPeriodAmount -> Bool -> SchedulePeriod -> HolidayCalendarData -> BusinessDayConventionEnum -> Optional O
getStubRate sc initialStub p cal convention = do
  let
    s = if initialStub then fromSome sc.initialStub else fromSome sc.finalStub
  case s.stubRate of
    Some stubRate -> if isSome s.floatingRate then error "both stubRate and floatingRate provided" else Const <$> s.stubRate
    None -> if isSome s.floatingRate then getStubRateFloating (fromSome s.floatingRate) p cal convention else None

-- | Align the payment schedule with the calculation schedule.
alignPaymentSchedule : [SchedulePeriod] -> [SchedulePeriod] -> Update [SchedulePeriod]
alignPaymentSchedule calculationSchedule paymentSchedule = do
  assertMsg "The payment schedule has fewer periods than the calculation schedule" $ length paymentSchedule <= length calculationSchedule
  let
    calculationScheduleWithoutStubs = filter (isNone . (.stubType)) calculationSchedule
    paymentScheduleWithoutStubs = filter (isNone . (.stubType)) paymentSchedule
  assertMsg "The payment schedule periods must be an even multiple of the calculation schedule periods" $ length calculationScheduleWithoutStubs % length paymentScheduleWithoutStubs == 0
  let
    nCalculationPeriodsPerPaymentPeriod = length calculationScheduleWithoutStubs / length paymentScheduleWithoutStubs
    paymentScheduleAlignedWithoutStubs = foldMap (replicate nCalculationPeriodsPerPaymentPeriod) paymentScheduleWithoutStubs
    firstPeriod = head paymentSchedule
    lastPeriod = last paymentSchedule
    initialStubIfItExists = case firstPeriod.stubType of
      Some ShortInitial -> [firstPeriod]
      Some LongInitial -> [firstPeriod]
      _ -> []
    finalStubIfItExists = case lastPeriod.stubType of
      Some ShortFinal -> [lastPeriod]
      Some LongFinal -> [lastPeriod]
      _ -> []
    paymentScheduleAligned = initialStubIfItExists ++ paymentScheduleAlignedWithoutStubs ++ finalStubIfItExists
  assertMsg "The payment schedule must match the calculation schedule" $ length paymentScheduleAligned == length calculationSchedule
  pure paymentScheduleAligned

-- | Calculate a floating rate amount for each payment date and create claims.
-- The floating rate is observed according to the FpML ResetDates component and used for the corresponding payment on the last day of that payment period.
--createFloatingRatePaymentClaims : [SchedulePeriod] -> [SchedulePeriod] -> PeriodicSchedule -> Bool -> Decimal -> Bool -> DayCountConventionEnum -> Deliverable -> Observable -> HolidayCalendarData -> HolidayCalendarData -> SwapStream -> Update TaggedClaim
createFloatingRateAmortizingNotionalPaymentClaims : [SchedulePeriod] -> [SchedulePeriod] -> PeriodicSchedule -> Bool -> Decimal -> Bool -> DayCountConventionEnum -> Deliverable -> Observable -> HolidayCalendarData -> [Date] -> SwapStream -> Update TaggedClaim
createFloatingRateAmortizingNotionalPaymentClaims calculationSchedule paymentSchedule periodicSchedule useAdjustedDatesForDcf floatingRateSpread issuerPays dayCountConvention cashInstrumentCid referenceRateId rateFixingCalendars rateFixingDates s = do
  let
    c = s.calculationPeriodAmount.calculation
    n = fromSome c.notionalSchedule
    notionalSteps = n.notionalStepSchedule.step
  debug notionalSteps
  debug calculationSchedule
  let
    --assertMsg "Number of notional steps do not match the number of calculationSchedule periods" $ length steps == length calculationSchedule
    a = if length notionalSteps == length calculationSchedule then
      if any (\(n, p) -> n.stepDate /= p.unadjustedStartDate) $ zip notionalSteps calculationSchedule then error("notional step schedule does not match calculationSchedule")
      else
        --error "return no error, void"
        1
    else
      if length notionalSteps > 0 then
        error("Number of notional steps do not match the number of calculationSchedule periods")
      else
        1
  let
    c = s.calculationPeriodAmount.calculation
    n = fromSome c.notionalSchedule
    notional = if Id n.notionalStepSchedule.currency == cashInstrumentCid.id then n.notionalStepSchedule.initialValue else error "swapStream currency does not match swap currency"
    resetDates = fromSome s.resetDates
    bdc = s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessDayConvention
  paymentScheduleAligned <- alignPaymentSchedule calculationSchedule paymentSchedule
  assertMsg "Only daily fixing date period supported" $ resetDates.fixingDates.period == D
  assertMsg "Only Business day type supported" $ resetDates.fixingDates.dayType == Business
  assertMsg "Only fixing dates relative to calculation start dates supported" $ resetDates.resetRelativeTo == CalculationPeriodStartDate
  assertMsg "No adjustement (besides business day type) supported" $ resetDates.fixingDates.businessDayConvention == NoAdjustment
  let
    createClaim (c, n) p f =
      --when (TimeGte f) $ scale (Const notional) $ scale (rate * (Const (calcPeriodDcf dayCountConvention c useAdjustedDatesForDcf periodicSchedule.terminationDate periodicSchedule.frequency))) $
      when (TimeGte f) $ scale (Const n.stepValue) $ scale (rate * (Const (calcPeriodDcf dayCountConvention c useAdjustedDatesForDcf periodicSchedule.terminationDate periodicSchedule.frequency))) $
      when (TimeGte p.adjustedEndDate) $ one cashInstrumentCid
        where
          regularRate = Observe referenceRateId + Const floatingRateSpread
          rate = case c.stubType of
            None -> regularRate
            Some stubType -> if isNone s.stubCalculationPeriodAmount then regularRate else fromOptional regularRate (getStubRate (fromSome s.stubCalculationPeriodAmount) (stubType == LongInitial || stubType == ShortInitial) p rateFixingCalendars bdc)
    floatingClaimAmounts = mconcat $ zipWith3 createClaim (zip calculationSchedule notionalSteps) paymentScheduleAligned rateFixingDates
    floatingClaims = if issuerPays then floatingClaimAmounts else give floatingClaimAmounts
  pure $ prepareAndTagClaims [floatingClaims] "Floating rate payment"

-- | Calculate a floating rate amount for each payment date and create claims.
-- The floating rate is observed according to the FpML ResetDates component and used for the corresponding payment on the last day of that payment period.
--createFloatingRatePaymentClaims : [SchedulePeriod] -> [SchedulePeriod] -> PeriodicSchedule -> Bool -> Decimal -> Bool -> DayCountConventionEnum -> Deliverable -> Observable -> HolidayCalendarData -> HolidayCalendarData -> SwapStream -> Update TaggedClaim
createFloatingRatePaymentClaims : [SchedulePeriod] -> [SchedulePeriod] -> PeriodicSchedule -> Bool -> Decimal -> Bool -> DayCountConventionEnum -> Deliverable -> Observable -> HolidayCalendarData -> [Date] -> SwapStream -> Update TaggedClaim
createFloatingRatePaymentClaims calculationSchedule paymentSchedule periodicSchedule useAdjustedDatesForDcf floatingRateSpread issuerPays dayCountConvention cashInstrumentCid referenceRateId rateFixingCalendars rateFixingDates s = do
  let
    c = s.calculationPeriodAmount.calculation
    n = fromSome c.notionalSchedule
    notional = if Id n.notionalStepSchedule.currency == cashInstrumentCid.id then n.notionalStepSchedule.initialValue else error "swapStream currency does not match swap currency"
    resetDates = fromSome s.resetDates
    bdc = s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessDayConvention
  paymentScheduleAligned <- alignPaymentSchedule calculationSchedule paymentSchedule
  assertMsg "Only daily fixing date period supported" $ resetDates.fixingDates.period == D
  assertMsg "Only Business day type supported" $ resetDates.fixingDates.dayType == Business
  assertMsg "Only fixing dates relative to calculation start dates supported" $ resetDates.resetRelativeTo == CalculationPeriodStartDate
  assertMsg "No adjustement (besides business day type) supported" $ resetDates.fixingDates.businessDayConvention == NoAdjustment
  let
    createClaim c p f =
      when (TimeGte f) $ scale (Const notional) $ scale (rate * (Const (calcPeriodDcf dayCountConvention c useAdjustedDatesForDcf periodicSchedule.terminationDate periodicSchedule.frequency))) $
      when (TimeGte p.adjustedEndDate) $ one cashInstrumentCid
        where
          regularRate = Observe referenceRateId + Const floatingRateSpread
          rate = case c.stubType of
            None -> regularRate
            Some stubType -> if isNone s.stubCalculationPeriodAmount then regularRate else fromOptional regularRate (getStubRate (fromSome s.stubCalculationPeriodAmount) (stubType == LongInitial || stubType == ShortInitial) p rateFixingCalendars bdc)
    floatingClaimAmounts = mconcat $ zipWith3 createClaim calculationSchedule paymentScheduleAligned rateFixingDates
    floatingClaims = if issuerPays then floatingClaimAmounts else give floatingClaimAmounts
  pure $ prepareAndTagClaims [floatingClaims] "Floating rate payment"

-- | Calculate a floating rate amount for each payment date and create claims.
-- The floating rate is observed according to the FpML ResetDates component and used for the corresponding payment on the last day of that payment period.
--createFloatingRatePaymentClaims : [SchedulePeriod] -> [SchedulePeriod] -> PeriodicSchedule -> Bool -> Decimal -> Bool -> DayCountConventionEnum -> Deliverable -> Observable -> HolidayCalendarData -> HolidayCalendarData -> SwapStream -> Update TaggedClaim
--createFloatingRatePaymentClaimsFxNotional : [SchedulePeriod] -> [SchedulePeriod] -> PeriodicSchedule -> NotionalSchedule -> Bool -> Decimal -> Bool -> DayCountConventionEnum -> Deliverable -> Observable -> HolidayCalendarData -> [Date] -> SwapStream -> Party -> Party -> Update TaggedClaim
--createFloatingRatePaymentClaimsFxNotional calculationSchedule paymentSchedule periodicSchedule notionalSchedule useAdjustedDatesForDcf floatingRateSpread issuerPays dayCountConvention cashInstrumentCid referenceRateId rateFixingCalendars rateFixingDates s issuer calendarDataAgency = do
createFloatingRatePaymentClaimsFxNotional : [SchedulePeriod] -> [SchedulePeriod] -> PeriodicSchedule -> Bool -> Decimal -> Bool -> DayCountConventionEnum -> Deliverable -> Observable -> HolidayCalendarData -> [Date] -> SwapStream -> Party -> Party -> Update TaggedClaim
createFloatingRatePaymentClaimsFxNotional calculationSchedule paymentSchedule periodicSchedule useAdjustedDatesForDcf floatingRateSpread issuerPays dayCountConvention cashInstrumentCid referenceRateId rateFixingCalendars rateFixingDates s issuer calendarDataAgency = do
  let
    fx = fromSome s.calculationPeriodAmount.calculation.fxLinkedNotionalSchedule
  fxFixingCalendars <- getHolidayCalendars fx.varyingNotionalFixingDates.businessCenters issuer calendarDataAgency
  let
    c = s.calculationPeriodAmount.calculation
    n = fromSome c.notionalSchedule
    --n = notionalSchedule -- use the notionalSchedule provided (in case the current leg points at another leg)
    notional = if Id n.notionalStepSchedule.currency == cashInstrumentCid.id then n.notionalStepSchedule.initialValue else error "swapStream currency does not match swap currency"
    resetDates = fromSome s.resetDates
    bdc = s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessDayConvention
    fxFixingDates = map (\p -> addBusinessDays (merge fxFixingCalendars) fx.varyingNotionalFixingDates.periodMultiplier p.adjustedStartDate) calculationSchedule
  assertMsg "fxFixingDates must match rateFixingDates" $ fxFixingDates == rateFixingDates
  paymentScheduleAligned <- alignPaymentSchedule calculationSchedule paymentSchedule
  assertMsg "Only daily fixing date period supported" $ resetDates.fixingDates.period == D
  assertMsg "Only Business day type supported" $ resetDates.fixingDates.dayType == Business
  assertMsg "Only fixing dates relative to calculation start dates supported" $ resetDates.resetRelativeTo == CalculationPeriodStartDate
  assertMsg "No adjustement (besides business day type) supported" $ resetDates.fixingDates.businessDayConvention == NoAdjustment
  let
    createClaim c p f =
      when (TimeGte f) $ scale (notionalConst * fxRateObs) $ scale (rate * (Const (calcPeriodDcf dayCountConvention c useAdjustedDatesForDcf periodicSchedule.terminationDate periodicSchedule.frequency))) $
      when (TimeGte p.adjustedEndDate) $ one cashInstrumentCid
        where
          origNotional = 5000000.0
          notionalConst = Const origNotional
          fxRateObs = Observe fx.fxSpotRateSource.primaryRateSource.rateSourcePage
          regularRateObs = Observe referenceRateId + Const floatingRateSpread
          rate = case c.stubType of
            None -> regularRateObs
            Some stubType -> if isNone s.stubCalculationPeriodAmount then regularRateObs else fromOptional regularRateObs (getStubRate (fromSome s.stubCalculationPeriodAmount) (stubType == LongInitial || stubType == ShortInitial) p rateFixingCalendars bdc)
    floatingClaimAmounts = mconcat $ zipWith3 createClaim calculationSchedule paymentScheduleAligned rateFixingDates
    floatingClaims = if issuerPays then floatingClaimAmounts else give floatingClaimAmounts
  pure $ prepareAndTagClaims [floatingClaims] "Floating rate payment"

-- | Create claims from swapStream that describes a floating coupon stream.
calculateClaimsFromFloatingSwapStream : SwapStream -> PeriodicSchedule -> [SchedulePeriod] -> [SchedulePeriod] -> Bool -> Bool -> Deliverable -> Party -> Party -> Update TaggedClaim
calculateClaimsFromFloatingSwapStream s periodicSchedule calculationSchedule paymentSchedule useAdjustedDatesForDcf issuerPaysLeg currency issuer calendarDataAgency = do
  let
    c = s.calculationPeriodAmount.calculation
    n = fromSome c.notionalSchedule
    notional = if Id n.notionalStepSchedule.currency == currency.id then n.notionalStepSchedule.initialValue else error "swapStream currency does not match swap currency"
  let
    fxl = s.calculationPeriodAmount.calculation.fxLinkedNotionalSchedule
    f = fromSome s.calculationPeriodAmount.calculation.floatingRateCalculation
    resetDates = fromSome s.resetDates
    r = fromSome s.resetDates
  assertMsg "stub must refer to the calculationPeriodDates of the current swapStream" $ isNone s.stubCalculationPeriodAmount || getField @"calculationPeriodDatesReference" (fromSome s.stubCalculationPeriodAmount) == s.calculationPeriodDates.id
  assertMsg "resetDate must refer to the calculationPeriodDates of the current swapStream" $ r.calculationPeriodDatesReference == s.calculationPeriodDates.id
  assertMsg "resetDate period must match calculation period" $ r.resetFrequency.period == s.calculationPeriodDates.calculationPeriodFrequency.period
  assertMsg "resetDate periodMultiplier must match calculation periodMultiplier" $ r.resetFrequency.periodMultiplier == s.calculationPeriodDates.calculationPeriodFrequency.periodMultiplier
  assertMsg "resetDate businessDayConvention must match calculation businessDayConvention" $ r.resetDatesAdjustments.businessDayConvention == s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessDayConvention
  assertMsg "resetDate businessCenters must match calculation businessCenters" $ r.resetDatesAdjustments.businessCenters == s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessCenters
  rateFixingCalendars <- getHolidayCalendars r.fixingDates.businessCenters issuer calendarDataAgency
  let
    rateFixingDates = map (\p -> addBusinessDays (merge rateFixingCalendars) resetDates.fixingDates.periodMultiplier p.adjustedStartDate) calculationSchedule
  case fxl of
    None -> case null n.notionalStepSchedule.step of
      True -> createFloatingRatePaymentClaims calculationSchedule paymentSchedule periodicSchedule useAdjustedDatesForDcf f.spreadSchedule.initialValue issuerPaysLeg s.calculationPeriodAmount.calculation.dayCountFraction currency f.floatingRateIndex (merge rateFixingCalendars) rateFixingDates s
      False -> createFloatingRateAmortizingNotionalPaymentClaims calculationSchedule paymentSchedule periodicSchedule useAdjustedDatesForDcf f.spreadSchedule.initialValue issuerPaysLeg s.calculationPeriodAmount.calculation.dayCountFraction currency f.floatingRateIndex (merge rateFixingCalendars) rateFixingDates s
        where a=1
    Some fxl -> createFloatingRatePaymentClaimsFxNotional calculationSchedule paymentSchedule periodicSchedule useAdjustedDatesForDcf f.spreadSchedule.initialValue issuerPaysLeg s.calculationPeriodAmount.calculation.dayCountFraction currency f.floatingRateIndex (merge rateFixingCalendars) rateFixingDates s issuer calendarDataAgency
