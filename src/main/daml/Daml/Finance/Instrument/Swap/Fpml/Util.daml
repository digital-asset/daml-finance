-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Swap.Fpml.Util where

import ContingentClaims.Core.Claim (Inequality(..), give, one, scale, when)
import ContingentClaims.Core.Observation (Observation(..))
import DA.Date
import DA.Foldable (foldMap)
import DA.List (head, last)
import DA.Optional (fromOptional, fromSome, isNone, isSome)
import Daml.Finance.Instrument.Generic.Util (getHolidayCalendars, prepareAndTagClaims)
import Daml.Finance.Interface.Claims.Types (Deliverable, Observable, TaggedClaim(..))
import Daml.Finance.Interface.Instrument.Swap.Fpml.FpmlTypes
import Daml.Finance.Interface.Types.Common (Id(..))
import Daml.Finance.Interface.Types.Date.Calendar
import Daml.Finance.Interface.Types.Date.RollConvention
import Daml.Finance.Interface.Types.Date.Schedule (Frequency(..), PeriodicSchedule(..), SchedulePeriod, StubPeriodTypeEnum(..))
import Daml.Finance.Util.Date.Calendar (addBusinessDays, adjustDate, merge)
import Daml.Finance.Util.Date.DayCount (calcPeriodDcf)
import Daml.Finance.Util.Date.RollConvention (addPeriod)
import Prelude hiding (key)

type O = Observation Date Decimal Observable

-- | Create a schedule for calculation periods.
createCalculationPeriodicSchedule : CalculationPeriodDates -> PeriodicSchedule
createCalculationPeriodicSchedule c = do
  let
    periodicSchedule = PeriodicSchedule with
      businessDayAdjustment =
        BusinessDayAdjustment with
          calendarIds = c.calculationPeriodDatesAdjustments.businessCenters
          convention = c.calculationPeriodDatesAdjustments.businessDayConvention
      effectiveDateBusinessDayAdjustment = None
      terminationDateBusinessDayAdjustment = None
      frequency =
        Frequency with
          rollConvention = c.calculationPeriodFrequency.rollConvention
          period = c.calculationPeriodFrequency.period
          periodMultiplier = c.calculationPeriodFrequency.periodMultiplier
      effectiveDate = c.effectiveDate.unadjustedDate
      firstRegularPeriodStartDate = c.firstRegularPeriodStartDate
      lastRegularPeriodEndDate = c.lastRegularPeriodEndDate
      stubPeriodType = None
      terminationDate = c.terminationDate.unadjustedDate
  periodicSchedule

-- | Create a schedule for payment periods.
createPaymentPeriodicSchedule : SwapStream -> PeriodicSchedule
createPaymentPeriodicSchedule s = do
  let
    periodicSchedule = PeriodicSchedule with
      businessDayAdjustment =
        BusinessDayAdjustment with
          calendarIds = s.paymentDates.paymentDatesAdjustments.businessCenters
          convention = s.paymentDates.paymentDatesAdjustments.businessDayConvention
      effectiveDateBusinessDayAdjustment = None
      terminationDateBusinessDayAdjustment = None
      frequency =
        Frequency with
          rollConvention = s.calculationPeriodDates.calculationPeriodFrequency.rollConvention
          period = s.paymentDates.paymentFrequency.period
          periodMultiplier = s.paymentDates.paymentFrequency.periodMultiplier
      effectiveDate = s.calculationPeriodDates.effectiveDate.unadjustedDate
      firstRegularPeriodStartDate = s.paymentDates.firstPaymentDate
      lastRegularPeriodEndDate = s.paymentDates.lastRegularPaymentDate
      stubPeriodType = None
      terminationDate = s.calculationPeriodDates.terminationDate.unadjustedDate
  periodicSchedule

-- | Retrieve holiday calendars and adjust a date as specified in a BusinessDayAdjustments FpML element
getCalendarsAndAdjust : Date -> BusinessDayAdjustments -> Party -> Party -> Update Date
getCalendarsAndAdjust unadjustedDate businessDayAdjustments issuer calendarDataAgency = do
  cals <- getHolidayCalendars businessDayAdjustments.businessCenters issuer calendarDataAgency
  pure $ adjustDate (merge cals) businessDayAdjustments.businessDayConvention unadjustedDate

-- | Adjust a date as specified in a BusinessDayAdjustments FpML element (or not at all if NoAdjustment)
adjustDateAccordingToBusinessDayAdjustments : Date -> BusinessDayAdjustments -> Party -> Party -> Update Date
adjustDateAccordingToBusinessDayAdjustments unadjustedDate businessDayAdjustments issuer calendarDataAgency = do
  case businessDayAdjustments.businessDayConvention of
    NoAdjustment -> pure $ unadjustedDate
    _ -> getCalendarsAndAdjust unadjustedDate businessDayAdjustments issuer calendarDataAgency

-- | Define observable part of claim when one specific floating rate is provided for a stub period.
getSingleStubRate : StubFloatingRate -> Optional O
getSingleStubRate floatingRate = do
  Some (Observe floatingRate.floatingRateIndex)

-- | Linearly interpolates two rates within a period, as specified in https://www.isda.org/a/aWkgE/Linear-interpolation-04022022.pdf
getInterpolatedStubRate : StubFloatingRate -> StubFloatingRate -> SchedulePeriod -> HolidayCalendarData -> BusinessDayConventionEnum -> Optional O
getInterpolatedStubRate fr1 fr2 p cal convention = do
  let
    tenor1 = fromSome fr1.indexTenor
    tenor2 = fromSome fr2.indexTenor
    s = p.adjustedStartDate
    p1 = adjustDate cal convention (addPeriod s tenor1)
    p2 = adjustDate cal convention (addPeriod s tenor2)
    tn = subDate p.adjustedEndDate s
    t1 = subDate p1 s
    t2 = subDate p2 s
    d1 = tn - t1
    d2 = t2 - tn
    w1 = intToDecimal d2 / intToDecimal (d1 + d2)
    w2 = 1.0 - w1

  -- In the ISDA paper, the following expression is used for linear interpolation:
  --Some (Observe (fr1.floatingRateIndex) + (Observe (fr2.floatingRateIndex) - Observe (fr1.floatingRateIndex)) * Const (intToDecimal (tn - t1) / intToDecimal (t2 - t1)))

  -- This expression can be simplified to:
  Some $ Const w1 * Observe fr1.floatingRateIndex + Const w2 * Observe fr2.floatingRateIndex

-- | Get the floating stub rate to be used for a stub period.
getStubRateFloating : [StubFloatingRate] -> SchedulePeriod -> HolidayCalendarData -> BusinessDayConventionEnum -> Optional O
getStubRateFloating floatingRates p cal convention = do
  case floatingRates of
    [rate] -> getSingleStubRate rate
    [rate1, rate2] -> getInterpolatedStubRate rate1 rate2 p cal convention
    other -> error "only one or two floating stub rates supported"

-- | Get the stub rate to be used for a stub period.
-- Currently, three main options from the FpML schema are supported:
-- 1. A fix stubRate.
-- 2. One or two floating rates for the stub.
-- 3. No specific stub rate defined -> use the same rate as is used for regular periods.
getStubRate : StubCalculationPeriodAmount -> Bool -> SchedulePeriod -> HolidayCalendarData -> BusinessDayConventionEnum -> Bool-> Optional O
getStubRate sc initialStub p cal convention fixLeg = do
  let
    stubValue = if initialStub then fromSome sc.initialStub else fromSome sc.finalStub
  case stubValue of
    StubValue_StubRate stubRate -> Const <$> Some stubRate
    StubValue_FloatingRate stubFloatingRates -> if fixLeg then error "floating stub not supported for fix leg" else getStubRateFloating stubFloatingRates p cal convention

-- | Align the payment schedule with the calculation schedule.
alignPaymentSchedule : [SchedulePeriod] -> [SchedulePeriod] -> Update [SchedulePeriod]
alignPaymentSchedule calculationSchedule paymentSchedule = do
  assertMsg "The payment schedule has fewer periods than the calculation schedule" $ length paymentSchedule <= length calculationSchedule
  let
    calculationScheduleWithoutStubs = filter (isNone . (.stubType)) calculationSchedule
    paymentScheduleWithoutStubs = filter (isNone . (.stubType)) paymentSchedule
  assertMsg "The payment schedule periods must be an even multiple of the calculation schedule periods" $ null paymentScheduleWithoutStubs || length calculationScheduleWithoutStubs % length paymentScheduleWithoutStubs == 0
  let
    firstPeriod = head paymentSchedule
    lastPeriod = last paymentSchedule
    initialStubIfItExists = case firstPeriod.stubType of
      Some ShortInitial -> [firstPeriod]
      Some LongInitial -> [firstPeriod]
      _ -> []
    finalStubIfItExists = case lastPeriod.stubType of
      Some ShortFinal -> [lastPeriod]
      Some LongFinal -> [lastPeriod]
      _ -> []
    paymentScheduleAlignedWithoutStubs = case length paymentScheduleWithoutStubs of
      0 -> []
      _ -> foldMap (replicate nCalculationPeriodsPerPaymentPeriod) paymentScheduleWithoutStubs
        where nCalculationPeriodsPerPaymentPeriod = length calculationScheduleWithoutStubs / length paymentScheduleWithoutStubs
    paymentScheduleAligned = initialStubIfItExists ++ paymentScheduleAlignedWithoutStubs ++ finalStubIfItExists
  debug initialStubIfItExists
  assertMsg "The payment schedule must match the calculation schedule" $ length paymentScheduleAligned == length calculationSchedule
  pure paymentScheduleAligned

verifyFxScheduleAndGetId : [SchedulePeriod] -> SwapStream -> Party -> Party -> FxLinkedNotionalSchedule -> Update (Optional Text, Optional Decimal, Optional [Date])
verifyFxScheduleAndGetId calculationSchedule s issuer calendarDataAgency fx = do
  fxFixingCalendars <- getHolidayCalendars fx.varyingNotionalFixingDates.businessCenters issuer calendarDataAgency
  let
    fxFixingDates = map (\p -> addBusinessDays (merge fxFixingCalendars) fx.varyingNotionalFixingDates.periodMultiplier p.adjustedStartDate) calculationSchedule
  pure $ (Some fx.fxSpotRateSource.primaryRateSource.rateSourcePage, fx.initialValue, Some fxFixingDates)

getFxRateId : [SchedulePeriod] -> SwapStream -> Party -> Party -> Update (Optional Text, Optional Decimal, Optional [Date])
getFxRateId calculationSchedule s issuer calendarDataAgency = do
  case s.calculationPeriodAmount.calculation.notionalScheduleValue of
    NotionalSchedule_FxLinked fx -> verifyFxScheduleAndGetId calculationSchedule s issuer calendarDataAgency fx
    _ -> pure (None, None, None)

-- | Create claims from swapStream that describes a fixed or floating coupon stream.
calculateFixPaymentClaimsFromSwapStream : FixedRateSchedule -> SwapStream -> PeriodicSchedule -> [SchedulePeriod] -> [SchedulePeriod] -> Bool -> Bool -> Deliverable -> Party -> Party -> Optional Text -> Optional [Date] -> [(Decimal, Bool)] -> Update [TaggedClaim]
calculateFixPaymentClaimsFromSwapStream fixedRateSchedule s periodicSchedule calculationSchedule paymentScheduleAligned useAdjustedDatesForDcf issuerPaysLeg currency issuer calendarDataAgency fxRateId fxFixingDates notionals = do
  debug "fix"

  -- todo: which of these checks are required for fxDates as well? write function, apply for both.
{-
  assertMsg "resetDate must refer to the calculationPeriodDates of the current swapStream" $ r.calculationPeriodDatesReference == s.calculationPeriodDates.id
  assertMsg "resetDate period must match calculation period" $ r.resetFrequency.period == s.calculationPeriodDates.calculationPeriodFrequency.period
  assertMsg "resetDate periodMultiplier must match calculation periodMultiplier" $ r.resetFrequency.periodMultiplier == s.calculationPeriodDates.calculationPeriodFrequency.periodMultiplier
  assertMsg "resetDate businessDayConvention must match calculation businessDayConvention" $ r.resetDatesAdjustments.businessDayConvention == s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessDayConvention
  assertMsg "resetDate businessCenters must match calculation businessCenters" $ r.resetDatesAdjustments.businessCenters == s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessCenters
  assertMsg "Only daily fixing date period supported" $ r.fixingDates.period == D
  assertMsg "Only Business day type supported" $ r.fixingDates.dayType == Business
  assertMsg "Only fixing dates relative to calculation start dates supported" $ r.resetRelativeTo == CalculationPeriodStartDate
  assertMsg "No adjustement (besides business day type) supported" $ r.fixingDates.businessDayConvention == NoAdjustment
 -}
  -- todo: run this if both fxFixingDates and rateFixingDates exist:
  --assertMsg "fxFixingDates must match rateFixingDates" $ fxFixingDates == rateFixingDates

  assertMsg "notionals list must be of same length as calculationSchedule" $ length notionals == length calculationSchedule
  assertMsg "Non-standard stub rates not supported for the fixed rate leg" $ isNone s.stubCalculationPeriodAmount
  let
    fixLeg = False
    -- calculate floating rate claims
    --createClaim (c, (n, fxAdjRequired)) p f =
    createClaim (c, (n, fxAdjRequired)) p =
      -- Calculate the claims from the current leg (either fix or float)
      -- when (TimeGte d) $ scale (Const a) $ scale (Const n.stepValue) $ one cashInstrumentCid)
      when (TimeGte p.adjustedEndDate) $ scale  (rate * Const (calcPeriodDcf s.calculationPeriodAmount.calculation.dayCountFraction c useAdjustedDatesForDcf periodicSchedule.terminationDate periodicSchedule.frequency)) $ scale notional $ one currency
      --when (TimeGte fixingDate) $ scale notional $ scale (rate * (Const (calcPeriodDcf s.calculationPeriodAmount.calculation.dayCountFraction c useAdjustedDatesForDcf periodicSchedule.terminationDate periodicSchedule.frequency))) $
      --when (TimeGte p.adjustedEndDate) $ one currency
        where
          --fixingDate = fromSome f
          notionalConst = Const n
          notional = case fxRateId of
            None -> notionalConst
            Some fxRateId -> if fxAdjRequired then notionalConst * fxRateObs else notionalConst
              where
                fxRateObs = Observe fxRateId
          fixRate = fixedRateSchedule.initialValue
          regularRate = Const fixRate
          rate = regularRate
{-
          rate = case c.stubType of
            None -> regularRate
            Some stubType -> if isNone s.stubCalculationPeriodAmount then regularRate else fromOptional regularRate (getStubRate (fromSome s.stubCalculationPeriodAmount) (stubType == LongInitial || stubType == ShortInitial) p rateFixingCalendar s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessDayConvention fixLeg)
 -}
    --claimAmounts = mconcat $ zipWith3 createClaim (zip calculationSchedule notionals) paymentScheduleAligned fxFixingDates
    claimAmounts = mconcat $ zipWith createClaim (zip calculationSchedule notionals) paymentScheduleAligned
    claims = if issuerPaysLeg then claimAmounts else give claimAmounts
    claimsTagged = prepareAndTagClaims [claims] "Fix rate payment"


    -- todo: implement principal claims here:
    --allTaggedClaims = [floatingClaimsTagged, principalClaimsTagged]
    allTaggedClaims = [claimsTagged]

  pure allTaggedClaims

-- | Create claims from swapStream that describes a fixed or floating coupon stream.
calculateFloatingPaymentClaimsFromSwapStream : FloatingRateCalculation -> SwapStream -> PeriodicSchedule -> [SchedulePeriod] -> [SchedulePeriod] -> Bool -> Bool -> Deliverable -> Party -> Party -> Optional Text -> Optional [Date] -> [(Decimal, Bool)] -> Update [TaggedClaim]
calculateFloatingPaymentClaimsFromSwapStream floatingRateCalculation s periodicSchedule calculationSchedule paymentScheduleAligned useAdjustedDatesForDcf issuerPaysLeg currency issuer calendarDataAgency fxRateId fxFixingDates notionals = do
  debug "float"
  -- todo: which of these checks are required for fxDates as well? write function, apply for both.
  let r = fromSome s.resetDates
  assertMsg "resetDate must refer to the calculationPeriodDates of the current swapStream" $ r.calculationPeriodDatesReference == s.calculationPeriodDates.id
  assertMsg "resetDate period must match calculation period" $ r.resetFrequency.period == s.calculationPeriodDates.calculationPeriodFrequency.period
  assertMsg "resetDate periodMultiplier must match calculation periodMultiplier" $ r.resetFrequency.periodMultiplier == s.calculationPeriodDates.calculationPeriodFrequency.periodMultiplier
  assertMsg "resetDate businessDayConvention must match calculation businessDayConvention" $ r.resetDatesAdjustments.businessDayConvention == s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessDayConvention
  assertMsg "resetDate businessCenters must match calculation businessCenters" $ r.resetDatesAdjustments.businessCenters == s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessCenters
  assertMsg "Only daily fixing date period supported" $ r.fixingDates.period == D
  assertMsg "Only Business day type supported" $ r.fixingDates.dayType == Business
  assertMsg "Only fixing dates relative to calculation start dates supported" $ r.resetRelativeTo == CalculationPeriodStartDate
  assertMsg "No adjustement (besides business day type) supported" $ r.fixingDates.businessDayConvention == NoAdjustment
  --createPaymentClaims calculationSchedule paymentSchedule constantNotionalScheduleReference periodicSchedule useAdjustedDatesForDcf f.spreadSchedule.initialValue issuerPaysLeg s.calculationPeriodAmount.calculation.dayCountFraction currency f.floatingRateIndex (merge rateFixingCalendars) rateFixingDates s issuer calendarDataAgency

  -- todo: run this if both fxFixingDates and rateFixingDates exist:
  --assertMsg "fxFixingDates must match rateFixingDates" $ fxFixingDates == rateFixingDates

  rateFixingCalendars <- getHolidayCalendars r.fixingDates.businessCenters issuer calendarDataAgency

  let
    rateFixingCalendar = merge $ rateFixingCalendars

    rateFixingDates = map (\p -> Some $ addBusinessDays rateFixingCalendar r.fixingDates.periodMultiplier p.adjustedStartDate) calculationSchedule

  assertMsg "notionals list must be of same length as calculationSchedule" $ length notionals == length calculationSchedule
  let
    fixLeg = False
    -- calculate floating rate claims
    createClaim (c, (n, fxAdjRequired)) p f =
      -- Calculate the claims from the current leg (either fix or float)
      when (TimeGte fixingDate) $ scale notional $ scale (rate * (Const (calcPeriodDcf s.calculationPeriodAmount.calculation.dayCountFraction c useAdjustedDatesForDcf periodicSchedule.terminationDate periodicSchedule.frequency))) $
      when (TimeGte p.adjustedEndDate) $ one currency
        where
          fixingDate = fromSome f
          notionalConst = Const n
          notional = case fxRateId of
            None -> notionalConst
            Some fxRateId -> if fxAdjRequired then notionalConst * fxRateObs else notionalConst
              where
                fxRateObs = Observe fxRateId

          floatingRateSpread = floatingRateCalculation.spreadSchedule.initialValue
          referenceRateId = floatingRateCalculation.floatingRateIndex
          regularRate = Observe referenceRateId + Const floatingRateSpread
          rate = case c.stubType of
            None -> regularRate
            Some stubType -> if isNone s.stubCalculationPeriodAmount then regularRate else fromOptional regularRate (getStubRate (fromSome s.stubCalculationPeriodAmount) (stubType == LongInitial || stubType == ShortInitial) p rateFixingCalendar s.calculationPeriodDates.calculationPeriodDatesAdjustments.businessDayConvention fixLeg)

    claimAmounts = mconcat $ zipWith3 createClaim (zip calculationSchedule notionals) paymentScheduleAligned rateFixingDates
    claims = if issuerPaysLeg then claimAmounts else give claimAmounts
    claimsTagged = prepareAndTagClaims [claims] "Floating rate payment"


    -- todo: implement principal claims here:
    --allTaggedClaims = [floatingClaimsTagged, principalClaimsTagged]
    allTaggedClaims = [claimsTagged]

  pure allTaggedClaims

-- | Create claims from swapStream that describes a fixed or floating coupon stream.
calculateClaimsFromSwapStream : SwapStream -> PeriodicSchedule -> [SchedulePeriod] -> [SchedulePeriod] -> Optional SwapStream -> Bool -> Bool -> Deliverable -> Party -> Party -> Update [TaggedClaim]
calculateClaimsFromSwapStream s periodicSchedule calculationSchedule paymentSchedule swapStreamNotionalRef useAdjustedDatesForDcf issuerPaysLeg currency issuer calendarDataAgency = do
  debug calculationSchedule
  case s.calculationPeriodAmount.calculation.notionalScheduleValue of
    NotionalSchedule_FxLinked fxl -> assertMsg "swapStream currency does not match swap currency" $ currency.id == Id fxl.varyingNotionalCurrency
    NotionalSchedule_Regular n -> assertMsg "swapStream currency does not match swap currency" $ currency.id == Id n.notionalStepSchedule.currency
  assertMsg "stub must refer to the calculationPeriodDates of the current swapStream" $ isNone s.stubCalculationPeriodAmount || getField @"calculationPeriodDatesReference" (fromSome s.stubCalculationPeriodAmount) == s.calculationPeriodDates.id
  assertMsg "Principal exchange not yet supported" $ isNone s.principalExchanges

  -- calculate notional (either fix, amortizing or fx linked)
  (fxRateId, fxLinkedNotionalInitialValue, fxFixingDates) <- getFxRateId calculationSchedule s issuer calendarDataAgency
  let
    fxAdjustmentRequired = isSome fxRateId
    c = s.calculationPeriodAmount.calculation
    n = case swapStreamNotionalRef of
      Some s2 -> case s2.calculationPeriodAmount.calculation.notionalScheduleValue of
        NotionalSchedule_FxLinked fxl -> error "notional reference swapStream must be of regular type, not fx-linked"
        NotionalSchedule_Regular nr -> nr
      _ -> case s.calculationPeriodAmount.calculation.notionalScheduleValue of
        NotionalSchedule_Regular ns -> ns
        _ -> error ""
    notionalSteps = n.notionalStepSchedule.step
    notionalBase
      | length notionalSteps == length calculationSchedule
          = if any (\(n, p) -> n.stepDate /= p.unadjustedStartDate) $ zip notionalSteps calculationSchedule then
              error ("notional step schedule does not match calculationSchedule")
            else
              map (\e -> (e.stepValue, fxAdjustmentRequired)) notionalSteps
      | null notionalSteps
          = replicate (length calculationSchedule) (n.notionalStepSchedule.initialValue, fxAdjustmentRequired)
      | otherwise
          = error
            ("Number of notional steps do not match the number of calculationSchedule periods")
    notionals = case fxLinkedNotionalInitialValue of
      None -> notionalBase
      Some iv -> (iv, False) :: (drop 1 notionalBase)

  debug notionals
  debug "before align"
  paymentScheduleAligned <- alignPaymentSchedule calculationSchedule paymentSchedule
  debug "after align"
  case s.calculationPeriodAmount.calculation.rateTypeValue of
    RateType_Fixed fixedRateSchedule -> calculateFixPaymentClaimsFromSwapStream fixedRateSchedule s periodicSchedule calculationSchedule paymentScheduleAligned useAdjustedDatesForDcf issuerPaysLeg currency issuer calendarDataAgency fxRateId fxFixingDates notionals
    RateType_Floating floatingRateCalculation -> calculateFloatingPaymentClaimsFromSwapStream floatingRateCalculation s periodicSchedule calculationSchedule paymentScheduleAligned useAdjustedDatesForDcf issuerPaysLeg currency issuer calendarDataAgency fxRateId fxFixingDates notionals
