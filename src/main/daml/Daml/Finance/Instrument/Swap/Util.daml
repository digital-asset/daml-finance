-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.Swap.Util where

import ContingentClaims.Core.Claim (Claim, Inequality(..), andList, cond, give, one, scale, when, (<=))
import ContingentClaims.Core.Observation (Observation(..))
import DA.Date (addDays)
import Daml.Finance.Claims.Util.Builders (prepareAndTagClaims)
import Daml.Finance.Claims.Util.Date (convertImplicitDcfToActualDcf)
import Daml.Finance.Interface.Claims.Types (Deliverable, Observable, TaggedClaim(..))
import Daml.Finance.Interface.Instrument.Swap.Types
import Daml.Finance.Interface.Types.Date.Calendar (HolidayCalendarData)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum(..))
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule(..), Schedule, SchedulePeriod)
import Daml.Finance.Util.Date.Calendar (addBusinessDays, adjustDate)
import Daml.Finance.Util.Date.DayCount (calcPeriodDcf)
import Prelude hiding ((<=), and, or)

type O = Observation Date Decimal Observable
type C = Claim Date Decimal Deliverable Observable

-- | HIDE Calculate the fixing date by using a day shift (if applicable) and then adjusting the
-- date.
calculateFixingDate : Date -> FixingDates -> HolidayCalendarData -> Int -> Date
calculateFixingDate baseDate fixingDates fixingCalendars dayShift =
  let
    resetDateUnadjStart = case fixingDates.dayType of
      None -> baseDate
      Some Business -> addBusinessDays fixingCalendars dayShift baseDate
      Some Calendar -> addDays baseDate dayShift
  in
    adjustDate fixingCalendars fixingDates.businessDayConvention resetDateUnadjStart

-- | HIDE Apply a cap and a floor to a floating rate claim.
capAndFloorRate : O -> Optional Decimal -> Optional Decimal -> O -> C -> Decimal -> C
capAndFloorRate observedFloatingRate capRate floorRate dcf notionalAmount couponRate =
  let
    regularRate = observedFloatingRate + Const couponRate
    regularRateClaim = scale (regularRate * dcf) notionalAmount
    rateAfterCap = case capRate of
      None -> regularRateClaim
      Some cap -> cond capCondition capRateClaim regularRateClaim
        where
          capCondition = Const cap <= regularRate
          capRateClaim = scale (Const cap * dcf) notionalAmount
    rateAfterCapAndFloor = case floorRate of
      None -> rateAfterCap
      Some floor -> cond floorCondition floorRateClaim rateAfterCap
        where
          floorCondition = regularRate <= Const floor
          floorRateClaim = scale (Const floor * dcf) notionalAmount
  in rateAfterCapAndFloor

-- | HIDE Calculate the coupon claim for a current period p out of a PeriodicSchedule
calculateCoupon : SchedulePeriod -> DayCountConventionEnum -> Bool -> PeriodicSchedule ->
  Optional FloatingRate -> Decimal -> C -> HolidayCalendarData -> Optional Decimal ->
  Optional Decimal -> C
calculateCoupon p dayCountConvention useAdjustedDatesForDcf periodicSchedule
  floatingRate couponRate notionalAmount fixingCalendars capRate
  floorRate =
  let
    dcf = Const $ calcPeriodDcf dayCountConvention p useAdjustedDatesForDcf
      periodicSchedule.terminationDate periodicSchedule.frequency
    cpn = case floatingRate of
      None -> scale ((Const couponRate) * dcf) notionalAmount
      Some fr -> case fr.referenceRateType of
        SingleFixing resetRelativeTo -> rateAfterCapAndFloor
          where
            baseDate = case (useAdjustedDatesForDcf, resetRelativeTo) of
              (True, CalculationPeriodStartDate) -> p.adjustedStartDate
              (True, CalculationPeriodEndDate) -> p.adjustedEndDate
              (False, CalculationPeriodStartDate) -> p.unadjustedStartDate
              (False, CalculationPeriodEndDate) -> p.unadjustedEndDate
            resetDate = calculateFixingDate baseDate fr.fixingDates fixingCalendars dayShift
            observedFloatingRate = ObserveAt fr.referenceRateId resetDate
            rateAfterCapAndFloor = capAndFloorRate observedFloatingRate capRate floorRate dcf
              notionalAmount couponRate
        CompoundedIndex dcfConventionImpl -> rateAfterCapAndFloor
          where
            baseStartDate = if useAdjustedDatesForDcf then p.adjustedStartDate
              else p.unadjustedStartDate
            resetDateStart = calculateFixingDate baseStartDate fr.fixingDates fixingCalendars
              dayShift
            baseEndDate = if useAdjustedDatesForDcf then p.adjustedEndDate
              else p.unadjustedEndDate
            resetDateEnd = calculateFixingDate baseEndDate fr.fixingDates fixingCalendars
              dayShift
            compoundedFloatingRate = ObserveAt fr.referenceRateId resetDateEnd /
              ObserveAt fr.referenceRateId resetDateStart - Const 1.0
            dcfConversionFactor = convertImplicitDcfToActualDcf dcf p useAdjustedDatesForDcf
              periodicSchedule dcfConventionImpl
            rateAfterCapAndFloor = capAndFloorRate compoundedFloatingRate capRate floorRate
              dcfConversionFactor notionalAmount couponRate
        where
          dayShift = if fr.fixingDates.period == D then fr.fixingDates.periodMultiplier
            else error "Only daily periods supported"
  in cpn

-- | Calculate a floating rate amount for each payment date and create claims.
-- This is a general function that supports both LIBOR and SOFR-COMPOUND reference rates.
createGeneralFloatingRatePaymentClaims : (Date -> Time) -> Schedule -> PeriodicSchedule -> Bool ->
  Decimal -> Bool -> DayCountConventionEnum -> Decimal -> Deliverable -> FloatingRate ->
  HolidayCalendarData -> TaggedClaim
createGeneralFloatingRatePaymentClaims dateToTime schedule periodicSchedule useAdjustedDatesForDcf
  floatingRateSpread ownerReceives dayCountConvention notional cashInstrument floatingRate
  fixingCalendars =
  let
    notionalAmount = scale (Const notional) $ one cashInstrument
    couponClaimAmounts = andList $ map (\p ->
        when (TimeGte p.adjustedEndDate)
        $ calculateCoupon p dayCountConvention useAdjustedDatesForDcf periodicSchedule
            (Some floatingRate) floatingRateSpread notionalAmount fixingCalendars None None
      ) schedule
    couponClaims = if ownerReceives then couponClaimAmounts else give couponClaimAmounts
  in prepareAndTagClaims dateToTime [couponClaims] "Floating rate payment"
