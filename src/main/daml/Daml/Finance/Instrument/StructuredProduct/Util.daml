-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.StructuredProduct.Util where

import ContingentClaims.Core.Claim (Claim, Inequality(..), and, at, cond, one, scale, when, zero)
import ContingentClaims.Core.Observation (Observation(..))
import DA.List (last)
import DA.Optional (isSome)
import Daml.Finance.Claims.Util.Builders (calculateRatePayment, prepareAndTagClaims)
import Daml.Finance.Interface.Claims.Types (Deliverable, Observable, TaggedClaim(..))
import Daml.Finance.Interface.Instrument.Types.FloatingRate (FloatingRate)
import Daml.Finance.Interface.Types.Date.Calendar (HolidayCalendarData)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule(..), Schedule)
import Prelude hiding (and, or, (<=))

type O = Observation Date Decimal Observable
type C = Claim Date Decimal Deliverable Observable

-- | Find out which schedule periods of scheduleA exist in scheduleB.
includes : Schedule -> Schedule -> [Bool]
includes scheduleA scheduleB =
  map (\a -> isSome $ find (\b -> b.adjustedEndDate == a.adjustedEndDate) scheduleB) scheduleA

-- | Calculate the claims for a an auto-callable with a fixed and/or floating coupon on each payment
--   date and a redemption amount at the end (unless auto-called previously).
createAutoCallableClaims : (Date -> Time) -> Schedule -> Schedule -> PeriodicSchedule
  -> Bool -> Decimal -> DayCountConventionEnum -> Decimal -> Deliverable -> Optional FloatingRate
  -> Optional Decimal -> Optional Decimal -> Text -> Decimal -> Decimal -> Decimal -> Decimal -> HolidayCalendarData
  -> TaggedClaim
createAutoCallableClaims dateToTime paymentSchedule callableSchedule periodicSchedule
  useAdjustedDatesForDcf couponRate dayCountConvention notional cashInstrument floatingRate
  capRate floorRate spot couponBarrier callBarrier finalBarrier initialFixing fixingCalendars =
  let
    notionalAmount = scale (Const notional) $ one cashInstrument

    principal = notionalAmount

    combineTagClaim (couponPeriod, callPeriod) notCalledClaim =
      let
        cpn = calculateRatePayment couponPeriod dayCountConvention useAdjustedDatesForDcf periodicSchedule
          floatingRate couponRate notionalAmount fixingCalendars capRate floorRate
        (callDate, paymentDate) = if callPeriod.adjustedEndDate < couponPeriod.adjustedEndDate
          then (callPeriod.adjustedEndDate, couponPeriod.adjustedEndDate)
          else error "call date must be before payment date"
        spotOnObservationDate = ObserveAt spot callDate
        couponBarrierHit = Lte (spotOnObservationDate, Const couponBarrier)
        coupon = cond couponBarrierHit zero cpn
        called = when (at paymentDate) $ and coupon principal
        notCalled = when (at paymentDate) $ and coupon notCalledClaim
        autoExerciseCondition = Lte (Const callBarrier, spotOnObservationDate)
        tailClaim = when (at callDate) $ cond autoExerciseCondition called notCalled
      in
        tailClaim

    finalCouponDate = (.adjustedEndDate) $ last paymentSchedule
    finalObservationDate = (.adjustedEndDate) $ last callableSchedule
    spotOnObservationDate = ObserveAt spot finalObservationDate
    barrierHit = Lte (spotOnObservationDate, Const finalBarrier)
    perf = spotOnObservationDate / Const initialFixing
    perfomanceScaledPrincipal = scale perf notionalAmount
    redemptionPayment = cond barrierHit perfomanceScaledPrincipal principal
    notCalledFinal = when (at finalCouponDate) redemptionPayment
    claims = foldr (\p acc -> combineTagClaim p acc) notCalledFinal $ zip paymentSchedule callableSchedule

  in
    prepareAndTagClaims dateToTime [claims] "Callable bond payment"
