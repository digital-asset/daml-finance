-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Instrument.StructuredProduct.Util where

import ContingentClaims.Core.Claim (Claim, Inequality(..), and, at, cond, one, scale, when, zero)
import ContingentClaims.Core.Observation (Observation(..))
import DA.List (last)
import DA.Optional (isSome)
import Daml.Finance.Claims.Util.Builders (calculateRatePayment, prepareAndTagClaims)
import Daml.Finance.Interface.Claims.Types (Deliverable, Observable, TaggedClaim(..))
import Daml.Finance.Interface.Instrument.Types.FloatingRate (FloatingRate)
import Daml.Finance.Interface.Types.Date.Calendar (HolidayCalendarData)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.Schedule (PeriodicSchedule(..), Schedule)
import Prelude hiding (and, or, (<=))
import Prelude qualified as P (and)

type O = Observation Date Decimal Observable
type C = Claim Date Decimal Deliverable Observable

-- | Find out which schedule periods of scheduleA exist in scheduleB.
includes : Schedule -> Schedule -> [Bool]
includes scheduleA scheduleB =
  map (\a -> isSome $ find (\b -> b.adjustedEndDate == a.adjustedEndDate) scheduleB) scheduleA

-- | Calculate the claims for a an auto-callable with a fixed and/or floating coupon on each payment
--   date and a redemption amount at the end (unless auto-called previously).
createAutoCallableClaims : (Date -> Time) -> Schedule -> Schedule -> PeriodicSchedule
  -> Bool -> Decimal -> DayCountConventionEnum -> Decimal -> Deliverable -> Optional FloatingRate
  -> Optional Decimal -> Optional Decimal -> Text -> Decimal -> Decimal -> Decimal -> Decimal -> HolidayCalendarData
  -> TaggedClaim
createAutoCallableClaims dateToTime paymentSchedule callableSchedule periodicSchedule
  useAdjustedDatesForDcf couponRate dayCountConvention notional cashInstrument floatingRate
  capRate floorRate spot couponBarrier callBarrier finalBarrier initialFixing fixingCalendars =
  let
    notionalAmount = scale (Const notional) $ one cashInstrument

    principal = notionalAmount
{-
    -- Find out on which coupon dates it is possible to call the bond.
    callPossibleInit = includes schedule callableSchedule

    -- Also search in the other direction, to ensure that no intended call dates are ignored.
    potentialCallDatesFound = includes callableSchedule schedule

    callPossible = if P.and potentialCallDatesFound then callPossibleInit
      else error "All dates in the call schedule must exist in the coupon schedule"
 -}
    -- TODO: verify that callableSchedule has same length as periodicSchedule
    -- TODO: verify that callableSchedule dates are before periodicSchedule dates

    combineTagClaim (couponPeriod, callPeriod) notCalledClaim =
      let
        cpn = calculateRatePayment couponPeriod dayCountConvention useAdjustedDatesForDcf periodicSchedule
          floatingRate couponRate notionalAmount fixingCalendars capRate floorRate
        callDate = callPeriod.adjustedEndDate
        spotOnObservationDate = ObserveAt spot callDate
        couponBarrierHit = Lte (spotOnObservationDate, Const couponBarrier)
        coupon = cond couponBarrierHit zero cpn
        called = when (at couponPeriod.adjustedEndDate) $ and coupon principal
        notCalled = when (at couponPeriod.adjustedEndDate) $ and coupon notCalledClaim
        autoExerciseCondition = Lte (Const callBarrier, spotOnObservationDate)
        tailClaim = when (at callDate) $ cond autoExerciseCondition called notCalled
      in
        tailClaim

    finalCouponDate = (.adjustedEndDate) $ last paymentSchedule
    finalObservationDate = (.adjustedEndDate) $ last callableSchedule
    spotOnObservationDate = ObserveAt spot finalObservationDate
    barrierHit = Lte (spotOnObservationDate, Const finalBarrier)
    perf = spotOnObservationDate / Const initialFixing
    scaledNotionalAmount = scale perf notionalAmount
    redemptionPayment = cond barrierHit scaledNotionalAmount principal
    notCalledFinal = when (at finalCouponDate) redemptionPayment
    -- TODO: do not fold over the last period in paymentSchedule, has short ki put (no 100% guarantee)
    claimAmount = foldr (\p acc -> combineTagClaim p acc) notCalledFinal $ zip paymentSchedule callableSchedule

    claims = claimAmount

  in
    prepareAndTagClaims dateToTime [claims] "Callable bond payment"
