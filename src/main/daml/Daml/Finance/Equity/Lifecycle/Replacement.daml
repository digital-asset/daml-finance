-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Equity.Lifecycle.Replacement where

import DA.Date (toDateUTC)
import DA.Time (time)
import Daml.Finance.Interface.Asset.Instrument qualified as Instrument (K, Q)
import Daml.Finance.Interface.Common.Types (Observers)
import Daml.Finance.Interface.Common.Util (flattenObservers)
import Daml.Finance.Interface.Equity.Lifecycle.CorporateAction qualified as CorporateAction (I, View(..))
import Daml.Finance.Interface.Lifecycle.Clock qualified as Clock (view)
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I, View(..))
import Daml.Finance.Interface.Lifecycle.Lifecyclable qualified as Lifecyclable (HasImplementation, Lifecycle(..), I, View(..))
import Daml.Finance.Lifecycle.Effect (Effect(..))

type T = Replacement

instance Lifecyclable.HasImplementation T
-- | Replacement of units of an instrument with a basket of other instruments.
template Replacement
  with
    offerer : Party
      -- ^ The party offering the takeover.
    executionDate : Date
      -- ^ The replacement's execution date.
    targetInstrument : Instrument.K
      -- ^ The instrument whose units are consumed by the merger.
    offeredAssets : [Instrument.Q]
      -- ^ The instruments whose units are delivered and corresponding amounts.
    id : Text
      -- ^ A textual identifier.
    observers : Observers
      -- ^ Observers.
  where
    signatory offerer
    observer flattenObservers observers

    implements CorporateAction.I where
      asEvent = toInterface @Event.I this
      asLifecyclable = toInterface @Lifecyclable.I this
      view = CorporateAction.View with offerer; effectiveDate = executionDate; id

    implements Lifecyclable.I where
      view = Lifecyclable.View with lifecycler = offerer
      lifecycleImpl Lifecyclable.Lifecycle{ruleName; settler; clockCid} self = do
        currentDate <- toDateUTC . (.clockTime) . Clock.view <$> fetch clockCid
        if currentDate == executionDate
        then do
          effectCid <- toInterfaceContractId <$> create Effect
            with
              provider = offerer
              settler
              targetInstrument
              producedInstrument = None
              consumed = []
              produced = offeredAssets
              settlementDate = executionDate
              id
              observers
          pure (self, [effectCid])
        else do
          pure (self, [])

    implements Event.I where
      view = Event.View with eventTime = time executionDate 11 00 00
