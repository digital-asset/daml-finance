-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Claims.Lifecycle.Rule where

import DA.Set (fromList, singleton)
import DA.Text (sha256)
import Daml.Finance.Claims.Util (isZero')
import Daml.Finance.Claims.Util.Lifecycle (electionEvent, lifecycle, lifecycleClaims, netOnTag, splitPending, timeEvent)
import Daml.Finance.Interface.Claims.Claim qualified as Claim (getAcquisitionTime)
import Daml.Finance.Interface.Claims.Dynamic.Instrument qualified as DynamicInstrument (CreateNewVersion(..), GetView(..), I)
import Daml.Finance.Interface.Claims.Types (EventData(..))
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as BaseInstrument (R, exerciseInterfaceByKey, getKey)
import Daml.Finance.Interface.Lifecycle.Election qualified as Election (ApplyElection(..), Exercisable(..), ExercisableView(..), getElectionTime)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (Evolve(..), I, View(..))
import Daml.Finance.Interface.Types.Common.Types (Id(..), InstrumentKey, Parties, PartiesMap)
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, View(..), flattenObservers)
import Daml.Finance.Lifecycle.Effect (Effect(..))
import Daml.Finance.Lifecycle.ElectionEffect (ElectionEffect(..))
import Daml.Finance.Util.Disclosure (addObserversImpl, removeObserversImpl, setObserversImpl)

-- | Rule to process an event for instruments that are modelled using "on-the-fly" claims
-- (the tree is not stored on-ledger but generated dynamically).
-- This rule supports both time update events and election events.
template Rule
  with
    providers : Parties
      -- ^ Providers of the distribution rule.
    lifecycler : Party
      -- ^ Party performing the lifecycling.
    observers : PartiesMap
      -- ^ Observers of the distribution rule.
    id : Id
      -- ^ Identifier for the rule contract.
    description : Text
      -- ^ Textual description.
  where
    signatory providers
    observer Disclosure.flattenObservers observers, lifecycler

    -- Lifecycle time update events
    interface instance Lifecycle.I for Rule where
      view = Lifecycle.View with lifecycler; id; description
      -- BOND_PROCESS_CLOCK_UPDATE_INITAL_CLAIMS_BEGIN
      evolve Lifecycle.Evolve{eventCid; observableCids; instrument} = do
        claimInstrument <- fetchInterfaceByKey @BaseInstrument.R instrument
      -- BOND_PROCESS_CLOCK_UPDATE_INITAL_CLAIMS_END
        -- BOND_PROCESS_CLOCK_UPDATE_LIFECYCLE_FASTFORWARD_BEGIN
        -- Recover claims tree as of the lastEventTimestamp. For a bond, this just requires
        -- lifecycling as of the lastEventTimestamp.
        nv <- BaseInstrument.exerciseInterfaceByKey @DynamicInstrument.I instrument lifecycler
          DynamicInstrument.GetView with viewer = lifecycler
        claims <- fst <$>
          lifecycle lifecycler observableCids claimInstrument [timeEvent nv.lastEventTimestamp]
        -- BOND_PROCESS_CLOCK_UPDATE_LIFECYCLE_FASTFORWARD_END
        -- BOND_PROCESS_CLOCK_UPDATE_LIFECYCLE_BEGIN
        -- Lifecycle
        let acquisitionTime = Claim.getAcquisitionTime claimInstrument
        v <- view <$> fetch eventCid
        (remaining, pending) <- lifecycleClaims observableCids acquisitionTime claims
          [timeEvent v.eventTime]
        let
          pendingAfterNetting = netOnTag pending
          (otherConsumed, otherProduced) = splitPending pendingAfterNetting
        if remaining == claims && null pendingAfterNetting then
          pure (None, [])
        else do
          let
            currentKey = BaseInstrument.getKey $ toInterface claimInstrument
            newKey = currentKey with version = sha256 $ show remaining
            producedInstrument = if isZero' remaining then None else Some newKey
          tryCreateNewInstrument lifecycler v.eventTime instrument newKey
          effectCid <- toInterfaceContractId <$> create Effect with
            providers = singleton currentKey.issuer
            id = v.id
            description = v.description
            targetInstrument = currentKey
            producedInstrument
            otherConsumed
            otherProduced
            settlementTime = Some v.eventTime
            observers = Disclosure.flattenObservers . (.observers) . view $
              toInterface @Disclosure.I claimInstrument
          pure (Some newKey, [effectCid])
        -- BOND_PROCESS_CLOCK_UPDATE_LIFECYCLE_END

    -- Lifecycle election events
    interface instance Election.Exercisable for Rule where
      view = Election.ExercisableView with lifecycler
      applyElection Election.ApplyElection{electionCid; observableCids} = do

        -- fetch election
        election <- fetch electionCid
        let
          v = view election
          electionTime = Election.getElectionTime election
          election = electionEvent electionTime v.electorIsOwner v.claim

        -- retrieve election data for previous elections and re-create election events
        nv <- BaseInstrument.exerciseInterfaceByKey @DynamicInstrument.I v.instrument lifecycler
          DynamicInstrument.GetView with viewer = lifecycler
        let
          prevElections = map (\e ->
            case e.election of
              None -> error "election missing"
              Some (electorIsOwner, tag) -> electionEvent e.t electorIsOwner tag)
            nv.prevElections

        -- fetch claim tree as of instrument inception
        claimInstrument <- fetchInterfaceByKey @BaseInstrument.R v.instrument
        let acquisitionTime = Claim.getAcquisitionTime claimInstrument

        -- fast-forward the claims tree to the current version by replaying the previous elections
        claims <- fst <$>
          lifecycle lifecycler observableCids claimInstrument prevElections

        -- lifecycle as of the time given by the event, by applying the corresponding election
        (remaining, pending) <- lifecycleClaims observableCids acquisitionTime claims [election]

        -- create new instrument and return effect
        if remaining == claims && null pending then
          pure (None, [])
        else do
          let
            currentKey = BaseInstrument.getKey $ toInterface claimInstrument
            newKey = currentKey with version = sha256 $ show remaining
            producedInstrument = if isZero' remaining then None else Some newKey
            (otherConsumed, otherProduced) = splitPending pending
          tryCreateNewElectionInstrument lifecycler nv.prevElections electionTime v.electorIsOwner
            v.claim v.instrument newKey
          effectCid <- toInterfaceContractId <$>
            create ElectionEffect with
              providers = fromList [v.instrument.issuer, v.instrument.depository]
              custodian = if v.electorIsOwner then v.counterparty else v.elector
              owner = if v.electorIsOwner then v.elector else v.counterparty
              id = v.id
              description = v.description
              targetInstrument = currentKey
              producedInstrument
              amount = v.amount
              otherConsumed
              otherProduced
              settlementTime = Some electionTime
              observers = v.observers
          pure (Some newKey, [effectCid])

    interface instance Disclosure.I for Rule where
      view = Disclosure.View with disclosureControllers = providers; observers
      setObservers = setObserversImpl @Rule @Disclosure.I this None
      addObservers = addObserversImpl @Rule @Disclosure.I this None
      removeObservers = removeObserversImpl @Rule @Disclosure.I this None

-- | HIDE
-- Check if an instrument for the new key already exists, otherwise create it.
tryCreateNewInstrument : Party -> Time -> InstrumentKey -> InstrumentKey -> Update ()
tryCreateNewInstrument actor eventTime oldKey newKey =
  do
    existingRefCidOpt <- lookupByKey @BaseInstrument.R newKey
    case existingRefCidOpt of
      Some _ -> pure ()
      None -> do
        newInstrumentCid <- BaseInstrument.exerciseInterfaceByKey @DynamicInstrument.I oldKey
          actor DynamicInstrument.CreateNewVersion with
            lastEventTimestamp = eventTime; version = newKey.version; prevElections = []
        pure ()

-- | HIDE
-- Check if an instrument for the new key already exists, otherwise create it.
tryCreateNewElectionInstrument : Party -> [EventData] -> Time -> Bool -> Text -> InstrumentKey ->
  InstrumentKey -> Update ()
tryCreateNewElectionInstrument actor prevElections eventTime electorIsOwner claimTag oldKey
  newKey = do
    existingRefCidOpt <- lookupByKey @BaseInstrument.R newKey
    case existingRefCidOpt of
      Some _ -> pure ()
      None -> do
        let
          newElection = EventData with
            t = eventTime
            election = Some (electorIsOwner, claimTag)
        instrumentCid <- BaseInstrument.exerciseInterfaceByKey @DynamicInstrument.I oldKey
          actor DynamicInstrument.CreateNewVersion with
            lastEventTimestamp = eventTime
            prevElections = prevElections ++ [newElection]
            version = newKey.version
        pure ()
