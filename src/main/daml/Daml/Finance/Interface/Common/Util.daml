-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Finance.Interface.Common.Util
  ( exerciseInterfaceByKeyHelper
  , fetchInterfaceByKey
  , flattenObservers
  , groupBy
  , mapWithIndex
  , notNull
  , verify
  ) where

import DA.Map qualified as M (Map, empty, insert, lookup, toList)
import DA.Record (HasField)
import DA.Set qualified as S (fromList, toList)
import Daml.Finance.Interface.Common.Types (Observers, Parties)
import DA.List qualified as List (null)

-- | Like `List.groupOn`, but returns the output in a `Map`.
groupBy : Ord k => (a -> k) -> [a] -> M.Map k [a]
groupBy f = foldl g M.empty
  where
    g acc x =
      let
        k = f x
        z = case M.lookup k acc of
          None -> [x]
          Some xs -> x :: xs
      in M.insert k z acc

-- | Like `map`, but the mapping function includes the zero-based index of the item.
mapWithIndex : (a -> Int -> b) -> [a] -> [b]
mapWithIndex f as = fst $ foldr (\a (bs, i) -> (f a i :: bs, i + 1)) ([], 0) as

-- | Checks if the input list is not empty.
notNull : [a] -> Bool
notNull = not . List.null

-- | Let us fetch an interface by key
fetchInterfaceByKey : forall t k i. (HasFetchByKey t k, HasField "cid" t (ContractId i), HasFetch i) => k -> Update i
fetchInterfaceByKey k = do
  d <- snd <$> fetchByKey @t k
  fetch $ coerceContractId d.cid

-- | HIDE
-- Utility function for exercising interface by key.
exerciseInterfaceByKeyHelper : forall t1 t2 t k c d r. (HasExerciseByKey t1 k c (ContractId t), HasExercise t2 d r) => k -> c -> d -> Update r
exerciseInterfaceByKeyHelper k arg1 arg2 = do
  cid : ContractId t <- exerciseByKey @t1 k arg1
  let cid' : ContractId t2 = coerceContractId cid
  exercise cid' arg2

-- | Verify is assertMsg with its arguments flipped.
verify : CanAssert m => Bool -> Text -> m ()
verify = flip assertMsg

-- | Flattens observers into a `Set Party` for usage in template definitions. For example:
-- ```
-- observer $ flattenObservers observers
-- ```
flattenObservers : Observers -> Parties
flattenObservers (observers : Observers) =
  S.fromList $ concatMap (\t -> concatMap S.toList (S.toList t._2)) (M.toList observers)
