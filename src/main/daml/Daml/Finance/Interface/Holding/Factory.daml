-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

module Daml.Finance.Interface.Holding.Factory where

import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Types.Common.Types (AccountKey(..), HoldingFactoryKey(..), Id, InstrumentKey(..), Parties, PartiesMap)
import Daml.Finance.Interface.Util.Common (exerciseInterfaceByKeyHelper)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), GetView(..), I, RemoveObservers(..), flattenObservers)

-- | Type synonym for `Factory`.
type F = Factory

-- | Type synonym for `Reference`. This type is currently used as a work-around given the lack of
-- interface keys.
type R = Reference

-- | Type synonym for `View`.
type V = View

-- View of `Factory`.
data View = View
  with
    provider : Party
      -- ^ The provider of the `Factory`.
    id : Id
      -- ^ Identifier for the holding factory.
  deriving (Eq, Show)

-- | Convert the account's 'View' to its key.
toKey : View -> HoldingFactoryKey
toKey v = HoldingFactoryKey with provider = v.provider; id = v.id

-- | Holding factory contract used to create (credit) holdings.
interface Factory requires Disclosure.I where
  viewtype V

  create' : Create -> Update (ContractId Base.I)
    -- ^ Implementation of `Create` choice.

  nonconsuming choice GetView : View
    -- ^ Retrieves the interface view.
    with
      viewer : Party
        -- ^ The party fetching the view.
    controller viewer
    do
      pure $ view this

  nonconsuming choice Create : ContractId Base.I
    -- ^ Create a holding on the instrument in the corresponding account.
    with
      instrument : InstrumentKey
        -- ^ The instrument of which units are held.
      account : AccountKey
        -- ^ The account at which the holding is held. Defines the holding's owner and custodian.
      amount : Decimal
        -- ^ Number of units.
      observers : PartiesMap
        -- ^ Observers of the holding to be credited.
    controller account.custodian, account.owner
      do
        create' this arg

-- | HIDE
-- This template is used to key a Holding Factory contract. It allows for looking up this contract by key
-- then acquiring the Factory contract by fetching its contract id on this contract. As updates are
-- made to a Factory, this Reference contract is required to be kept in sync.
template Reference
  with
    factoryView : View
      -- ^ The default view for factories.
    cid : ContractId Factory
      -- ^ The contract id of the factory.
    observers : PartiesMap
  where
    signatory factoryView.provider
    observer Disclosure.flattenObservers observers

    key toKey factoryView : HoldingFactoryKey
    maintainer key.provider

    nonconsuming choice GetCid : ContractId Factory
      -- ^ Get the `Factory`'s contract id.
      with
        viewer : Party
      controller viewer
      do
        pure cid

    choice SetCid : ContractId Reference
      -- ^ Set the factory cid. This choice should be called only from `Factory` implementations.
      with
        newCid : ContractId Factory
          -- ^ The factory cid.
      controller factoryView.provider
      do
        create this with cid = newCid

    choice SetObservers : ContractId Reference
      -- ^ Set observers. This choice should be called only from `Factory` implementations.
      with
        newObservers : PartiesMap
          -- ^ The new observers.
      controller factoryView.provider
      do
        create this with observers = newObservers

-- | Create factory including reference.
createWithReference : (HasCreate f, HasToInterface f F) => f -> Update (ContractId F)
createWithReference factory = do
  cid <- toInterfaceContractId @F <$> create factory
  createReference (view $ toInterface @F factory).provider cid
  pure cid

-- | Exercise interface by key.
-- This method can be used to exercise a choice on a `Factory` given its `FactoryKey`.
-- Requires as input the `FactoryKey`, the actor fetching the factory and the choice arguments.
-- For example:
-- ```
-- exerciseInterfaceByKey @HoldingFactory.I holdingFactoryKey actor
--   HoldingFactory.Create with instrument; account; amount; observers
-- ```
exerciseInterfaceByKey : forall i d r. (HasInterfaceTypeRep i, HasExercise i d r)
  => HoldingFactoryKey -- ^ The factory key.
  -> Party             -- ^ The actor fetching the factory.
  -> d                 -- ^ The choice arguments.
  -> Update r
exerciseInterfaceByKey k viewer arg =
  exerciseInterfaceByKeyHelper @R @F @i k (GetCid with viewer) arg

-- | Disclose factory.
disclose : (Text, Parties) -> Party -> Parties -> HoldingFactoryKey -> Update (ContractId F)
disclose observersToAdd actor disclosers factory =
  fromInterfaceContractId <$>
    exerciseInterfaceByKey
      @Disclosure.I
      factory
      actor
      Disclosure.AddObservers with disclosers; observersToAdd

-- | Undisclose factory.
undisclose : (Text, Parties) -> Party -> Parties -> HoldingFactoryKey ->
  Update (Optional (ContractId F))
undisclose observersToRemove actor disclosers factory =
  fmap fromInterfaceContractId <$>
    exerciseInterfaceByKey
      @Disclosure.I
      factory
      actor
      Disclosure.RemoveObservers with disclosers; observersToRemove

-- | HIDE
-- Create Reference for the factory.
createReference : Party -> ContractId F -> Update (ContractId R)
createReference actor cid = do
  factoryView <- exercise cid GetView with viewer = actor
  disclosureView <- exercise
    (toInterfaceContractId @Disclosure.I cid)
    Disclosure.GetView with viewer = actor
  create Reference with factoryView; cid; observers = disclosureView.observers

-- | HIDE
-- Helper function to update the factory reference once observers are added to the factory.
disclosureUpdateReference : HoldingFactoryKey -> PartiesMap -> ContractId F ->
  Update (ContractId Disclosure.I)
disclosureUpdateReference k newObservers iCid = do
  exerciseByKey @Reference k SetCid with newCid = iCid
  exerciseByKey @Reference k SetObservers with newObservers
  pure $ toInterfaceContractId iCid
