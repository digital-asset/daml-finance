-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Interface.Holding.Util where

import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I)
import Daml.Finance.Interface.Types.Common.Types (InstrumentKey, Parties)
import Daml.Finance.Interface.Util.Common (isInstanceOf)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I, RemoveObservers(..))

-- | The `HoldingStandard` data type classifies holdings based on the interfaces they implement in
-- the holding hierarchy:
--
--   Fungible.I
--      | require
--      v
--   Transferable.I
--      | require
--      v
--    Base.I
--
data HoldingStandard
  = Fungible
    -- ^ Represents the class of holdings which implement Fungible.I, and by extension,
    --   Transferable.I and Base.I.
  | NonFungible
    -- ^ Represents the class of holdings which implement Transferable.I and, by extension,
    --   Base.I, but not Fungible.I.
  | NonTransferable
    -- ^ Represents the class of holdings which implement only Base.I and neither Transferable.I
    --   nor Fungible.I.
  deriving (Eq, Ord)

-- | Returns the holding standard of a holding.
getHoldingStandard : ContractId Base.I -> Update HoldingStandard
getHoldingStandard cid = do
  implementsFungible <- isInstanceOf @Fungible.I cid
  if implementsFungible then
    pure Fungible
  else do
    implementsTransferable <- isInstanceOf @Transferable.I cid
    if implementsTransferable then
      pure NonFungible
    else
      pure NonTransferable

-- | Get the key of a holding.
getInstrument : (HasToInterface t Base.I) => t -> InstrumentKey
getInstrument holding = (view $ toInterface @Base.I holding).instrument

-- | Get the amount of a holding.
getAmount : (HasToInterface t Base.I) => t -> Decimal
getAmount holding = (view $ toInterface @Base.I holding).amount

-- | Disclose a holding.
disclose :
  ( HasInterfaceTypeRep i
  , HasToInterface i Disclosure.I
  , HasFromInterface i Disclosure.I
  )
  => (Text, Parties) -> Parties -> ContractId i -> Update (ContractId i)
disclose observersToAdd disclosers cid = fromInterfaceContractId <$>
  exercise (toInterfaceContractId @Disclosure.I cid) Disclosure.AddObservers with
    disclosers; observersToAdd

-- | Undisclose a holding.
undisclose :
  ( HasInterfaceTypeRep i
  , HasToInterface i Disclosure.I
  , HasFromInterface i Disclosure.I
  )
  => (Text, Parties) -> Parties -> ContractId i -> Update (Optional (ContractId i))
undisclose observersToRemove disclosers cid = fmap fromInterfaceContractId <$>
  exercise (toInterfaceContractId @Disclosure.I cid) Disclosure.RemoveObservers with
    disclosers; observersToRemove
