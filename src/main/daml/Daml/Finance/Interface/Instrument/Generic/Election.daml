-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Interface.Instrument.Generic.Election where

import Daml.Finance.Interface.Claims.Types (C)
import Daml.Finance.Interface.Lifecycle.Observable.NumericObservable qualified as NumericObservable (I)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I)
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I, Implementation, getEventTime)
import Daml.Finance.Interface.Types.Common.Types (Id, InstrumentKey, PartiesMap)

-- | Type synonym for `Election`.
type I = Election

-- | Type synonym for `View`.
type V = View

-- | View for `Election`.
data View = View
  with
    id : Id
      -- ^ The identifier for an election.
    description : Text
      -- ^ A description of the instrument.
    claim : C
      -- ^ The claim representation of the election (i.e., the elected sub-tree).
    elector : Party
      -- ^ Parties on behalf of which the election is made.
    counterparty : Party
      -- ^ Faces the `elector` in the `Holding`.
    electorIsOwner : Bool
      -- ^ `True` if election is on behalf of the owner of the holding, `False` otherwise.
    observers : PartiesMap
      -- ^ Observers of the election.
    amount : Decimal
      -- ^ Number of instrument units to which the election applies.
    provider : Party
      -- ^ Party that is authorized to process the election and generate the new instrument version
      --   and effects.
    instrument : InstrumentKey
      -- ^ The instrument to which the election applies.
  deriving (Eq, Show)

-- | Interface implemented by templates that represents a claim-based election. This interface
--   requires the `Event` interface implementation.
interface Election where
  viewtype V

  asEvent : Event.I
    -- ^ Conversion to `Event` interface.
  archive' : ContractId Election -> Update ()
    -- ^ Implementation of archiving the contract.

  nonconsuming choice GetView : View
    -- ^ Retrieves the interface view.
    with
      viewer : Party
        -- ^ The party retrieving the view.
    controller viewer
    do
      pure $ view this

  nonconsuming choice Apply : (Optional InstrumentKey, [ContractId Effect.I])
    -- ^ Applies the election to the instrument, returning the new instrument as well as the
    --   corresponding effects. The election is archived as part of this choice.
    with
      observableCids : [ContractId NumericObservable.I]
        -- ^ Set of observables.
      exercisableCid : ContractId Exercisable
        -- ^ The contract that is used to apply an election to the instrument.
    controller (view this).provider
    do
      let v = view this
      (newInstrumentCid, effects) <- exercise exercisableCid ApplyElection with
        observableCids
        electionCid = toInterfaceContractId self
      archive' this self -- this is needed as we can't write postconsuming choices on interfaces
      pure (newInstrumentCid, effects)

-- | Type constraint for requiring templates to implement `Exercisable` along with `Event`.
type Implementation t = (HasToInterface t I, Event.Implementation t)
instance HasToInterface I Event.I where _toInterface = asEvent
class (Implementation t) => HasImplementation t
instance HasImplementation I

-- | Retrieves the election's time.
getElectionTime : Election -> Time
getElectionTime = Event.getEventTime . asEvent

-- | View for `Exercisable`.
data ExercisableView = ExercisableView
  with
    lifecycler : Party
      -- ^ Party processing the election.
  deriving (Eq, Show)

-- | Interface implemented by instruments that admit (claim-based) elections.
interface Exercisable where
  viewtype ExercisableView

  applyElection : ApplyElection -> Update (Optional InstrumentKey, [ContractId Effect.I])
    -- ^ Implementation of the `ApplyElection` choice.

  nonconsuming choice Exercisable_GetView : ExercisableView
    -- ^ Retrieves the interface view.
    with
      viewer : Party
        -- ^ The party retrieving the view.
    controller viewer
    do
      pure $ view this

  nonconsuming choice ApplyElection : (Optional InstrumentKey, [ContractId Effect.I])
    -- ^ Applies an election to the instrument.
    with
      electionCid : ContractId Election
        -- ^ The election.
      observableCids : [ContractId NumericObservable.I]
        -- ^ Set of observables.
    controller (view this).lifecycler
    do
      applyElection this arg

-- | Type constraint for requiring templates to implement `Exercisable`.
type ExercisableImplementation t = HasToInterface t Exercisable
class (ExercisableImplementation t) => ExercisableHasImplementation t
instance ExercisableHasImplementation Exercisable
