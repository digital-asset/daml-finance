-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

-- | We recommend to import this module qualified.
module Daml.Finance.Interface.Account.Account where

import DA.List qualified as L (head)
import DA.Set qualified as S (toList)
import Daml.Finance.Interface.Holding.Base qualified as Base (I)
import Daml.Finance.Interface.Holding.Factory qualified as Holding (F)
import Daml.Finance.Interface.Types.Common.Types (Id, AccountKey(..), InstrumentKey(..), Parties, Quantity)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, Implementation, disclose, undisclose)
import Daml.Finance.Interface.Util.Index qualified as Index (IndexTable(..), HasIndexTable(..), I)

-- | Instance of has index table.
instance (Index.HasIndexTable I AccountKey) where
  getKey = Daml.Finance.Interface.Account.Account.toKey . view

-- | Type synonym for `Account`.
type I = Account

-- | Type synonym for `AccountKey`.
type K = AccountKey

-- | Type synonym for `View`.
type V = View

-- | Controllers of the account (related to transfers).
data Controllers = Controllers
  with
    outgoing : Parties
      -- ^ Parties instructing a transfer (outgoing).
    incoming : Parties
      -- ^ Parties approving a transfer (incoming).
  deriving (Eq, Show)

-- | View for `Account`.
data View = View
  with
    custodian : Party
      -- ^ Party providing accounting services.
    owner : Party
      -- ^ Party owning this account.
    id : Id
      -- ^ Identifier for the account.
    description : Text
      -- ^ Human readable description of the account.
    holdingFactoryCid : ContractId Holding.F
      -- ^ Associated holding factory.
    controllers : Controllers
      -- ^ Parties controlling transfers.
  deriving (Eq, Show)

-- | Convert the account's 'View' to its key.
toKey : V -> K
toKey v = AccountKey with custodian = v.custodian; owner = v.owner; id = v.id

-- | An interface which represents an established relationship between a provider and an owner.
interface Account requires Index.I where
  viewtype V

  asDisclosure : Disclosure.I
    -- ^ Conversion to `Disclosure` interface.
  getKey : AccountKey
    -- ^ Get the unique key of the `Account`.
  credit : Credit -> Update (ContractId Base.I)
    -- ^ Implementation of the `Credit` choice.
  debit : Debit -> Update ()
    -- ^ Implementation of the `Debit` choice.

  nonconsuming choice GetView : View
    -- ^ Retrieves the interface view.
    with
      viewer : Party
        -- ^ The party fetching the view.
    controller viewer
    do
      pure $ view this

  nonconsuming choice Credit : ContractId Base.I
    -- ^ Creates a new `Holding` in the corresponding `Account`.
    with
      quantity : Quantity InstrumentKey Decimal
        -- ^ The target `Instrument` and corresponding amount.
    controller (view this).custodian, (view this).controllers.incoming
    do
      credit this arg

  nonconsuming choice Debit : ()
    -- ^ Removes an existing `Holding`.
    with
      holdingCid : ContractId Base.I
        -- ^ The `Holding`'s contract id.
    controller (view this).custodian, (view this).controllers.outgoing
    do
      debit this arg

-- | Type constraint for requiring templates to implement `Account` along with `Disclosure`.
type Implementation t = (HasToInterface t I, Disclosure.Implementation t)
instance HasToInterface I Disclosure.I where _toInterface = asDisclosure
class (Implementation t) => HasImplementation t
instance HasImplementation I

-- | HIDE
discloseByKey : (Text, Parties) -> AccountKey -> Bool -> Index.IndexTable ->
  Update (ContractId Account, Index.IndexTable)
discloseByKey observersToAdd account isOutgoingController idx = do
  (cid, i) <- Index.fetchInterfaceByKey @Account @AccountKey @Account idx account
  let
    v = view i
    disclosers = if isOutgoingController then v.controllers.outgoing else v.controllers.incoming
  cid <- Disclosure.disclose @Account observersToAdd (L.head $ S.toList disclosers) disclosers cid
  pure (cid, Index.insert @Account account cid idx)

-- | HIDE
undiscloseByKey : (Text, Parties) -> AccountKey -> Bool -> Index.IndexTable ->
  Update (Optional (ContractId Account), Index.IndexTable)
undiscloseByKey observersToRemove account isOutgoingController idx = do
  (cid, i) <- Index.fetchInterfaceByKey @Account @AccountKey @Account idx account
  let
    v = view i
    disclosers = if isOutgoingController then v.controllers.outgoing else v.controllers.incoming
  oCid <- Disclosure.undisclose @Account observersToRemove disclosers cid
  pure $ optional (oCid, idx) (\cid -> (oCid, Index.insert @Account account cid idx)) oCid
