-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE AllowAmbiguousTypes #-}

-- | This module provides a collection of utilities for managing an explicit key table that is
-- used for looking up contract IDs associated with key values. The StateT monad transformer is
-- utilized to simplify the handling of the state, which is represented by the key table.
module Daml.Finance.Interface.Util.KeyTable where

import DA.Assert ((===))
import DA.Map qualified as M (Map, delete, empty, insert, lookup)
import DA.Optional (fromSomeNote)
import DA.Text (sha256)
import DA.Traversable qualified as T (mapA)
import Daml.Control.Monad.Trans.Class (lift)
import Daml.Control.Monad.Trans.State (StateT(..), get, put)
import Prelude hiding (archive, create, exercise, exerciseByKey, fetch, fetchByKey, fetchFromInterface, lookup, lookupByKey)
import qualified Prelude

-- | Type synonym for `SyntheticallyKeyed`.
type I = SyntheticallyKeyed

-- | Type synonym for `View`.
type V = View

-- | An interface for synthetically keyed interfaces.
interface SyntheticallyKeyed where
  viewtype V

-- | View for `SyntheticallyKeyed`.
data View = View {}
  deriving (Eq, Show)

-- | Key table (used for looking up contract ids for keys).
newtype KeyTable =
  KeyTable {getKeyTable : M.Map Text (ContractId SyntheticallyKeyed)} deriving (Eq, Show)

-- | Type synonym for state monad transformer (for KeyTable and Update).
type UpdateWithKey = StateT KeyTable Update

-- | Utility for running the state monad.
withKeyTable : KeyTable -> StateT KeyTable m a -> m (a, KeyTable)
withKeyTable = flip runStateT

-- A type class used for interfaces which are synthetically keyed (an instance needs to be declared
-- in the corresponding interface).
class
  ( Eq k
  , Show k
  , Ord k
  , HasFetch i
  , HasInterfaceTypeRep i
  , HasFromInterface i SyntheticallyKeyed
  , HasToInterface i SyntheticallyKeyed
  ) =>
  HasSyntheticKey i k where
    getKey : i -> k
      -- ^ Gets the key from an interface value.
    getKeyFromCid : Party -> ContractId i -> Update k
      -- ^ Gets the key of a contract ID. In order to be able to get the key of a contract, where a
      --   a party only has `readAs` rights, this is usually done by first exercising a
      --   non-consuming choice with a flexible controller (first argument), c.f. `GetView` of the
      --   `Account` interface.
    serialiseKey : k -> Text
      -- ^ Serializes the key.
    serialiseKey = sha256 . show
    insert : k -> ContractId i -> KeyTable -> KeyTable
      -- ^ Inserts an entry into an KeyTable.
    insert k cid keyTable = KeyTable
      $ M.insert (serialiseKey @i k) (toInterfaceContractId @SyntheticallyKeyed cid)
      $ getKeyTable keyTable
    delete : k -> KeyTable -> KeyTable
      -- ^ Deletes an entry from an KeyTable.
    delete k keyTable = KeyTable $ M.delete (serialiseKey @i k) $ getKeyTable keyTable
    lookup : k -> KeyTable -> Optional (ContractId i)
      -- ^ Looks up an entry from an KeyTable.
    lookup k keyTable =
      coerceInterfaceContractId @i <$> M.lookup @Text (serialiseKey @i k) (getKeyTable keyTable)

-- HIDE
instance Semigroup KeyTable where
  (<>) a b = KeyTable $ getKeyTable a <> getKeyTable b

-- HIDE
instance Monoid KeyTable where
  mempty = KeyTable M.empty
  mconcat = foldl (<>) mempty

-- | Utility function for inserting into the key table within monad m.
insertWithState :
  forall m i k.
  ( Action m
  , HasSyntheticKey i k
  ) => k -> ContractId i -> StateT KeyTable m ()
insertWithState k cid = put =<< insert k cid <$> get

-- | Utility function for deleting from the key table within monad m.
deleteWithState :
  forall m i k.
  ( Action m
  , HasSyntheticKey i k
  ) => k -> StateT KeyTable m ()
deleteWithState k = put =<< delete @i k <$> get

-- | Utility function for making key table lookups within monad m.
lookupWithState :
  forall m i k.
  ( Action m
  , HasSyntheticKey i k
  ) => k -> StateT KeyTable m (Optional (ContractId i))
lookupWithState k = lookup @i k <$> get

-- | Utility function for creating a contract instance with a key within the UpdateWithKey monad.
createWithKey :
  forall i k t.
  ( HasSyntheticKey i k
  , HasCreate t
  , HasToInterface t i
  ) => t -> UpdateWithKey (ContractId t)
createWithKey t = do
  -- create instance
  cid <- create t
  -- add entry to key table
  put =<< insert (getKey @i @k $ toInterface t) (toInterfaceContractId @i cid) <$> get
  pure cid

-- | Utility function for archiving an instance by key within the UpdateWithKey monad.
archiveByKey :
  forall i k.
  ( HasSyntheticKey i k
  , HasArchiveM UpdateWithKey i
  ) => Party -> k -> UpdateWithKey ()
archiveByKey actor k = do
  iCid <- fromSomeNote "key must exist" <$> lookupByKey @i @k actor k
  -- sanity check (verify that `k` is the correct key for the `cid`)
  (k ===) =<< lift (getKeyFromCid @i @k actor iCid)
  archive iCid
  -- delete entry from key table
  deleteWithState @Update @i k

-- | Utility function for looking up a contract instance by key within the UpdateWithKey monad.
-- The `lookupByKey` function utilizes a key `k` to obtain a `cid` from the key table. It verifies
-- whether `k` is the correct key for `cid` with help of the `getKeyFromCid` function.
lookupByKey :
  forall i k.
  HasSyntheticKey i k => Party -> k -> UpdateWithKey (Optional (ContractId i))
lookupByKey actor k = lookupWithState @Update @i k >>= T.mapA
  \cid -> do
    let iCid = coerceInterfaceContractId @i cid
    -- sanity check (verify that `k` is the correct key for the `cid`)
    (k ===) =<< lift (getKeyFromCid @i @k actor iCid)
    pure iCid

-- | Utility function for fetching an instance by key in the UpdateWithKey monad.
-- The `fetchByKey` function utilizes a key `k` to obtain a `cid` from the key table. It verifies
-- whether `k` is the correct key for `cid` with help of the `getKey` function.
fetchByKey :
  forall i1 i2 k.
  ( HasSyntheticKey i1 k
  , HasInterfaceTypeRep i2
  , HasFetch i2
  ) => k -> UpdateWithKey (ContractId i2, i2)
fetchByKey k = do
  cid <- fromSomeNote ("key table lookup for " <> show k <> " failed")
    <$> lookupWithState @Update @i1 k
  i1 <- fetch cid
  let cid2 = coerceInterfaceContractId @i2 cid
  i2 <- fetch cid2
  -- sanity check (verify that `k` is the correct key for the `cid`)
  k === getKey i1
  pure (cid2, i2)

-- | Utility function for exercising a choice by key in the UpdateWithKey monad.
exerciseByKey :
  forall i1 i2 c r k.
  ( HasSyntheticKey i1 k
  , HasInterfaceTypeRep i2
  , HasExerciseM UpdateWithKey i2 c r
  ) => Party -> k -> c -> UpdateWithKey r
exerciseByKey actor k c = do
  iCid <- fromSomeNote ("key table lookup for " <> show k <> " failed") <$> lookupByKey @i1 actor k
  exercise (coerceInterfaceContractId @i2 iCid) c

-- | Type class for creating a template instance within a monad.
class Action m => HasCreateM m t where
  create : t -> m (ContractId t)

-- | Instance used for creating a template instance within the Update monad.
instance HasCreate t => HasCreateM Update t where
  create = Prelude.create

-- | Instance used for creating a template within the UpdateWithKey monad.
instance HasCreate t => HasCreateM UpdateWithKey t where
  create = lift . Prelude.create

-- | Type class for archiving a template instance within a monad.
class Action m => HasArchiveM m t where
  archive : ContractId t -> m ()

-- | Instance used for arvhiving a template instance in the Update monad.
instance HasArchive t => HasArchiveM Update t where
  archive = Prelude.archive

-- | Instance used for arvhiving a template instance in the UpdateWithKey monad.
instance HasArchive t => HasArchiveM UpdateWithKey t where
  archive = lift . Prelude.archive

-- | Type class for fetching an instance within a monad.
class Action m => HasFetchM m t where
  fetch : ContractId t -> m t

-- | Instance used for fetching an instance in the Update monad.
instance HasFetch t => HasFetchM Update t where
  fetch = Prelude.fetch

-- | Instance used for fetching an instance in the UpdateWithKey monad.
instance HasFetch t => HasFetchM UpdateWithKey t where
  fetch = lift . Prelude.fetch

-- | Type class for fetching from interface within a monad.
class Action m => HasFetchFromInterfaceM t m i where
  fetchFromInterface : ContractId i -> m (Optional (ContractId t, t))

-- | Instance used for fetching from interface within the Update monad.
instance (HasFromInterface t i, HasFetch i) => HasFetchFromInterfaceM t Update i where
  fetchFromInterface = Prelude.fetchFromInterface @t

-- | Instance used for fetching from interface within the UpdateWithKey monad.
instance (HasFromInterface t i, HasFetch i) =>
  HasFetchFromInterfaceM t UpdateWithKey i where
    fetchFromInterface = lift . Prelude.fetchFromInterface @t

-- | Type class for exercising a choice within a monad.
class Action m => HasExerciseM m t c r where
  exercise : ContractId t -> c -> m r

-- | Instance used for exercising a choice in the Update monad.
instance HasExercise t c r => HasExerciseM Update t c r where
  exercise = Prelude.exercise

-- | Instance used for exercising a choice in the UpdateWithKey monad.
instance HasExercise t c r => HasExerciseM UpdateWithKey t c r where
  exercise cid = lift . Prelude.exercise cid

-- | Overlapping instance used to exercise (a choice with state) in the UpdateWithKey monad.
-- This function allows exercising any choice of type `a -> KeyTable -> Update (b, KeyTable)`,
-- where `a` and `b` are any serializable types. The state (i.e., the `KeyTable`) is updated with
-- the state returned by the choice, and thus each choice is responsible for modifying the state as
-- needed. For example, a consuming choice for a keyed instance (that does not recreate itself) with
-- key `k` should include a deletion of `k` from the key table. To exercise a choice, such as:
-- ```
--  template Bar
--  ...
--  choice Foo : (Int, KeyTable)
--    with
--      b : Int
--      keyTable : KeyTable
--    controller p
--    do
--      a <- get
--      pure (a + b, keyTable)
-- ```
-- within the `UpdateWithKey` monad, you can use the expression `exercise cid Foo 2`
-- (where `cid` has type `ContractId Bar`, and the `keyTable` argument of the choice is left out).
instance {-# OVERLAPPING #-} HasExercise t c (r, KeyTable) =>
  HasExerciseM UpdateWithKey t (KeyTable -> c) r where
    exercise cid f = StateT $ Prelude.exercise cid . f
