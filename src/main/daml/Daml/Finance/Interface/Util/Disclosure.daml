-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Interface.Util.Disclosure where

import DA.Map qualified as M (delete, insert, lookup, toList)
import DA.Optional (fromOptional)
import DA.Set qualified as S (Set, delete, empty, insert, null, member, fromList, toList)
import DA.Traversable qualified as T (mapA)
import Daml.Finance.Interface.Types.Common (Observers, Parties)
import Prelude hiding (null)

-- | Type synonym for `Disclosure`.
type I = Disclosure

-- | Type synonym for `View`.
type V = View

-- | View for `Disclosure`.
data View = View
  with
    disclosureControllers : S.Set Parties
      -- ^ Disjunction choice controllers.
    observers : Observers
      -- ^ Observers with context.
  deriving (Eq, Ord, Show)

-- | An interface for managing the visibility of contracts for non-authorizing parties.
interface Disclosure where
  viewtype V

  setObservers : SetObservers -> Update (ContractId Disclosure)
    -- ^ Implementation of the `SetObservers` choice.
  archive' : ContractId Disclosure -> Update ()
    -- ^ Implemetation of archiving the contract.

  nonconsuming choice GetView : View
    -- ^ Retrieves the instrument view.
    with
      viewer : Party
        -- ^ The party retrieving the view.
    controller viewer
    do
      pure $ view this

  choice SetObservers : ContractId Disclosure
    -- ^ Set the observers for a contract.
    with
      disclosers : Parties
        -- ^ Party calling this choice.
      newObservers : Observers
        -- ^ Observers to set for this contract. This overrides the existing observers.
    controller disclosers
    do
      assertMsg "controller must be authorized to SetObservers" $ disclosers `S.member` (view this).disclosureControllers
      setObservers this arg

  choice AddObservers : ContractId Disclosure
    -- ^ Add a single new observer context to the existing observers.
    with
      disclosers : Parties
        -- ^ Party calling this choice.
      observersToAdd : (Text, Parties)
        -- ^ Observer context to add to a contract.
    controller disclosers
    do
      assertMsg "controller must be authorized to AddObservers" $ disclosers `S.member` (view this).disclosureControllers
      let
        elem = fromOptional S.empty (M.lookup observersToAdd._1 (view @Disclosure this).observers)
        value = S.insert observersToAdd._2 elem
        newObservers = M.insert observersToAdd._1 value ((view this).observers)
      setObservers this (SetObservers with disclosers; newObservers)

  nonconsuming choice RemoveObservers : Optional (ContractId Disclosure)
    -- ^ Remove an observer context from the existing observers.
    -- Any party can undisclose itself. None is returned if no update is needed.
    with
      disclosers : Parties
        -- ^ Party calling this choice.
      observersToRemove : (Text, Parties)
        -- ^ Observer context to remove.
    controller disclosers
    do
      assertMsg "controller must be authorized to RemoveObservers when removing other parties"
        $ disclosers == snd observersToRemove || disclosers `S.member` (view this).disclosureControllers

      let observers = (view this).observers

      fromOptional None <$> T.mapA
        (\elem -> do
          let
            elem' = S.delete observersToRemove._2 elem
            newObservers = (
              if (S.null elem') then
                M.delete observersToRemove._1
              else
                M.insert observersToRemove._1 elem')
              observers
          if (observers == newObservers) then
            pure None
          else do
            archive' this (coerceContractId self : ContractId Disclosure)
            Some <$> setObservers this (SetObservers with disclosers = observersToRemove._2; newObservers)
       ) (M.lookup observersToRemove._1 observers)

-- | Type constraint for requiring templates to implement `Disclosure`.
type Implementation t = HasToInterface t I
class (Implementation t) => HasImplementation t
instance HasImplementation I

-- | Flattens observers into a `Set Party` for usage in template definitions. For example:
-- ```
-- observer $ flattenObservers observers
-- ```
flattenObservers : Observers -> Parties
flattenObservers (observers : Observers) =
  S.fromList $ concatMap (\t -> concatMap S.toList (S.toList t._2)) (M.toList observers)
