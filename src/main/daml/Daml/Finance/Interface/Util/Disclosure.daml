-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Interface.Util.Disclosure where

import DA.Map qualified as M (values)
import Daml.Finance.Interface.Types.Common.Types (Parties, PartiesMap)
import Daml.Finance.Interface.Util.KeyTable (HasExerciseM, exercise)
import Prelude hiding (archive, create, exercise, exerciseByKey, fetch, fetchByKey, fetchFromInterface, lookup, lookupByKey)

-- | Type synonym for `Disclosure`.
type I = Disclosure

-- | Type synonym for `View`.
type V = View

-- | View for `Disclosure`.
data View = View
  with
    disclosureControllers : Parties
      -- ^ Disjunction choice controllers.
    observers : PartiesMap
      -- ^ Observers with context.
      -- The parties are mapped by a specific key.
      -- The textual key is the "observation context" of the disclosure.
      -- This allows processes to add/remove parties for their specific purpose, without affecting
      -- others.
  deriving (Eq, Show)

-- | An interface for managing the visibility of contracts for non-authorizing parties.
interface Disclosure where
  viewtype V

  setObservers : SetObservers -> Update (ContractId Disclosure)
    -- ^ Implementation of the `SetObservers` choice.
  addObservers : AddObservers -> Update (ContractId Disclosure)
    -- ^ Implementation of the `AddObservers` choice.
  removeObservers : ContractId Disclosure -> RemoveObservers -> Update (Optional (
    ContractId Disclosure))
    -- ^ Implementation of the `RemoveObservers` choice.

  nonconsuming choice GetView : View
    -- ^ Retrieves the interface view.
    with
      viewer : Party
        -- ^ The party retrieving the view.
    controller viewer
    do
      pure $ view this

  choice SetObservers : ContractId Disclosure
    -- ^ Set the observers for a contract.
    with
      disclosers : Parties
        -- ^ Party calling this choice.
      newObservers : PartiesMap
        -- ^ Observers to set for this contract. This overrides the existing observers.
        -- The parties are mapped by a specific key.
        -- The textual key is the "observation context" of the disclosure.
        -- This allows processes to add/remove parties for their specific purpose, without affecting
        -- others.
    controller disclosers
    do
      setObservers this arg

  choice AddObservers : ContractId Disclosure
    -- ^ Add a single new observer context to the existing observers.
    with
      disclosers : Parties
        -- ^ Party calling this choice.
      observersToAdd : (Text, Parties)
        -- ^ Parties to add as observers to the contract and the corresponding observer context.
        -- If the observer context already exists, the new set of parties is added to the old one.
    controller disclosers
    do
      addObservers this arg

  nonconsuming choice RemoveObservers : Optional (ContractId Disclosure)
    -- ^ Remove observers from a context.
    -- None is returned if no update is needed. Parties for a context can be removed if any
    -- of the disclosers are part of the observers to be removed or the disclosureControllers.
    with
      disclosers : Parties
        -- ^ Parties calling this choice.
      observersToRemove : (Text, Parties)
        -- ^ Parties to be removed from the contract observers and the corresponding observer
        -- context.
    controller disclosers
    do
      removeObservers this self arg

-- | Flattens observers which use the `PartiesMap` into a `Set Party` for usage in template
-- definitions. For example:
-- ```
-- observer $ flattenObservers observers
-- ```
flattenObservers : PartiesMap -> Parties
flattenObservers = mconcat . M.values

-- | Disclose a template instance implementing the disclosure interface.
disclose :
  forall i m.
  ( Action m
  , HasExerciseM m Disclosure AddObservers (ContractId Disclosure)
  , HasToInterface i Disclosure
  , HasInterfaceTypeRep i
  ) => (Text, Parties) -> Parties -> ContractId i -> m (ContractId i)
disclose observersToAdd disclosers iCid = do
  cid : ContractId Disclosure <-
    exercise @m (toInterfaceContractId @I iCid) AddObservers with disclosers; observersToAdd
  pure $ coerceInterfaceContractId @i cid

-- | Undisclose a template instance implementing the disclosure interface.
undisclose :
  forall i m.
  ( Action m
  , HasExerciseM m Disclosure RemoveObservers (Optional (ContractId Disclosure))
  , HasToInterface i Disclosure
  , HasInterfaceTypeRep i
  ) => (Text, Parties) -> Parties -> ContractId i -> m (Optional (ContractId i))
undisclose observersToRemove disclosers iCid = do
  cid : Optional (ContractId Disclosure) <-
    exercise @m (toInterfaceContractId @I iCid) RemoveObservers with disclosers; observersToRemove
  pure $ fmap (coerceInterfaceContractId @i) cid
