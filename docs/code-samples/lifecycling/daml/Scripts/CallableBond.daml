module Scripts.CallableBond where

import DA.Date (Month(..), date)
import DA.Map qualified as M (empty, fromList)
import DA.Set qualified as S (fromList, singleton)
import Daml.Script

-- INTERFACE DEPENDENCIES --
import Daml.Finance.Interface.Instrument.Bond.Callable.Factory qualified as Callable (Create(..), F(..))
import Daml.Finance.Interface.Instrument.Bond.Callable.Types (Callable(..))
import Daml.Finance.Interface.Lifecycle.Election qualified as Election (Apply(..), Exercisable, I)
import Daml.Finance.Interface.Lifecycle.Election.Factory qualified as Election (Create(..), F)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..))
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (Evolve(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..))
import Daml.Finance.Interface.Types.Common.Types (Id(..), InstrumentKey(..))
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayConventionEnum(..))
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum(..))
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum(..))

-- IMPLEMENTATION DEPENDENCIES --
import Daml.Finance.Data.Numeric.Observation (Observation(..))
import Daml.Finance.Data.Time.DateClock (dateToDateClockTime)
import Daml.Finance.Instrument.Bond.Callable.Factory qualified as Callable (Factory(..))
import Daml.Finance.Lifecycle.Election qualified as Election (Factory(..))

import Workflow.CreditAccount qualified as CreditAccount

import Scripts.FixedRateBond (FixedRateState(..), runFixedRateBond)

-- | Test script that
-- 1. creates a callable bond instrument and a holding on it
-- 2. reuses the lifecycle rule and lifecycle event from the fixed rate bond tutorial
-- 3. lifecycles the time event
-- 4. processes the lifecycle effect
-- 5. settles the distribution
runCallableBond : Script()
runCallableBond = do

  -- Execute the `runFixedRateBond` script to reuse variables.
  FixedRateState{bank
    , bob
    , public
    , bobAccount
    , periodicSchedule
    , usdInstrument
    , holidayCalendarIds
    , lifecycleRuleCid
    , lifecycleClaimRuleCid
    , firstCouponClockEventCid} <- runFixedRateBond

  now <- getTime

  let pp = [("Public Party", S.singleton public)]

  -- Create and distribute bond
  -- CREATE_CALLABLE_BOND_VARIABLES_BEGIN
  let
    notional = 1.0
    floatingRate = None
    couponRate = 0.011
    capRate = None
    floorRate = None
    couponPeriod = M
    couponPeriodMultiplier = 3
    dayCountConvention = ActActISDA
    useAdjustedDatesForDcf = True
    businessDayConvention = Following
    noticeDays = 0
  -- CREATE_CALLABLE_BOND_VARIABLES_END

  -- CREATE_CALLABLE_BOND_INSTRUMENT_BEGIN
  -- Create a floating rate bond factory
  callableBondFactoryCid <- toInterfaceContractId @Callable.F <$> submit bank do
    createCmd Callable.Factory with
      provider = bank
      observers = M.empty

  -- Define an instrument key for the bond
  let
    instrumentId = Id "CallableBond"
    instrumentVersion = "0"
    bondInstrument = InstrumentKey with
      issuer = bank
      depository = bank
      id = instrumentId
      version = instrumentVersion

  -- Bank creates the bond instrument
  callableBondCid <- submit bank do
    exerciseCmd callableBondFactoryCid Callable.Create with
      callable = Callable with
        instrument = bondInstrument
        description = "Instrument representing units of a callable bond"
        floatingRate
        couponRate
        capRate
        floorRate
        couponSchedule = periodicSchedule
        noticeDays
        callSchedule = periodicSchedule
        holidayCalendarIds
        calendarDataProvider = bank
        dayCountConvention
        useAdjustedDatesForDcf
        currency = usdInstrument
        notional
        lastEventTimestamp = now
        prevElections = []
      observers = M.fromList pp
  -- CREATE_CALLABLE_BOND_INSTRUMENT_END

  -- CREATE_CALLABLE_BOND_HOLDING_BEGIN
  -- Credit Bob's account with a bond holding
  bobRequestCid <- submit bob do
    createCmd CreditAccount.Request with
      account = bobAccount
      instrument = bondInstrument
      amount = 100000.0
  bobBondHoldingCid <- submit bank do exerciseCmd bobRequestCid CreditAccount.Accept
  -- CREATE_CALLABLE_BOND_HOLDING_END

  -- Create election factory to allow holders to create elections
  electionFactoryCid <- submit bank do
    toInterfaceContractId @Election.F <$> createCmd Election.Factory with
      provider = bank
      observers = M.fromList [("Observers", S.fromList [bob, bank])]

  -- Create the Election
  let
    counterparty = bank
    electedTag = "CALLED"
    --electedTag = "NOT CALLED"
    amount = 100000.0
    description = "election for a callable bond"
    firstCouponDate = date 2019 May 15
  electionCid <- submit bank do
    exerciseCmd electionFactoryCid Election.Create with
      actors = S.singleton bank
      id = Id "election id"
      description
      claim = electedTag
      electionTime = dateToDateClockTime firstCouponDate
      electorIsOwner = False
      elector = bank
      counterparty
      instrument = bondInstrument
      amount
      observers = M.fromList [("Holders", S.fromList [bank, bob])]
      provider = bank

  let
    exercisableCid = coerceInterfaceContractId @Election.Exercisable lifecycleRuleCid
  -- Apply election to generate new instrument version + effects
  (newInstrumentKey, [effectCid]) <- submitMulti [bank] [public] do
    exerciseCmd electionCid Election.Apply with
      observableCids = []
      exercisableCid

{-
  -- LIFECYCLE_BOND_BEGIN
  -- Try to lifecycle the instrument
  (lifecycleCid, [effectCid]) <- submit bank do
    exerciseCmd lifecycleRuleCid Lifecycle.Evolve with
      eventCid = firstCouponClockEventCid
      observableCids = []
      instrument = bondInstrument
  -- LIFECYCLE_BOND_END

  -- Claim effect
  -- CLAIM_EFFECT_BEGIN
  result <- submitMulti [bob] [public] do
    exerciseCmd lifecycleClaimRuleCid Claim.ClaimEffect with
      claimer = bob
      holdingCids = [bobBondHoldingCid]
      effectCid -- This is equivalent to writing effectCid = effectCid
      batchId = Id "BondSettlement"
  let [bobInstructionCid, bankInstructionCid, couponInstructionCid] = result.instructionCids
  -- CLAIM_EFFECT_END

  -- EFFECT_SETTLEMENT_BEGIN
  -- Allocate instruction
  (bobInstructionCid, _) <- submit bob do
    exerciseCmd bobInstructionCid Instruction.Allocate with
      actors = S.singleton bob
      allocation = Pledge bobBondHoldingCid

  (bankInstructionCid, _) <- submit bank do
    exerciseCmd bankInstructionCid Instruction.Allocate with
      actors = S.singleton bank
      allocation = CreditReceiver

  (couponInstructionCid, _) <- submit bank do
    exerciseCmd couponInstructionCid Instruction.Allocate with
      actors = S.singleton bank
      allocation = CreditReceiver

  -- Approve instruction
  bobInstructionCid <- submit bank do
    exerciseCmd bobInstructionCid Instruction.Approve with
      actors = S.singleton bank
      approval = DebitSender

  bankInstructionCid <- submit bob do
    exerciseCmd bankInstructionCid Instruction.Approve with
      actors = S.singleton bob
      approval = TakeDelivery bobAccount

  couponInstructionCid <- submit bob do
    exerciseCmd couponInstructionCid Instruction.Approve with
      actors = S.singleton bob
      approval = TakeDelivery bobAccount

  -- Settle batch
  submitMulti [bob] [public] do
    exerciseCmd result.batchCid Batch.Settle with actors = S.singleton bob
  -- EFFECT_SETTLEMENT_END
 -}
  pure ()
