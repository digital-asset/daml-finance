module Scripts.Internal where

import DA.Set as S (fromList, singleton)
import Daml.Script

-- INTERFACE DEPENDENCIES --
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Factory qualified as Settlement (F, Instruct(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (I, Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), InstructionKey(..), RoutedStep(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentKey(..))
import Daml.Finance.Interface.Util.Common (qty)

-- IMPLEMENTATION DEPENDENCIES --
import Daml.Finance.Settlement.Factory qualified as Settlement (Factory(..))
import Daml.Finance.Settlement.Instruction qualified as Instruction (T)

import Scripts.Setup

-- | Helper container used to transfer state from one script to another.
data SetupInternalSettlement = SetupInternalSettlement
  with
    instrument : InstrumentKey
    bank : Party
    alice : Party
    aliceAccount : AccountKey
    aliceHoldingCid : ContractId Transferable.I
    bob : Party
    bobAccount : AccountKey
    charlie : Party
    charlieAccount : AccountKey
    requestor : Party
    -- routeProviderCid : ContractId RouteProvider.I
    settlementFactoryCid : ContractId Settlement.F
      -- ^ The settlement factory used to generate settlement instructions from a list of
      --   `RoutedStep`s
  deriving (Eq, Show)

runSetupInternalSettlement : Script (SetupInternalSettlement)
runSetupInternalSettlement = do
  Setup{..} <- runSetup AccountControllers with incoming = Owner; outgoing = Owner

  -- Setup a Settlement Factory facility
  -- This is used to generate settlement instructions from a list of `RoutedStep`s
  -- SETTLEMENT_FACTORY_BEGIN
  settlementFactoryCid <- toInterfaceContractId @Settlement.F <$> submit bank do
    createCmd Settlement.Factory with
      provider = bank
      observers = S.fromList [alice, bob, charlie, requestor]
  -- SETTLEMENT_FACTORY_END

  pure SetupInternalSettlement{..}

-- | Settlement 1: A debit and credit of holdings.
-- The account hiearchy where edges are accounts and the arrow heads (^v><) denote routed steps.
--            Bank
--         D ^    \ C
--          /      v
--     Alice       Bob
--
-- D: Debit
--    Bank approves with a DebitSender and Alice allocates with a Pledge.
-- C: Credit
--    Bank allocates with a CreditReceiver and Bob approves with a TakeDelivery.
--
runSettlementWithDebitAndCredit : Script ()
runSettlementWithDebitAndCredit = do

  -- SETUP_SETTLE_WITH_DEBIT_AND_CREDIT_BEGIN
  -- Setup
  SetupInternalSettlement
    { instrument
    , bank
    , alice, aliceAccount, aliceHoldingCid
    , bob, bobAccount
    , charlie, charlieAccount
    , requestor
    , settlementFactoryCid
    } <- runSetupInternalSettlement
  -- SETUP_SETTLE_WITH_DEBIT_AND_CREDIT_END

  -- SETTLE_WITH_DEBIT_AND_CREDIT_INSTRUCT_BEGIN
  -- Routed steps
  let
    routedStep1 = RoutedStep with
      custodian = bank
      sender = alice
      receiver = bank
      quantity = qty 1000.0 instrument
    routedStep2 = routedStep1 with
      sender = bank
      receiver = bob

  -- Generate settlement instructions from a list of `RoutedStep`s.
  (batchCid, [instructionCid1, instructionCid2]) <-
    submit requestor do
      exerciseCmd settlementFactoryCid Settlement.Instruct with
        instructors = fromList [requestor]
        settlers = fromList [requestor]
        id = Id "1"
        description = "Movement of holding from Alice to Bob through debit and credit"
        contextId = None
        routedSteps = [routedStep1, routedStep2]
        settlementTime = None -- i.e., immediate settlement
  -- SETTLE_WITH_DEBIT_AND_CREDIT_INSTRUCT_END

  -- SETTLE_WITH_DEBIT_AND_CREDIT_SETTLE_BEGIN
  -- i. Alice allocates
  (instructionCid1, _) <- submit alice do
    exerciseCmd instructionCid1 Instruction.Allocate with
      actors = S.singleton alice
      allocation = Pledge $ toInterfaceContractId aliceHoldingCid

  -- ii. Bob approves
  instructionCid2 <- submit bob do
    exerciseCmd instructionCid2 Instruction.Approve with
      actors = S.singleton bob
      approval = TakeDelivery bobAccount

  -- ii. Bank approves
  instructionCid1 <- submit bank do
    exerciseCmd instructionCid1 Instruction.Approve with
      actors = S.singleton bank
      approval = DebitSender
  (instructionCid2, _) <- submit bank do
    exerciseCmd instructionCid2 Instruction.Allocate with
      actors = S.singleton bank
      allocation = CreditReceiver

  -- iii. Requestor executes the settlement.
  [bobHoldingCid] <- submit requestor do
    exerciseCmd batchCid Batch.Settle with
      actors = singleton requestor
  -- SETTLE_WITH_DEBIT_AND_CREDIT_SETTLE_END

  pure ()

-- | Settlement 2: A transfer of a holding.
-- The account hiearchy where edges are accounts and the arrow heads (^v><) denote routed steps.
--
--           Bank
--          /   \
--     Alice  >  Bob
--            T
--
-- T: Transfer
--    Alice allocates with a Pledge and Bob approves with a TakeDelivery.
--
runSettlementWithTransfer : Script ()
runSettlementWithTransfer = do

  -- SETUP_SETTLE_WITH_TRANSFER_BEGIN
  -- Setup
  SetupInternalSettlement
    { instrument
    , bank
    , alice, aliceAccount, aliceHoldingCid
    , bob, bobAccount
    , charlie, charlieAccount
    , requestor
    , settlementFactoryCid
    } <- runSetupInternalSettlement
  -- SETUP_SETTLE_WITH_TRANSFER_END

  -- SETUP_SETTLE_WITH_TRANSFER_INSTRUCT_BEGIN
  -- Routed steps
  let
    routedStep = RoutedStep with
      custodian = bank
      sender = alice
      receiver = bob
      quantity = qty 1000.0 instrument

  -- Generate settlement instructions from a list of `RoutedStep`s.
  (batchCid, [instructionCid]) <-
    submit requestor do
      exerciseCmd settlementFactoryCid Settlement.Instruct with
        instructors = fromList [requestor]
        settlers = singleton requestor
        id = Id "1"
        description = "Transfer from Alice to Bob"
        contextId = None
        routedSteps = [routedStep]
        settlementTime = None -- i.e., immediate settlement
  -- SETUP_SETTLE_WITH_TRANSFER_INSTRUCT_END

  -- SETUP_SETTLE_WITH_TRANSFER_SETTLE_BEGIN
  -- i. Alice allocates
  (instructionCid, _) <- submit alice do
    exerciseCmd instructionCid Instruction.Allocate with
      actors = S.singleton alice
      allocation = Pledge $ toInterfaceContractId aliceHoldingCid

  -- i. Bob approves
  instructionCid <- submit bob do
    exerciseCmd instructionCid Instruction.Approve with
      actors = S.singleton bob
      approval = TakeDelivery bobAccount

  -- iii. Requestor executes the settlement.
  [bobHoldingCid] <- submit requestor do
    exerciseCmd batchCid Batch.Settle with
      actors = singleton requestor
  -- SETUP_SETTLE_WITH_TRANSFER_SETTLE_END

  pure ()

-- | Settlement 3: Transfer between Alice and Bob via Charlier which passes the asset through.
-- The account hiearchy where edges are accounts and the arrow heads (^v><) denote routed steps.

--               Bank
--          /     |    \
--     Alice > Charlie > Bob
--           T+       T-

-- T+: Transfer with PassThroughTo
--     Alice allocated with Pledge and Charlie approves with PassThroughTo
-- T-: Transfer with PassThroughFrom
--     Charlied allocates with PassThroughFrom and Bob approves with TakeDelivery.

runSettlementWithPassThrough : Script ()
runSettlementWithPassThrough = do

  -- SETUP_SETTLE_WITH_PASS_THROUGH_BEGIN
  -- Setup
  SetupInternalSettlement
    { instrument
    , bank
    , alice, aliceAccount, aliceHoldingCid
    , bob, bobAccount
    , charlie, charlieAccount
    , requestor
    , settlementFactoryCid
    } <- runSetupInternalSettlement
  -- SETUP_SETTLE_WITH_PASS_THROUGH_END

  -- SETUP_SETTLE_WITH_PASS_THROUGH_INSTRUCT_BEGIN
  -- Routed steps
  let
    routedStep1 = RoutedStep with
      custodian = bank
      sender = alice
      receiver = charlie
      quantity = qty 1000.0 instrument
    routedStep2 = routedStep1 with
      sender = charlie
      receiver = bob

  -- Generate settlement instructions from a list of `RoutedStep`s.
  (batchCid, [instructionCid1, instructionCid2]) <-
    submit requestor do
      exerciseCmd settlementFactoryCid Settlement.Instruct with
        instructors = fromList [requestor]
        settlers = singleton requestor
        id = Id "1"
        description = "Transfer from Alice to Bob via Charlie"
        contextId = None
        routedSteps = [routedStep1, routedStep2]
        settlementTime = None -- i.e., immediate settlement
  -- SETUP_SETTLE_WITH_PASS_THROUGH_INSTRUCT_END

  -- SETUP_SETTLE_WITH_PASS_THROUGH_SETTLE_BEGIN
  -- i. Alice allocates
  (instructionCid1, _) <- submit alice do
    exerciseCmd instructionCid1 Instruction.Allocate with
      actors = S.singleton alice
      allocation = Pledge $ toInterfaceContractId aliceHoldingCid

  -- ii. Bob approves
  instructionCid2 <- submit bob do
    exerciseCmd instructionCid2 Instruction.Approve with
      actors = S.singleton bob
      approval = TakeDelivery bobAccount

  -- iii. Charlie lets holding pass through
  instructionKey2 <- retrieveKey charlie instructionCid2
  instructionCid1 <- submit charlie do
    exerciseCmd instructionCid1 Instruction.Approve with
      actors = S.singleton charlie
      approval = PassThroughTo (charlieAccount, instructionKey2)
  instructionKey1 <- retrieveKey charlie instructionCid1
  instructionCid2 <- submit charlie do
    exerciseCmd instructionCid2 Instruction.Allocate with
      actors = S.singleton charlie
      allocation = PassThroughFrom (charlieAccount, instructionKey1)

  -- iii. Requestor executes the settlement.
  [bobHoldingCid] <- submitMulti [requestor] [] do
    exerciseCmd batchCid Batch.Settle with
      actors = singleton requestor
  -- SETUP_SETTLE_WITH_PASS_THROUGH_SETTLE_END

  pure ()

-- | Utility function for retrieving the key of an instruction.
retrieveKey : Party -> ContractId Instruction.I -> Script InstructionKey
retrieveKey actor cid = script do
  Some i <- queryContractId actor (fromInterfaceContractId @Instruction.T cid)
  pure $ key i
